{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>\u2139\ufe0f Created with AI and there mey be errors.</p>"},{"location":"#build-custom-n8n-nodes-like-a-pro","title":"Build Custom n8n Nodes Like a Pro \ud83d\ude80","text":"<p>Welcome to the n8n Custom Nodes Guide \u2014 your comprehensive resource for building, testing, and publishing custom nodes for n8n, the extendable workflow automation tool.</p> <p>Whether you're building a quick internal integration or a polished community node, this guide has you covered with real-world examples, API references, and reusable patterns.</p> <p></p>"},{"location":"#what-youll-find-here","title":"\ud83e\udded What You'll Find Here","text":"<ul> <li>\ud83d\udcda Public Node API \u2014 Learn how to use the <code>IExecuteFunctions</code> context, access parameters, and return data.</li> <li>\ud83e\udde9 Node Patterns \u2014 Choose from Declarative, Programmatic, or Modular Declarative patterns depending on your use case.</li> <li>\ud83d\udd10 Credential Strategies \u2014 Implement secure authentication using API keys, OAuth2, service accounts, and more.</li> <li>\ud83e\uddea Real-World Examples \u2014 See how production-grade nodes like PowerBI, WebSocket, and Apify are built.</li> <li>\ud83c\udfa8 UI &amp; UX \u2014 Customize your node's appearance and behavior in the n8n editor.</li> </ul>"},{"location":"#quick-start","title":"\u26a1 Quick Start","text":"<p>Here's a minimal but valid n8n node to get you started:</p> <pre><code>import { INodeType, INodeTypeDescription, IExecuteFunctions } from 'n8n-workflow'\n\nexport class HelloWorldNode implements INodeType {\n  description: INodeTypeDescription = {\n    displayName: 'Hello World',\n    name: 'helloWorld',\n    group: ['transform'],\n    version: 1,\n    description: 'Returns a simple greeting',\n    defaults: {\n      name: 'Hello World',\n    },\n    inputs: ['main'],\n    outputs: ['main'],\n    properties: [],\n  }\n\n  async execute(this: IExecuteFunctions) {\n    return [ [{ json: { hello: 'world' } }] ]\n  }\n}\n</code></pre> <p>Ready to dive deeper?</p> <ul> <li>Start with the Public API \u2192</li> <li>Pick a Node Pattern \u2192</li> <li>Browse Real Examples \u2192</li> </ul>"},{"location":"#choose-your-path","title":"\ud83c\udfaf Choose Your Path","text":""},{"location":"#new-to-n8n-node-development","title":"\ud83c\udd95 New to n8n Node Development?","text":"<p>Start with the Public API Overview to understand the core concepts, then explore the Declarative Pattern for the simplest approach.</p>"},{"location":"#building-complex-logic","title":"\ud83d\udd27 Building Complex Logic?","text":"<p>Jump to the Programmatic Pattern for full control, or check out the Modular Declarative Pattern for the best of both worlds.</p>"},{"location":"#need-authentication","title":"\ud83d\udd10 Need Authentication?","text":"<p>Browse our Credential Patterns to implement secure API connections with OAuth2, service accounts, and more.</p>"},{"location":"#want-real-examples","title":"\ud83e\uddea Want Real Examples?","text":"<p>Explore our Real-World Examples to see how production nodes handle complex scenarios like WebSockets, binary data, and external APIs.</p>"},{"location":"#why-this-guide","title":"\ud83e\udde0 Why This Guide?","text":"<p>This isn't just a reference \u2014 it's a battle-tested playbook for building maintainable, scalable, and user-friendly n8n nodes. It's written by a developer (hi, I'm Mrowr \ud83d\udc3e) who's been deep in the node ecosystem and wants to make your life easier.</p> <p>What makes this different:</p> <ul> <li>\u2705 Real-world focus \u2014 Examples from actual production nodes</li> <li>\u2705 Pattern-driven \u2014 Clear architectural guidance for different use cases</li> <li>\u2705 Comprehensive API docs \u2014 Every helper, context, and interface explained</li> <li>\u2705 Best practices \u2014 Error handling, testing, and UX considerations</li> <li>\u2705 Copy-paste ready \u2014 Code you can actually use</li> </ul>"},{"location":"#ready-to-build","title":"\ud83d\udee0\ufe0f Ready to Build?","text":"<p>Use the navigation sidebar to explore, or jump straight to these popular sections:</p> <ul> <li>Helpers Overview \u2014 HTTP requests, binary data, filesystem operations</li> <li>Execution Contexts \u2014 Understanding the <code>this</code> context in your nodes</li> <li>Parameter Access \u2014 Reading user inputs and configuration</li> <li>Error Handling \u2014 Graceful failures and user-friendly messages</li> <li>UI &amp; UX \u2014 Making your nodes intuitive and polished</li> </ul>"},{"location":"#whats-next","title":"\ud83d\ude80 What's Next?","text":"<p>Once you've built your first node, consider:</p> <ul> <li>Publishing to the n8n Community Nodes registry</li> <li>Contributing examples back to this guide</li> <li>Joining the n8n Community to share your creations</li> </ul> <p>Happy building! \ud83c\udf89</p>"},{"location":"advanced/BinaryData/","title":"Binary Data Manipulation","text":"<p>Working with binary data in n8n nodes allows you to handle files, images, documents, and other non-text content.</p>"},{"location":"advanced/BinaryData/#key-concepts","title":"Key Concepts","text":"<ul> <li>Use <code>prepareBinaryData()</code> to create binary data objects</li> <li>Binary data includes metadata (filename, mimeType, fileExtension)</li> <li>Access binary data from input items or create new binary data</li> <li>Handle multiple binary properties per item</li> </ul>"},{"location":"advanced/BinaryData/#binary-data-structure","title":"Binary Data Structure","text":"<pre><code>interface IBinaryData {\n  data: string;           // Base64 encoded data\n  mimeType: string;       // MIME type (e.g., 'image/png')\n  fileName?: string;      // Original filename\n  fileExtension?: string; // File extension\n  directory?: string;     // Directory path (for file storage)\n}\n</code></pre>"},{"location":"advanced/BinaryData/#complete-binary-data-examples","title":"Complete Binary Data Examples","text":""},{"location":"advanced/BinaryData/#file-processing-node","title":"File Processing Node","text":"<pre><code>import {\n  IExecuteFunctions,\n  INodeExecutionData,\n  INodeType,\n  INodeTypeDescription,\n  NodeOperationError,\n} from 'n8n-workflow';\nimport { createReadStream, createWriteStream, promises as fs } from 'fs';\nimport { pipeline } from 'stream/promises';\nimport * as path from 'path';\nimport * as crypto from 'crypto';\n\nexport class BinaryDataExample implements INodeType {\n  description: INodeTypeDescription = {\n    displayName: 'Binary Data Example',\n    name: 'binaryDataExample',\n    group: ['transform'],\n    version: 1,\n    description: 'Demonstrates comprehensive binary data handling',\n    defaults: {\n      name: 'Binary Data Example',\n    },\n    inputs: ['main'],\n    outputs: ['main'],\n    properties: [\n      {\n        displayName: 'Operation',\n        name: 'operation',\n        type: 'options',\n        noDataExpression: true,\n        options: [\n          {\n            name: 'Read File',\n            value: 'readFile',\n            description: 'Read a file and convert to binary data',\n          },\n          {\n            name: 'Write File',\n            value: 'writeFile',\n            description: 'Write binary data to a file',\n          },\n          {\n            name: 'Convert Image',\n            value: 'convertImage',\n            description: 'Convert image format and resize',\n          },\n          {\n            name: 'Create Archive',\n            value: 'createArchive',\n            description: 'Create a ZIP archive from multiple files',\n          },\n          {\n            name: 'Extract Text',\n            value: 'extractText',\n            description: 'Extract text from PDF or document',\n          },\n          {\n            name: 'Generate File',\n            value: 'generateFile',\n            description: 'Generate various file types',\n          },\n        ],\n        default: 'readFile',\n      },\n      {\n        displayName: 'File Path',\n        name: 'filePath',\n        type: 'string',\n        displayOptions: {\n          show: {\n            operation: ['readFile', 'writeFile'],\n          },\n        },\n        default: '',\n        description: 'Path to the file',\n      },\n      {\n        displayName: 'Binary Property',\n        name: 'binaryProperty',\n        type: 'string',\n        displayOptions: {\n          show: {\n            operation: ['writeFile', 'convertImage', 'extractText'],\n          },\n        },\n        default: 'data',\n        description: 'Name of the binary property to process',\n      },\n      {\n        displayName: 'Output Format',\n        name: 'outputFormat',\n        type: 'options',\n        displayOptions: {\n          show: {\n            operation: ['convertImage'],\n          },\n        },\n        options: [\n          { name: 'PNG', value: 'png' },\n          { name: 'JPEG', value: 'jpeg' },\n          { name: 'WebP', value: 'webp' },\n          { name: 'GIF', value: 'gif' },\n        ],\n        default: 'png',\n        description: 'Output image format',\n      },\n      {\n        displayName: 'File Type',\n        name: 'fileType',\n        type: 'options',\n        displayOptions: {\n          show: {\n            operation: ['generateFile'],\n          },\n        },\n        options: [\n          { name: 'CSV', value: 'csv' },\n          { name: 'JSON', value: 'json' },\n          { name: 'XML', value: 'xml' },\n          { name: 'PDF', value: 'pdf' },\n          { name: 'Image', value: 'image' },\n        ],\n        default: 'csv',\n        description: 'Type of file to generate',\n      },\n      {\n        displayName: 'Processing Options',\n        name: 'processingOptions',\n        type: 'collection',\n        placeholder: 'Add Option',\n        default: {},\n        options: [\n          {\n            displayName: 'Max File Size (MB)',\n            name: 'maxFileSize',\n            type: 'number',\n            default: 50,\n            description: 'Maximum file size to process',\n          },\n          {\n            displayName: 'Preserve Metadata',\n            name: 'preserveMetadata',\n            type: 'boolean',\n            default: true,\n            description: 'Preserve file metadata when processing',\n          },\n          {\n            displayName: 'Compression Level',\n            name: 'compressionLevel',\n            type: 'number',\n            default: 6,\n            description: 'Compression level (0-9)',\n          },\n          {\n            displayName: 'Image Width',\n            name: 'imageWidth',\n            type: 'number',\n            default: 800,\n            description: 'Target image width for resizing',\n          },\n          {\n            displayName: 'Image Height',\n            name: 'imageHeight',\n            type: 'number',\n            default: 600,\n            description: 'Target image height for resizing',\n          },\n        ],\n      },\n    ],\n  };\n\n  async execute(this: IExecuteFunctions): Promise&lt;INodeExecutionData[][]&gt; {\n    const items = this.getInputData();\n    const returnData: INodeExecutionData[] = [];\n    const operation = this.getNodeParameter('operation', 0) as string;\n\n    for (let i = 0; i &lt; items.length; i++) {\n      try {\n        let result: INodeExecutionData;\n\n        switch (operation) {\n          case 'readFile':\n            result = await this.readFile(i);\n            break;\n          case 'writeFile':\n            result = await this.writeFile(i, items[i]);\n            break;\n          case 'convertImage':\n            result = await this.convertImage(i, items[i]);\n            break;\n          case 'createArchive':\n            result = await this.createArchive(i, items[i]);\n            break;\n          case 'extractText':\n            result = await this.extractText(i, items[i]);\n            break;\n          case 'generateFile':\n            result = await this.generateFile(i);\n            break;\n          default:\n            throw new NodeOperationError(\n              this.getNode(),\n              `Unknown operation: ${operation}`,\n              { itemIndex: i }\n            );\n        }\n\n        returnData.push(result);\n\n      } catch (error) {\n        throw new NodeOperationError(\n          this.getNode(),\n          `Error in operation ${operation}: ${error.message}`,\n          { itemIndex: i }\n        );\n      }\n    }\n\n    return [returnData];\n  }\n\n  private async readFile(itemIndex: number): Promise&lt;INodeExecutionData&gt; {\n    const filePath = this.getNodeParameter('filePath', itemIndex) as string;\n    const processingOptions = this.getNodeParameter('processingOptions', itemIndex, {}) as any;\n\n    if (!filePath) {\n      throw new NodeOperationError(\n        this.getNode(),\n        'File path is required',\n        { itemIndex }\n      );\n    }\n\n    try {\n      // Check if file exists and get stats\n      const stats = await fs.stat(filePath);\n\n      if (!stats.isFile()) {\n        throw new NodeOperationError(\n          this.getNode(),\n          `Path is not a file: ${filePath}`,\n          { itemIndex }\n        );\n      }\n\n      // Check file size\n      const maxSize = (processingOptions.maxFileSize || 50) * 1024 * 1024;\n      if (stats.size &gt; maxSize) {\n        throw new NodeOperationError(\n          this.getNode(),\n          `File too large: ${(stats.size / 1024 / 1024).toFixed(2)}MB (max: ${processingOptions.maxFileSize || 50}MB)`,\n          { itemIndex }\n        );\n      }\n\n      // Read file as buffer\n      const buffer = await fs.readFile(filePath);\n\n      // Determine MIME type based on file extension\n      const ext = path.extname(filePath).toLowerCase();\n      const mimeType = this.getMimeType(ext);\n      const fileName = path.basename(filePath);\n\n      // Create binary data\n      const binaryData = await this.helpers.prepareBinaryData(\n        buffer,\n        fileName,\n        mimeType\n      );\n\n      // Calculate file hash for integrity\n      const hash = crypto.createHash('sha256').update(buffer).digest('hex');\n\n      return {\n        json: {\n          success: true,\n          fileName,\n          filePath,\n          fileSize: stats.size,\n          fileSizeFormatted: this.formatFileSize(stats.size),\n          mimeType,\n          fileExtension: ext,\n          hash,\n          created: stats.birthtime,\n          modified: stats.mtime,\n        },\n        binary: {\n          data: binaryData,\n        },\n      };\n\n    } catch (error) {\n      if (error.code === 'ENOENT') {\n        throw new NodeOperationError(\n          this.getNode(),\n          `File not found: ${filePath}`,\n          { itemIndex }\n        );\n      }\n      throw error;\n    }\n  }\n\n  private async writeFile(itemIndex: number, item: INodeExecutionData): Promise&lt;INodeExecutionData&gt; {\n    const filePath = this.getNodeParameter('filePath', itemIndex) as string;\n    const binaryProperty = this.getNodeParameter('binaryProperty', itemIndex) as string;\n\n    if (!filePath) {\n      throw new NodeOperationError(\n        this.getNode(),\n        'File path is required',\n        { itemIndex }\n      );\n    }\n\n    if (!item.binary || !item.binary[binaryProperty]) {\n      throw new NodeOperationError(\n        this.getNode(),\n        `No binary data found in property: ${binaryProperty}`,\n        { itemIndex }\n      );\n    }\n\n    const binaryData = item.binary[binaryProperty];\n\n    try {\n      // Ensure directory exists\n      const dir = path.dirname(filePath);\n      await fs.mkdir(dir, { recursive: true });\n\n      // Convert base64 to buffer and write file\n      const buffer = Buffer.from(binaryData.data, 'base64');\n      await fs.writeFile(filePath, buffer);\n\n      // Get file stats after writing\n      const stats = await fs.stat(filePath);\n\n      return {\n        json: {\n          success: true,\n          filePath,\n          fileName: binaryData.fileName || path.basename(filePath),\n          fileSize: stats.size,\n          fileSizeFormatted: this.formatFileSize(stats.size),\n          mimeType: binaryData.mimeType,\n          written: new Date().toISOString(),\n        },\n      };\n\n    } catch (error) {\n      throw new NodeOperationError(\n        this.getNode(),\n        `Failed to write file: ${error.message}`,\n        { itemIndex }\n      );\n    }\n  }\n\n  private async convertImage(itemIndex: number, item: INodeExecutionData): Promise&lt;INodeExecutionData&gt; {\n    const binaryProperty = this.getNodeParameter('binaryProperty', itemIndex) as string;\n    const outputFormat = this.getNodeParameter('outputFormat', itemIndex) as string;\n    const processingOptions = this.getNodeParameter('processingOptions', itemIndex, {}) as any;\n\n    if (!item.binary || !item.binary[binaryProperty]) {\n      throw new NodeOperationError(\n        this.getNode(),\n        `No binary data found in property: ${binaryProperty}`,\n        { itemIndex }\n      );\n    }\n\n    const binaryData = item.binary[binaryProperty];\n\n    // Check if it's an image\n    if (!binaryData.mimeType?.startsWith('image/')) {\n      throw new NodeOperationError(\n        this.getNode(),\n        `Binary data is not an image: ${binaryData.mimeType}`,\n        { itemIndex }\n      );\n    }\n\n    try {\n      // For this example, we'll simulate image processing\n      // In a real implementation, you'd use a library like Sharp\n      const inputBuffer = Buffer.from(binaryData.data, 'base64');\n\n      // Simulate image conversion and resizing\n      const processedBuffer = await this.simulateImageProcessing(\n        inputBuffer,\n        outputFormat,\n        processingOptions.imageWidth || 800,\n        processingOptions.imageHeight || 600\n      );\n\n      // Create new filename with new extension\n      const originalName = binaryData.fileName || 'image';\n      const baseName = path.parse(originalName).name;\n      const newFileName = `${baseName}_converted.${outputFormat}`;\n      const newMimeType = `image/${outputFormat}`;\n\n      // Create new binary data\n      const newBinaryData = await this.helpers.prepareBinaryData(\n        processedBuffer,\n        newFileName,\n        newMimeType\n      );\n\n      return {\n        json: {\n          success: true,\n          originalFormat: binaryData.mimeType,\n          newFormat: newMimeType,\n          originalSize: inputBuffer.length,\n          newSize: processedBuffer.length,\n          compressionRatio: ((inputBuffer.length - processedBuffer.length) / inputBuffer.length * 100).toFixed(2) + '%',\n          dimensions: {\n            width: processingOptions.imageWidth || 800,\n            height: processingOptions.imageHeight || 600,\n          },\n        },\n        binary: {\n          data: newBinaryData,\n        },\n      };\n\n    } catch (error) {\n      throw new NodeOperationError(\n        this.getNode(),\n        `Image conversion failed: ${error.message}`,\n        { itemIndex }\n      );\n    }\n  }\n\n  private async createArchive(itemIndex: number, item: INodeExecutionData): Promise&lt;INodeExecutionData&gt; {\n    // Simulate creating a ZIP archive from multiple binary properties\n    const archiveEntries: Array&lt;{ name: string; data: Buffer }&gt; = [];\n\n    if (item.binary) {\n      for (const [propertyName, binaryData] of Object.entries(item.binary)) {\n        const buffer = Buffer.from(binaryData.data, 'base64');\n        const fileName = binaryData.fileName || `${propertyName}.bin`;\n        archiveEntries.push({ name: fileName, data: buffer });\n      }\n    }\n\n    if (archiveEntries.length === 0) {\n      throw new NodeOperationError(\n        this.getNode(),\n        'No binary data found to archive',\n        { itemIndex }\n      );\n    }\n\n    try {\n      // Simulate ZIP creation (in real implementation, use a ZIP library)\n      const archiveBuffer = await this.simulateZipCreation(archiveEntries);\n\n      const archiveName = `archive_${Date.now()}.zip`;\n      const binaryData = await this.helpers.prepareBinaryData(\n        archiveBuffer,\n        archiveName,\n        'application/zip'\n      );\n\n      return {\n        json: {\n          success: true,\n          archiveName,\n          fileCount: archiveEntries.length,\n          files: archiveEntries.map(entry =&gt; entry.name),\n          archiveSize: archiveBuffer.length,\n          archiveSizeFormatted: this.formatFileSize(archiveBuffer.length),\n        },\n        binary: {\n          archive: binaryData,\n        },\n      };\n\n    } catch (error) {\n      throw new NodeOperationError(\n        this.getNode(),\n        `Archive creation failed: ${error.message}`,\n        { itemIndex }\n      );\n    }\n  }\n\n  private async extractText(itemIndex: number, item: INodeExecutionData): Promise&lt;INodeExecutionData&gt; {\n    const binaryProperty = this.getNodeParameter('binaryProperty', itemIndex) as string;\n\n    if (!item.binary || !item.binary[binaryProperty]) {\n      throw new NodeOperationError(\n        this.getNode(),\n        `No binary data found in property: ${binaryProperty}`,\n        { itemIndex }\n      );\n    }\n\n    const binaryData = item.binary[binaryProperty];\n    const buffer = Buffer.from(binaryData.data, 'base64');\n\n    try {\n      let extractedText = '';\n      let metadata: any = {};\n\n      // Handle different file types\n      if (binaryData.mimeType === 'application/pdf') {\n        // Simulate PDF text extraction\n        const result = await this.simulatePdfTextExtraction(buffer);\n        extractedText = result.text;\n        metadata = result.metadata;\n      } else if (binaryData.mimeType?.includes('text/')) {\n        // Handle text files\n        extractedText = buffer.toString('utf-8');\n        metadata = { encoding: 'utf-8', lineCount: extractedText.split('\\n').length };\n      } else if (binaryData.mimeType?.startsWith('image/')) {\n        // Simulate OCR for images\n        const result = await this.simulateOcrExtraction(buffer);\n        extractedText = result.text;\n        metadata = result.metadata;\n      } else {\n        throw new NodeOperationError(\n          this.getNode(),\n          `Unsupported file type for text extraction: ${binaryData.mimeType}`,\n          { itemIndex }\n        );\n      }\n\n      return {\n        json: {\n          success: true,\n          fileName: binaryData.fileName,\n          mimeType: binaryData.mimeType,\n          extractedText,\n          textLength: extractedText.length,\n          wordCount: extractedText.split(/\\s+/).filter(word =&gt; word.length &gt; 0).length,\n          metadata,\n        },\n      };\n\n    } catch (error) {\n      throw new NodeOperationError(\n        this.getNode(),\n        `Text extraction failed: ${error.message}`,\n        { itemIndex }\n      );\n    }\n  }\n\n  private async generateFile(itemIndex: number): Promise&lt;INodeExecutionData&gt; {\n    const fileType = this.getNodeParameter('fileType', itemIndex) as string;\n\n    try {\n      let buffer: Buffer;\n      let fileName: string;\n      let mimeType: string;\n\n      switch (fileType) {\n        case 'csv':\n          const csvData = this.generateCsvData();\n          buffer = Buffer.from(csvData, 'utf-8');\n          fileName = `data_${Date.now()}.csv`;\n          mimeType = 'text/csv';\n          break;\n\n        case 'json':\n          const jsonData = this.generateJsonData();\n          buffer = Buffer.from(JSON.stringify(jsonData, null, 2), 'utf-8');\n          fileName = `data_${Date.now()}.json`;\n          mimeType = 'application/json';\n          break;\n\n        case 'xml':\n          const xmlData = this.generateXmlData();\n          buffer = Buffer.from(xmlData, 'utf-8');\n          fileName = `data_${Date.now()}.xml`;\n          mimeType = 'application/xml';\n          break;\n\n        case 'pdf':\n          buffer = await this.generatePdfData();\n          fileName = `document_${Date.now()}.pdf`;\n          mimeType = 'application/pdf';\n          break;\n\n        case 'image':\n          buffer = await this.generateImageData();\n          fileName = `image_${Date.now()}.png`;\n          mimeType = 'image/png';\n          break;\n\n        default:\n          throw new NodeOperationError(\n            this.getNode(),\n            `Unsupported file type: ${fileType}`,\n            { itemIndex }\n          );\n      }\n\n      const binaryData = await this.helpers.prepareBinaryData(\n        buffer,\n        fileName,\n        mimeType\n      );\n\n      return {\n        json: {\n          success: true,\n          fileType,\n          fileName,\n          mimeType,\n          fileSize: buffer.length,\n          fileSizeFormatted: this.formatFileSize(buffer.length),\n          generated: new Date().toISOString(),\n        },\n        binary: {\n          data: binaryData,\n        },\n      };\n\n    } catch (error) {\n      throw new NodeOperationError(\n        this.getNode(),\n        `File generation failed: ${error.message}`,\n        { itemIndex }\n      );\n    }\n  }\n\n  // Helper methods for file processing simulation\n  private getMimeType(extension: string): string {\n    const mimeTypes: { [key: string]: string } = {\n      '.txt': 'text/plain',\n      '.csv': 'text/csv',\n      '.json': 'application/json',\n      '.xml': 'application/xml',\n      '.pdf': 'application/pdf',\n      '.png': 'image/png',\n      '.jpg': 'image/jpeg',\n      '.jpeg': 'image/jpeg',\n      '.gif': 'image/gif',\n      '.webp': 'image/webp',\n      '.zip': 'application/zip',\n      '.doc': 'application/msword',\n      '.docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n      '.xls': 'application/vnd.ms-excel',\n      '.xlsx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n    };\n\n    return mimeTypes[extension] || 'application/octet-stream';\n  }\n\n  private formatFileSize(bytes: number): string {\n    const sizes = ['Bytes', 'KB', 'MB', 'GB'];\n    if (bytes === 0) return '0 Bytes';\n    const i = Math.floor(Math.log(bytes) / Math.log(1024));\n    return Math.round(bytes / Math.pow(1024, i) * 100) / 100 + ' ' + sizes[i];\n  }\n\n  private async simulateImageProcessing(\n    buffer: Buffer,\n    format: string,\n    width: number,\n    height: number\n  ): Promise&lt;Buffer&gt; {\n    // Simulate image processing - in real implementation use Sharp or similar\n    // For demo, just return a smaller buffer to simulate compression\n    const compressionRatio = 0.7;\n    const newSize = Math.floor(buffer.length * compressionRatio);\n    return Buffer.alloc(newSize, buffer[0]);\n  }\n\n  private async simulateZipCreation(entries: Array&lt;{ name: string; data: Buffer }&gt;): Promise&lt;Buffer&gt; {\n    // Simulate ZIP creation - in real implementation use node-stream-zip or similar\n    const totalSize = entries.reduce((sum, entry) =&gt; sum + entry.data.length, 0);\n    const zipHeader = Buffer.from('PK\\x03\\x04'); // ZIP file signature\n    const simulatedZip = Buffer.concat([zipHeader, Buffer.alloc(totalSize * 0.8)]);\n    return simulatedZip;\n  }\n\n  private async simulatePdfTextExtraction(buffer: Buffer): Promise&lt;{ text: string; metadata: any }&gt; {\n    // Simulate PDF text extraction - in real implementation use pdf-parse or similar\n    return {\n      text: 'This is simulated text extracted from a PDF document. In a real implementation, you would use a PDF parsing library.',\n      metadata: {\n        pages: 1,\n        title: 'Sample Document',\n        author: 'n8n',\n        creationDate: new Date().toISOString(),\n      },\n    };\n  }\n\n  private async simulateOcrExtraction(buffer: Buffer): Promise&lt;{ text: string; metadata: any }&gt; {\n    // Simulate OCR text extraction - in real implementation use tesseract.js or similar\n    return {\n      text: 'This is simulated text extracted from an image using OCR. In a real implementation, you would use an OCR library.',\n      metadata: {\n        confidence: 0.95,\n        language: 'eng',\n        processingTime: '2.3s',\n      },\n    };\n  }\n\n  private generateCsvData(): string {\n    const headers = ['ID', 'Name', 'Email', 'Age', 'City'];\n    const rows = [\n      ['1', 'John Doe', 'john@example.com', '30', 'New York'],\n      ['2', 'Jane Smith', 'jane@example.com', '25', 'Los Angeles'],\n      ['3', 'Bob Johnson', 'bob@example.com', '35', 'Chicago'],\n    ];\n\n    return [headers, ...rows].map(row =&gt; row.join(',')).join('\\n');\n  }\n\n  private generateJsonData(): any {\n    return {\n      users: [\n        { id: 1, name: 'John Doe', email: 'john@example.com', age: 30, city: 'New York' },\n        { id: 2, name: 'Jane Smith', email: 'jane@example.com', age: 25, city: 'Los Angeles' },\n        { id: 3, name: 'Bob Johnson', email: 'bob@example.com', age: 35, city: 'Chicago' },\n      ],\n      metadata: {\n        generated: new Date().toISOString(),\n        count: 3,\n        version: '1.0',\n      },\n    };\n  }\n\n  private generateXmlData(): string {\n    return `&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;users&gt;\n  &lt;user id=\"1\"&gt;\n    &lt;name&gt;John Doe&lt;/name&gt;\n    &lt;email&gt;john@example.com&lt;/email&gt;\n    &lt;age&gt;30&lt;/age&gt;\n    &lt;city&gt;New York&lt;/city&gt;\n  &lt;/user&gt;\n  &lt;user id=\"2\"&gt;\n    &lt;name&gt;Jane Smith&lt;/name&gt;\n    &lt;email&gt;jane@example.com&lt;/email&gt;\n    &lt;age&gt;25&lt;/age&gt;\n    &lt;city&gt;Los Angeles&lt;/city&gt;\n  &lt;/user&gt;\n  &lt;user id=\"3\"&gt;\n    &lt;name&gt;Bob Johnson&lt;/name&gt;\n    &lt;email&gt;bob@example.com&lt;/email&gt;\n    &lt;age&gt;35&lt;/age&gt;\n    &lt;city&gt;Chicago&lt;/city&gt;\n  &lt;/user&gt;\n&lt;/users&gt;`;\n  }\n\n  private async generatePdfData(): Promise&lt;Buffer&gt; {\n    // Simulate PDF generation - in real implementation use PDFKit or similar\n    const pdfHeader = Buffer.from('%PDF-1.4\\n');\n    const pdfContent = Buffer.from('Simulated PDF content');\n    return Buffer.concat([pdfHeader, pdfContent]);\n  }\n\n  private async generateImageData(): Promise&lt;Buffer&gt; {\n    // Simulate image generation - in real implementation use Canvas or similar\n    // Create a simple PNG header for demonstration\n    const pngSignature = Buffer.from([0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A]);\n    const simulatedImageData = Buffer.alloc(1000, 0xFF); // White pixels\n    return Buffer.concat([pngSignature, simulatedImageData]);\n  }\n}\n</code></pre> <p>Key Binary Data Patterns:</p> <ol> <li> <p>Reading Files: <pre><code>const buffer = await fs.readFile(filePath);\nconst binaryData = await this.helpers.prepareBinaryData(buffer, fileName, mimeType);\n</code></pre></p> </li> <li> <p>Writing Files: <pre><code>const buffer = Buffer.from(binaryData.data, 'base64');\nawait fs.writeFile(filePath, buffer);\n</code></pre></p> </li> <li> <p>Processing Binary Data: <pre><code>const inputBuffer = Buffer.from(binaryData.data, 'base64');\nconst processedBuffer = await processImage(inputBuffer);\nconst newBinaryData = await this.helpers.prepareBinaryData(processedBuffer, newFileName, newMimeType);\n</code></pre></p> </li> <li> <p>Multiple Binary Properties: <pre><code>return {\n  json: { success: true },\n  binary: {\n    original: originalBinaryData,\n    processed: processedBinaryData,\n    thumbnail: thumbnailBinaryData,\n  },\n};\n</code></pre></p> </li> <li> <p>Binary Data Validation: <pre><code>if (!item.binary || !item.binary[binaryProperty]) {\n  throw new NodeOperationError(this.getNode(), `No binary data found in property: ${binaryProperty}`);\n}\n</code></pre></p> </li> </ol> <p>This comprehensive binary data handling approach enables nodes to work with any type of file or binary content efficiently and safely!</p>"},{"location":"advanced/CustomValidation/","title":"Custom Validation","text":"<p>Custom validation ensures data integrity and provides clear feedback when inputs don't meet requirements.</p>"},{"location":"advanced/CustomValidation/#key-concepts","title":"Key Concepts","text":"<ul> <li>Validate input parameters before processing</li> <li>Provide clear, actionable error messages</li> <li>Support both synchronous and asynchronous validation</li> <li>Use validation for security and data quality</li> </ul>"},{"location":"advanced/CustomValidation/#validation-patterns","title":"Validation Patterns","text":"<ul> <li>Field-level validation for individual parameters</li> <li>Cross-field validation for related parameters</li> <li>Business logic validation for domain rules</li> <li>Format validation for structured data</li> </ul>"},{"location":"advanced/CustomValidation/#complete-custom-validation-examples","title":"Complete Custom Validation Examples","text":""},{"location":"advanced/CustomValidation/#comprehensive-validation-node","title":"Comprehensive Validation Node","text":"<pre><code>import {\n  IExecuteFunctions,\n  INodeExecutionData,\n  INodeType,\n  INodeTypeDescription,\n  NodeOperationError,\n  NodeParameterOption,\n} from 'n8n-workflow';\n\nexport class CustomValidationNode implements INodeType {\n  description: INodeTypeDescription = {\n    displayName: 'Custom Validation',\n    name: 'customValidation',\n    group: ['transform'],\n    version: 1,\n    description: 'Demonstrates comprehensive custom validation patterns',\n    defaults: {\n      name: 'Custom Validation',\n    },\n    inputs: ['main'],\n    outputs: ['main'],\n    properties: [\n      {\n        displayName: 'Validation Type',\n        name: 'validationType',\n        type: 'options',\n        noDataExpression: true,\n        options: [\n          {\n            name: 'Email Validation',\n            value: 'email',\n            description: 'Validate email addresses with custom rules',\n          },\n          {\n            name: 'Phone Validation',\n            value: 'phone',\n            description: 'Validate phone numbers by country',\n          },\n          {\n            name: 'Date Range Validation',\n            value: 'dateRange',\n            description: 'Validate date ranges and business rules',\n          },\n          {\n            name: 'Financial Validation',\n            value: 'financial',\n            description: 'Validate financial data and calculations',\n          },\n          {\n            name: 'Custom Schema Validation',\n            value: 'schema',\n            description: 'Validate against custom JSON schema',\n          },\n          {\n            name: 'Business Rules Validation',\n            value: 'businessRules',\n            description: 'Apply complex business logic validation',\n          },\n        ],\n        default: 'email',\n      },\n      // Email validation fields\n      {\n        displayName: 'Email Address',\n        name: 'emailAddress',\n        type: 'string',\n        displayOptions: {\n          show: {\n            validationType: ['email'],\n          },\n        },\n        default: '',\n        description: 'Email address to validate',\n        placeholder: 'user@example.com',\n      },\n      {\n        displayName: 'Email Validation Rules',\n        name: 'emailRules',\n        type: 'collection',\n        placeholder: 'Add Rule',\n        displayOptions: {\n          show: {\n            validationType: ['email'],\n          },\n        },\n        default: {},\n        options: [\n          {\n            displayName: 'Allow Disposable Emails',\n            name: 'allowDisposable',\n            type: 'boolean',\n            default: false,\n            description: 'Allow disposable email addresses',\n          },\n          {\n            displayName: 'Require Corporate Domain',\n            name: 'requireCorporate',\n            type: 'boolean',\n            default: false,\n            description: 'Require corporate (non-free) email domains',\n          },\n          {\n            displayName: 'Max Length',\n            name: 'maxLength',\n            type: 'number',\n            default: 254,\n            description: 'Maximum email address length',\n          },\n          {\n            displayName: 'Blocked Domains',\n            name: 'blockedDomains',\n            type: 'string',\n            default: '',\n            description: 'Comma-separated list of blocked domains',\n            placeholder: 'spam.com,fake.org',\n          },\n        ],\n      },\n      // Phone validation fields\n      {\n        displayName: 'Phone Number',\n        name: 'phoneNumber',\n        type: 'string',\n        displayOptions: {\n          show: {\n            validationType: ['phone'],\n          },\n        },\n        default: '',\n        description: 'Phone number to validate',\n        placeholder: '+1-555-123-4567',\n      },\n      {\n        displayName: 'Country Code',\n        name: 'countryCode',\n        type: 'options',\n        displayOptions: {\n          show: {\n            validationType: ['phone'],\n          },\n        },\n        options: [\n          { name: 'United States (+1)', value: 'US' },\n          { name: 'United Kingdom (+44)', value: 'GB' },\n          { name: 'Germany (+49)', value: 'DE' },\n          { name: 'France (+33)', value: 'FR' },\n          { name: 'Auto-detect', value: 'AUTO' },\n        ],\n        default: 'US',\n        description: 'Country for phone number validation',\n      },\n      // Date range validation fields\n      {\n        displayName: 'Start Date',\n        name: 'startDate',\n        type: 'dateTime',\n        displayOptions: {\n          show: {\n            validationType: ['dateRange'],\n          },\n        },\n        default: '',\n        description: 'Start date of the range',\n      },\n      {\n        displayName: 'End Date',\n        name: 'endDate',\n        type: 'dateTime',\n        displayOptions: {\n          show: {\n            validationType: ['dateRange'],\n          },\n        },\n        default: '',\n        description: 'End date of the range',\n      },\n      {\n        displayName: 'Date Rules',\n        name: 'dateRules',\n        type: 'collection',\n        placeholder: 'Add Rule',\n        displayOptions: {\n          show: {\n            validationType: ['dateRange'],\n          },\n        },\n        default: {},\n        options: [\n          {\n            displayName: 'Max Range Days',\n            name: 'maxRangeDays',\n            type: 'number',\n            default: 365,\n            description: 'Maximum allowed days in range',\n          },\n          {\n            displayName: 'Allow Future Dates',\n            name: 'allowFuture',\n            type: 'boolean',\n            default: true,\n            description: 'Allow dates in the future',\n          },\n          {\n            displayName: 'Business Days Only',\n            name: 'businessDaysOnly',\n            type: 'boolean',\n            default: false,\n            description: 'Only allow business days (Mon-Fri)',\n          },\n        ],\n      },\n      // Financial validation fields\n      {\n        displayName: 'Amount',\n        name: 'amount',\n        type: 'number',\n        displayOptions: {\n          show: {\n            validationType: ['financial'],\n          },\n        },\n        default: 0,\n        description: 'Financial amount to validate',\n      },\n      {\n        displayName: 'Currency',\n        name: 'currency',\n        type: 'options',\n        displayOptions: {\n          show: {\n            validationType: ['financial'],\n          },\n        },\n        options: [\n          { name: 'US Dollar (USD)', value: 'USD' },\n          { name: 'Euro (EUR)', value: 'EUR' },\n          { name: 'British Pound (GBP)', value: 'GBP' },\n          { name: 'Japanese Yen (JPY)', value: 'JPY' },\n        ],\n        default: 'USD',\n        description: 'Currency for the amount',\n      },\n      {\n        displayName: 'Financial Rules',\n        name: 'financialRules',\n        type: 'collection',\n        placeholder: 'Add Rule',\n        displayOptions: {\n          show: {\n            validationType: ['financial'],\n          },\n        },\n        default: {},\n        options: [\n          {\n            displayName: 'Min Amount',\n            name: 'minAmount',\n            type: 'number',\n            default: 0,\n            description: 'Minimum allowed amount',\n          },\n          {\n            displayName: 'Max Amount',\n            name: 'maxAmount',\n            type: 'number',\n            default: 1000000,\n            description: 'Maximum allowed amount',\n          },\n          {\n            displayName: 'Decimal Places',\n            name: 'decimalPlaces',\n            type: 'number',\n            default: 2,\n            description: 'Required number of decimal places',\n          },\n          {\n            displayName: 'Require Positive',\n            name: 'requirePositive',\n            type: 'boolean',\n            default: true,\n            description: 'Amount must be positive',\n          },\n        ],\n      },\n      // Schema validation fields\n      {\n        displayName: 'JSON Data',\n        name: 'jsonData',\n        type: 'json',\n        displayOptions: {\n          show: {\n            validationType: ['schema'],\n          },\n        },\n        default: '{}',\n        description: 'JSON data to validate against schema',\n      },\n      {\n        displayName: 'JSON Schema',\n        name: 'jsonSchema',\n        type: 'json',\n        displayOptions: {\n          show: {\n            validationType: ['schema'],\n          },\n        },\n        default: '{\"type\": \"object\", \"properties\": {}}',\n        description: 'JSON schema for validation',\n      },\n      // Business rules validation\n      {\n        displayName: 'User Data',\n        name: 'userData',\n        type: 'json',\n        displayOptions: {\n          show: {\n            validationType: ['businessRules'],\n          },\n        },\n        default: '{\"age\": 25, \"country\": \"US\", \"income\": 50000}',\n        description: 'User data for business rules validation',\n      },\n      {\n        displayName: 'Validation Options',\n        name: 'validationOptions',\n        type: 'collection',\n        placeholder: 'Add Option',\n        default: {},\n        options: [\n          {\n            displayName: 'Strict Mode',\n            name: 'strictMode',\n            type: 'boolean',\n            default: false,\n            description: 'Enable strict validation (fail on warnings)',\n          },\n          {\n            displayName: 'Return Details',\n            name: 'returnDetails',\n            type: 'boolean',\n            default: true,\n            description: 'Return detailed validation results',\n          },\n          {\n            displayName: 'Custom Error Messages',\n            name: 'customErrorMessages',\n            type: 'boolean',\n            default: false,\n            description: 'Use custom error messages',\n          },\n        ],\n      },\n    ],\n  };\n\n  async execute(this: IExecuteFunctions): Promise&lt;INodeExecutionData[][]&gt; {\n    const items = this.getInputData();\n    const returnData: INodeExecutionData[] = [];\n\n    for (let i = 0; i &lt; items.length; i++) {\n      try {\n        const validationType = this.getNodeParameter('validationType', i) as string;\n        const validationOptions = this.getNodeParameter('validationOptions', i, {}) as any;\n\n        let validationResult: any;\n\n        switch (validationType) {\n          case 'email':\n            validationResult = await this.validateEmail(i);\n            break;\n          case 'phone':\n            validationResult = await this.validatePhone(i);\n            break;\n          case 'dateRange':\n            validationResult = await this.validateDateRange(i);\n            break;\n          case 'financial':\n            validationResult = await this.validateFinancial(i);\n            break;\n          case 'schema':\n            validationResult = await this.validateSchema(i);\n            break;\n          case 'businessRules':\n            validationResult = await this.validateBusinessRules(i);\n            break;\n          default:\n            throw new NodeOperationError(\n              this.getNode(),\n              `Unknown validation type: ${validationType}`,\n              { itemIndex: i }\n            );\n        }\n\n        // Handle validation results based on options\n        if (!validationResult.isValid &amp;&amp; validationOptions.strictMode) {\n          throw new NodeOperationError(\n            this.getNode(),\n            `Validation failed: ${validationResult.errors.join(', ')}`,\n            { itemIndex: i }\n          );\n        }\n\n        const result: any = {\n          validationType,\n          isValid: validationResult.isValid,\n          success: validationResult.isValid,\n        };\n\n        if (validationOptions.returnDetails) {\n          result.details = validationResult;\n        } else {\n          result.summary = this.createValidationSummary(validationResult);\n        }\n\n        returnData.push({\n          json: {\n            ...result,\n            metadata: {\n              validated_at: new Date().toISOString(),\n              item_index: i,\n              validation_options: validationOptions,\n            },\n          },\n        });\n\n      } catch (error) {\n        throw new NodeOperationError(\n          this.getNode(),\n          `Validation error: ${error.message}`,\n          { itemIndex: i }\n        );\n      }\n    }\n\n    return [returnData];\n  }\n\n  private async validateEmail(itemIndex: number): Promise&lt;any&gt; {\n    const emailAddress = this.getNodeParameter('emailAddress', itemIndex) as string;\n    const emailRules = this.getNodeParameter('emailRules', itemIndex, {}) as any;\n\n    const errors: string[] = [];\n    const warnings: string[] = [];\n    const details: any = {};\n\n    // Basic format validation\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    if (!emailRegex.test(emailAddress)) {\n      errors.push('Invalid email format');\n    }\n\n    // Length validation\n    const maxLength = emailRules.maxLength || 254;\n    if (emailAddress.length &gt; maxLength) {\n      errors.push(`Email too long (max ${maxLength} characters)`);\n    }\n\n    // Domain extraction and validation\n    const domain = emailAddress.split('@')[1]?.toLowerCase();\n    if (domain) {\n      details.domain = domain;\n\n      // Blocked domains check\n      if (emailRules.blockedDomains) {\n        const blockedDomains = emailRules.blockedDomains.split(',').map((d: string) =&gt; d.trim().toLowerCase());\n        if (blockedDomains.includes(domain)) {\n          errors.push(`Domain ${domain} is blocked`);\n        }\n      }\n\n      // Disposable email check\n      const disposableDomains = ['10minutemail.com', 'tempmail.org', 'guerrillamail.com'];\n      const isDisposable = disposableDomains.includes(domain);\n      details.isDisposable = isDisposable;\n\n      if (isDisposable &amp;&amp; !emailRules.allowDisposable) {\n        errors.push('Disposable email addresses are not allowed');\n      }\n\n      // Corporate domain check\n      const freeDomains = ['gmail.com', 'yahoo.com', 'hotmail.com', 'outlook.com'];\n      const isFree = freeDomains.includes(domain);\n      details.isCorporate = !isFree;\n\n      if (emailRules.requireCorporate &amp;&amp; isFree) {\n        errors.push('Corporate email address required');\n      }\n\n      // Domain validation (simplified DNS check simulation)\n      details.domainValid = await this.simulateDomainValidation(domain);\n      if (!details.domainValid) {\n        warnings.push('Domain may not exist or be unreachable');\n      }\n    }\n\n    // Additional checks\n    const localPart = emailAddress.split('@')[0];\n    if (localPart) {\n      details.localPart = localPart;\n\n      // Check for suspicious patterns\n      if (localPart.includes('test') || localPart.includes('example')) {\n        warnings.push('Email appears to be a test address');\n      }\n\n      // Check for consecutive dots or special characters\n      if (localPart.includes('..') || localPart.startsWith('.') || localPart.endsWith('.')) {\n        errors.push('Invalid local part format');\n      }\n    }\n\n    return {\n      isValid: errors.length === 0,\n      errors,\n      warnings,\n      details,\n      email: emailAddress,\n    };\n  }\n\n  private async validatePhone(itemIndex: number): Promise&lt;any&gt; {\n    const phoneNumber = this.getNodeParameter('phoneNumber', itemIndex) as string;\n    const countryCode = this.getNodeParameter('countryCode', itemIndex) as string;\n\n    const errors: string[] = [];\n    const warnings: string[] = [];\n    const details: any = {};\n\n    // Clean phone number (remove spaces, dashes, parentheses)\n    const cleanedPhone = phoneNumber.replace(/[\\s\\-\\(\\)]/g, '');\n    details.cleanedNumber = cleanedPhone;\n\n    // Country-specific validation\n    const phonePatterns: { [key: string]: { pattern: RegExp; length: number; format: string } } = {\n      US: { pattern: /^\\+?1?[2-9]\\d{2}[2-9]\\d{2}\\d{4}$/, length: 10, format: '+1-XXX-XXX-XXXX' },\n      GB: { pattern: /^\\+?44[1-9]\\d{8,9}$/, length: 11, format: '+44-XXXX-XXXXXX' },\n      DE: { pattern: /^\\+?49[1-9]\\d{10,11}$/, length: 11, format: '+49-XXX-XXXXXXXX' },\n      FR: { pattern: /^\\+?33[1-9]\\d{8}$/, length: 10, format: '+33-X-XX-XX-XX-XX' },\n    };\n\n    let detectedCountry = countryCode;\n    if (countryCode === 'AUTO') {\n      // Auto-detect country based on prefix\n      if (cleanedPhone.startsWith('+1') || cleanedPhone.startsWith('1')) {\n        detectedCountry = 'US';\n      } else if (cleanedPhone.startsWith('+44')) {\n        detectedCountry = 'GB';\n      } else if (cleanedPhone.startsWith('+49')) {\n        detectedCountry = 'DE';\n      } else if (cleanedPhone.startsWith('+33')) {\n        detectedCountry = 'FR';\n      } else {\n        warnings.push('Could not auto-detect country code');\n        detectedCountry = 'US'; // Default fallback\n      }\n    }\n\n    details.detectedCountry = detectedCountry;\n    const pattern = phonePatterns[detectedCountry];\n\n    if (pattern) {\n      details.expectedFormat = pattern.format;\n\n      if (!pattern.pattern.test(cleanedPhone)) {\n        errors.push(`Invalid ${detectedCountry} phone number format`);\n      }\n\n      // Length validation\n      const numberWithoutCountryCode = cleanedPhone.replace(/^\\+?\\d{1,3}/, '');\n      if (numberWithoutCountryCode.length !== pattern.length) {\n        errors.push(`Phone number should have ${pattern.length} digits (excluding country code)`);\n      }\n    } else {\n      warnings.push(`Validation pattern not available for country: ${detectedCountry}`);\n    }\n\n    // General validations\n    if (cleanedPhone.length &lt; 7) {\n      errors.push('Phone number too short');\n    }\n\n    if (cleanedPhone.length &gt; 15) {\n      errors.push('Phone number too long');\n    }\n\n    // Check for suspicious patterns\n    const repeatingPattern = /(\\d)\\1{6,}/;\n    if (repeatingPattern.test(cleanedPhone)) {\n      warnings.push('Phone number contains suspicious repeating digits');\n    }\n\n    // Format the number for display\n    details.formattedNumber = this.formatPhoneNumber(cleanedPhone, detectedCountry);\n\n    return {\n      isValid: errors.length === 0,\n      errors,\n      warnings,\n      details,\n      phoneNumber,\n    };\n  }\n\n  private async validateDateRange(itemIndex: number): Promise&lt;any&gt; {\n    const startDateStr = this.getNodeParameter('startDate', itemIndex) as string;\n    const endDateStr = this.getNodeParameter('endDate', itemIndex) as string;\n    const dateRules = this.getNodeParameter('dateRules', itemIndex, {}) as any;\n\n    const errors: string[] = [];\n    const warnings: string[] = [];\n    const details: any = {};\n\n    // Parse dates\n    const startDate = new Date(startDateStr);\n    const endDate = new Date(endDateStr);\n    const now = new Date();\n\n    details.startDate = startDate.toISOString();\n    details.endDate = endDate.toISOString();\n\n    // Basic date validation\n    if (isNaN(startDate.getTime())) {\n      errors.push('Invalid start date');\n    }\n\n    if (isNaN(endDate.getTime())) {\n      errors.push('Invalid end date');\n    }\n\n    if (errors.length === 0) {\n      // Range validation\n      if (startDate &gt;= endDate) {\n        errors.push('Start date must be before end date');\n      }\n\n      // Calculate range\n      const rangeDays = Math.ceil((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24));\n      details.rangeDays = rangeDays;\n\n      // Max range validation\n      const maxRangeDays = dateRules.maxRangeDays || 365;\n      if (rangeDays &gt; maxRangeDays) {\n        errors.push(`Date range too large (max ${maxRangeDays} days)`);\n      }\n\n      // Future date validation\n      if (!dateRules.allowFuture) {\n        if (startDate &gt; now) {\n          errors.push('Start date cannot be in the future');\n        }\n        if (endDate &gt; now) {\n          errors.push('End date cannot be in the future');\n        }\n      }\n\n      // Business days validation\n      if (dateRules.businessDaysOnly) {\n        const startDay = startDate.getDay();\n        const endDay = endDate.getDay();\n\n        if (startDay === 0 || startDay === 6) {\n          errors.push('Start date must be a business day (Monday-Friday)');\n        }\n\n        if (endDay === 0 || endDay === 6) {\n          errors.push('End date must be a business day (Monday-Friday)');\n        }\n      }\n\n      // Calculate business days in range\n      details.businessDays = this.calculateBusinessDays(startDate, endDate);\n      details.weekendDays = rangeDays - details.businessDays;\n\n      // Additional insights\n      if (rangeDays &gt; 30) {\n        warnings.push('Long date range may impact performance');\n      }\n\n      if (startDate.getFullYear() !== endDate.getFullYear()) {\n        warnings.push('Date range spans multiple years');\n      }\n    }\n\n    return {\n      isValid: errors.length === 0,\n      errors,\n      warnings,\n      details,\n      startDate: startDateStr,\n      endDate: endDateStr,\n    };\n  }\n\n  private async validateFinancial(itemIndex: number): Promise&lt;any&gt; {\n    const amount = this.getNodeParameter('amount', itemIndex) as number;\n    const currency = this.getNodeParameter('currency', itemIndex) as string;\n    const financialRules = this.getNodeParameter('financialRules', itemIndex, {}) as any;\n\n    const errors: string[] = [];\n    const warnings: string[] = [];\n    const details: any = {};\n\n    details.amount = amount;\n    details.currency = currency;\n\n    // Basic amount validation\n    if (typeof amount !== 'number' || isNaN(amount)) {\n      errors.push('Amount must be a valid number');\n      return { isValid: false, errors, warnings, details, amount, currency };\n    }\n\n    // Positive amount validation\n    if (financialRules.requirePositive &amp;&amp; amount &lt;= 0) {\n      errors.push('Amount must be positive');\n    }\n\n    // Range validation\n    const minAmount = financialRules.minAmount ?? 0;\n    const maxAmount = financialRules.maxAmount ?? 1000000;\n\n    if (amount &lt; minAmount) {\n      errors.push(`Amount below minimum (${minAmount} ${currency})`);\n    }\n\n    if (amount &gt; maxAmount) {\n      errors.push(`Amount exceeds maximum (${maxAmount} ${currency})`);\n    }\n\n    // Decimal places validation\n    const decimalPlaces = financialRules.decimalPlaces ?? 2;\n    const amountStr = amount.toString();\n    const decimalIndex = amountStr.indexOf('.');\n\n    if (decimalIndex !== -1) {\n      const actualDecimalPlaces = amountStr.length - decimalIndex - 1;\n      details.decimalPlaces = actualDecimalPlaces;\n\n      if (actualDecimalPlaces &gt; decimalPlaces) {\n        errors.push(`Too many decimal places (max ${decimalPlaces})`);\n      }\n    } else {\n      details.decimalPlaces = 0;\n    }\n\n    // Currency-specific validation\n    const currencyRules: { [key: string]: { minorUnit: number; maxAmount: number } } = {\n      USD: { minorUnit: 2, maxAmount: 1000000 },\n      EUR: { minorUnit: 2, maxAmount: 1000000 },\n      GBP: { minorUnit: 2, maxAmount: 1000000 },\n      JPY: { minorUnit: 0, maxAmount: 100000000 },\n    };\n\n    const currencyRule = currencyRules[currency];\n    if (currencyRule) {\n      details.currencyRule = currencyRule;\n\n      if (decimalPlaces !== currencyRule.minorUnit) {\n        warnings.push(`${currency} typically uses ${currencyRule.minorUnit} decimal places`);\n      }\n\n      if (amount &gt; currencyRule.maxAmount) {\n        warnings.push(`Large amount for ${currency} currency`);\n      }\n    }\n\n    // Format amount for display\n    details.formattedAmount = this.formatCurrency(amount, currency);\n\n    // Fraud detection patterns\n    const fraudPatterns = [\n      { pattern: /\\.99$/, message: 'Suspicious pricing pattern (.99 ending)' },\n      { pattern: /^9{3,}/, message: 'Suspicious amount pattern (multiple 9s)' },\n    ];\n\n    fraudPatterns.forEach(({ pattern, message }) =&gt; {\n      if (pattern.test(amountStr)) {\n        warnings.push(message);\n      }\n    });\n\n    // Large transaction warning\n    if (amount &gt; 10000) {\n      warnings.push('Large transaction amount - may require additional verification');\n    }\n\n    return {\n      isValid: errors.length === 0,\n      errors,\n      warnings,\n      details,\n      amount,\n      currency,\n    };\n  }\n\n  private async validateSchema(itemIndex: number): Promise&lt;any&gt; {\n    const jsonDataStr = this.getNodeParameter('jsonData', itemIndex) as string;\n    const jsonSchemaStr = this.getNodeParameter('jsonSchema', itemIndex) as string;\n\n    const errors: string[] = [];\n    const warnings: string[] = [];\n    const details: any = {};\n\n    try {\n      // Parse JSON data\n      const jsonData = JSON.parse(jsonDataStr);\n      details.parsedData = jsonData;\n\n      // Parse JSON schema\n      const jsonSchema = JSON.parse(jsonSchemaStr);\n      details.schema = jsonSchema;\n\n      // Perform schema validation (simplified implementation)\n      const validationResult = this.validateAgainstSchema(jsonData, jsonSchema);\n\n      errors.push(...validationResult.errors);\n      warnings.push(...validationResult.warnings);\n      details.validationDetails = validationResult.details;\n\n    } catch (error) {\n      if (error.message.includes('JSON')) {\n        errors.push(`JSON parsing error: ${error.message}`);\n      } else {\n        errors.push(`Schema validation error: ${error.message}`);\n      }\n    }\n\n    return {\n      isValid: errors.length === 0,\n      errors,\n      warnings,\n      details,\n      jsonData: jsonDataStr,\n      jsonSchema: jsonSchemaStr,\n    };\n  }\n\n  private async validateBusinessRules(itemIndex: number): Promise&lt;any&gt; {\n    const userDataStr = this.getNodeParameter('userData', itemIndex) as string;\n\n    const errors: string[] = [];\n    const warnings: string[] = [];\n    const details: any = {};\n\n    try {\n      const userData = JSON.parse(userDataStr);\n      details.userData = userData;\n\n      // Age validation\n      if (userData.age !== undefined) {\n        if (typeof userData.age !== 'number' || userData.age &lt; 0 || userData.age &gt; 150) {\n          errors.push('Invalid age (must be 0-150)');\n        } else if (userData.age &lt; 18) {\n          warnings.push('User is under 18 years old');\n        } else if (userData.age &gt; 65) {\n          warnings.push('User is over retirement age');\n        }\n      }\n\n      // Income validation\n      if (userData.income !== undefined) {\n        if (typeof userData.income !== 'number' || userData.income &lt; 0) {\n          errors.push('Invalid income (must be positive number)');\n        } else {\n          // Income brackets\n          if (userData.income &lt; 25000) {\n            details.incomeCategory = 'low';\n          } else if (userData.income &lt; 75000) {\n            details.incomeCategory = 'medium';\n          } else {\n            details.incomeCategory = 'high';\n          }\n\n          // Age-income correlation check\n          if (userData.age &amp;&amp; userData.age &lt; 25 &amp;&amp; userData.income &gt; 100000) {\n            warnings.push('High income for young age - verify data accuracy');\n          }\n        }\n      }\n\n      // Country validation\n      if (userData.country) {\n        const validCountries = ['US', 'CA', 'GB', 'DE', 'FR', 'AU', 'JP'];\n        if (!validCountries.includes(userData.country)) {\n          warnings.push(`Country ${userData.country} not in supported list`);\n        }\n        details.countrySupported = validCountries.includes(userData.country);\n      }\n\n      // Cross-field business rules\n      if (userData.age &amp;&amp; userData.income &amp;&amp; userData.country) {\n        // Eligibility rules\n        const eligibilityRules = [\n          {\n            name: 'premium_service',\n            condition: userData.age &gt;= 21 &amp;&amp; userData.income &gt;= 50000,\n            message: 'Eligible for premium service',\n          },\n          {\n            name: 'student_discount',\n            condition: userData.age &gt;= 16 &amp;&amp; userData.age &lt;= 25 &amp;&amp; userData.income &lt; 30000,\n            message: 'Eligible for student discount',\n          },\n          {\n            name: 'senior_benefits',\n            condition: userData.age &gt;= 65,\n            message: 'Eligible for senior benefits',\n          },\n        ];\n\n        details.eligibility = {};\n        eligibilityRules.forEach(rule =&gt; {\n          details.eligibility[rule.name] = rule.condition;\n          if (rule.condition) {\n            warnings.push(rule.message);\n          }\n        });\n\n        // Risk assessment\n        let riskScore = 0;\n        if (userData.age &lt; 25) riskScore += 1;\n        if (userData.income &lt; 25000) riskScore += 2;\n        if (!['US', 'CA', 'GB'].includes(userData.country)) riskScore += 1;\n\n        details.riskScore = riskScore;\n        details.riskLevel = riskScore &lt;= 1 ? 'low' : riskScore &lt;= 3 ? 'medium' : 'high';\n\n        if (riskScore &gt; 3) {\n          warnings.push('High risk profile - additional verification may be required');\n        }\n      }\n\n    } catch (error) {\n      errors.push(`JSON parsing error: ${error.message}`);\n    }\n\n    return {\n      isValid: errors.length === 0,\n      errors,\n      warnings,\n      details,\n      userData: userDataStr,\n    };\n  }\n\n  // Helper methods\n  private async simulateDomainValidation(domain: string): Promise&lt;boolean&gt; {\n    // Simulate DNS validation - in real implementation use dns.resolve()\n    const validDomains = ['gmail.com', 'yahoo.com', 'outlook.com', 'example.com', 'test.com'];\n    return validDomains.includes(domain) || Math.random() &gt; 0.1; // 90% valid\n  }\n\n  private formatPhoneNumber(phone: string, country: string): string {\n    // Simple phone formatting based on country\n    const cleaned = phone.replace(/^\\+?\\d{1,3}/, ''); // Remove country code\n\n    switch (country) {\n      case 'US':\n        return `+1-${cleaned.slice(0, 3)}-${cleaned.slice(3, 6)}-${cleaned.slice(6)}`;\n      case 'GB':\n        return `+44-${cleaned.slice(0, 4)}-${cleaned.slice(4)}`;\n      case 'DE':\n        return `+49-${cleaned.slice(0, 3)}-${cleaned.slice(3)}`;\n      case 'FR':\n        return `+33-${cleaned.slice(0, 1)}-${cleaned.slice(1, 3)}-${cleaned.slice(3, 5)}-${cleaned.slice(5, 7)}-${cleaned.slice(7)}`;\n      default:\n        return phone;\n    }\n  }\n\n  private calculateBusinessDays(startDate: Date, endDate: Date): number {\n    let businessDays = 0;\n    const currentDate = new Date(startDate);\n\n    while (currentDate &lt; endDate) {\n      const dayOfWeek = currentDate.getDay();\n      if (dayOfWeek !== 0 &amp;&amp; dayOfWeek !== 6) { // Not Sunday (0) or Saturday (6)\n        businessDays++;\n      }\n      currentDate.setDate(currentDate.getDate() + 1);\n    }\n\n    return businessDays;\n  }\n\n  private formatCurrency(amount: number, currency: string): string {\n    const formatters: { [key: string]: Intl.NumberFormat } = {\n      USD: new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD' }),\n      EUR: new Intl.NumberFormat('de-DE', { style: 'currency', currency: 'EUR' }),\n      GBP: new Intl.NumberFormat('en-GB', { style: 'currency', currency: 'GBP' }),\n      JPY: new Intl.NumberFormat('ja-JP', { style: 'currency', currency: 'JPY' }),\n    };\n\n    const formatter = formatters[currency];\n    return formatter ? formatter.format(amount) : `${amount} ${currency}`;\n  }\n\n  private validateAgainstSchema(data: any, schema: any): { errors: string[]; warnings: string[]; details: any } {\n    const errors: string[] = [];\n    const warnings: string[] = [];\n    const details: any = {};\n\n    // Simplified JSON schema validation\n    if (schema.type) {\n      const actualType = Array.isArray(data) ? 'array' : typeof data;\n      if (actualType !== schema.type) {\n        errors.push(`Expected type ${schema.type}, got ${actualType}`);\n      }\n      details.typeValid = actualType === schema.type;\n    }\n\n    if (schema.type === 'object' &amp;&amp; schema.properties) {\n      details.propertyValidation = {};\n\n      // Check required properties\n      if (schema.required) {\n        schema.required.forEach((prop: string) =&gt; {\n          if (!(prop in data)) {\n            errors.push(`Missing required property: ${prop}`);\n          }\n        });\n      }\n\n      // Validate each property\n      Object.entries(schema.properties).forEach(([prop, propSchema]: [string, any]) =&gt; {\n        if (prop in data) {\n          const propValue = data[prop];\n          const propType = Array.isArray(propValue) ? 'array' : typeof propValue;\n\n          details.propertyValidation[prop] = { valid: true };\n\n          if (propSchema.type &amp;&amp; propType !== propSchema.type) {\n            errors.push(`Property ${prop}: expected ${propSchema.type}, got ${propType}`);\n            details.propertyValidation[prop].valid = false;\n          }\n\n          if (propSchema.minLength &amp;&amp; typeof propValue === 'string' &amp;&amp; propValue.length &lt; propSchema.minLength) {\n            errors.push(`Property ${prop}: too short (min ${propSchema.minLength})`);\n          }\n\n          if (propSchema.maxLength &amp;&amp; typeof propValue === 'string' &amp;&amp; propValue.length &gt; propSchema.maxLength) {\n            errors.push(`Property ${prop}: too long (max ${propSchema.maxLength})`);\n          }\n\n          if (propSchema.minimum &amp;&amp; typeof propValue === 'number' &amp;&amp; propValue &lt; propSchema.minimum) {\n            errors.push(`Property ${prop}: below minimum (${propSchema.minimum})`);\n          }\n\n          if (propSchema.maximum &amp;&amp; typeof propValue === 'number' &amp;&amp; propValue &gt; propSchema.maximum) {\n            errors.push(`Property ${prop}: above maximum (${propSchema.maximum})`);\n          }\n        }\n      });\n\n      // Check for additional properties\n      if (schema.additionalProperties === false) {\n        Object.keys(data).forEach(prop =&gt; {\n          if (!(prop in schema.properties)) {\n            warnings.push(`Additional property not allowed: ${prop}`);\n          }\n        });\n      }\n    }\n\n    if (schema.type === 'array') {\n      if (schema.minItems &amp;&amp; data.length &lt; schema.minItems) {\n        errors.push(`Array too short (min ${schema.minItems} items)`);\n      }\n\n      if (schema.maxItems &amp;&amp; data.length &gt; schema.maxItems) {\n        errors.push(`Array too long (max ${schema.maxItems} items)`);\n      }\n\n      details.arrayLength = data.length;\n    }\n\n    return { errors, warnings, details };\n  }\n\n  private createValidationSummary(result: any): string {\n    if (result.isValid) {\n      return `Validation passed${result.warnings?.length ? ` with ${result.warnings.length} warnings` : ''}`;\n    } else {\n      return `Validation failed: ${result.errors.length} errors${result.warnings?.length ? `, ${result.warnings.length} warnings` : ''}`;\n    }\n  }\n}\n</code></pre> <p>Key Custom Validation Patterns:</p> <ol> <li> <p>Field-Level Validation: <pre><code>if (!emailRegex.test(emailAddress)) {\n  errors.push('Invalid email format');\n}\n</code></pre></p> </li> <li> <p>Cross-Field Validation: <pre><code>if (startDate &gt;= endDate) {\n  errors.push('Start date must be before end date');\n}\n</code></pre></p> </li> <li> <p>Business Rules Validation: <pre><code>if (userData.age &lt; 25 &amp;&amp; userData.income &gt; 100000) {\n  warnings.push('High income for young age - verify data accuracy');\n}\n</code></pre></p> </li> <li> <p>Schema Validation: <pre><code>const validationResult = this.validateAgainstSchema(jsonData, jsonSchema);\nerrors.push(...validationResult.errors);\n</code></pre></p> </li> <li> <p>Conditional Validation: <pre><code>if (financialRules.requirePositive &amp;&amp; amount &lt;= 0) {\n  errors.push('Amount must be positive');\n}\n</code></pre></p> </li> <li> <p>Format Validation: <pre><code>const phonePatterns = {\n  US: { pattern: /^\\+?1?[2-9]\\d{2}[2-9]\\d{2}\\d{4}$/, length: 10 }\n};\n</code></pre></p> </li> <li> <p>Warning vs Error Handling: <pre><code>// Errors stop processing\nerrors.push('Critical validation failure');\n\n// Warnings allow processing to continue\nwarnings.push('Data quality concern');\n</code></pre></p> </li> </ol> <p>This comprehensive validation approach ensures data quality, security, and provides excellent user feedback for any validation issues!</p>"},{"location":"advanced/ErrorHandling/","title":"Error Handling Patterns","text":"<p>Proper error handling is crucial for creating robust n8n nodes that provide clear feedback to users.</p>"},{"location":"advanced/ErrorHandling/#key-principles","title":"Key Principles","text":"<ul> <li>Use specific error types for different scenarios</li> <li>Provide actionable error messages</li> <li>Include context and suggestions for resolution</li> <li>Handle both API errors and validation errors</li> </ul>"},{"location":"advanced/ErrorHandling/#error-types","title":"Error Types","text":"<ul> <li><code>NodeApiError</code> - For API-related errors</li> <li><code>NodeOperationError</code> - For operation/logic errors</li> <li><code>NodeConnectionError</code> - For connection issues</li> </ul>"},{"location":"advanced/ErrorHandling/#complete-error-handling-examples","title":"Complete Error Handling Examples","text":""},{"location":"advanced/ErrorHandling/#basic-error-handling-with-try-catch","title":"Basic Error Handling with Try-Catch","text":"<pre><code>import {\n  IExecuteFunctions,\n  INodeExecutionData,\n  INodeType,\n  INodeTypeDescription,\n  NodeApiError,\n  NodeOperationError,\n  NodeConnectionError,\n} from 'n8n-workflow';\n\nexport class ErrorHandlingExample implements INodeType {\n  description: INodeTypeDescription = {\n    displayName: 'Error Handling Example',\n    name: 'errorHandlingExample',\n    group: ['transform'],\n    version: 1,\n    description: 'Demonstrates comprehensive error handling patterns',\n    defaults: {\n      name: 'Error Handling Example',\n    },\n    inputs: ['main'],\n    outputs: ['main'],\n    properties: [\n      {\n        displayName: 'Operation',\n        name: 'operation',\n        type: 'options',\n        noDataExpression: true,\n        options: [\n          {\n            name: 'API Request',\n            value: 'apiRequest',\n            description: 'Make an API request with error handling',\n          },\n          {\n            name: 'Data Validation',\n            value: 'dataValidation',\n            description: 'Validate input data with custom errors',\n          },\n          {\n            name: 'File Processing',\n            value: 'fileProcessing',\n            description: 'Process files with comprehensive error handling',\n          },\n        ],\n        default: 'apiRequest',\n      },\n      {\n        displayName: 'API URL',\n        name: 'apiUrl',\n        type: 'string',\n        displayOptions: {\n          show: {\n            operation: ['apiRequest'],\n          },\n        },\n        default: 'https://jsonplaceholder.typicode.com/posts/1',\n        description: 'URL to make the API request to',\n      },\n      {\n        displayName: 'Email',\n        name: 'email',\n        type: 'string',\n        displayOptions: {\n          show: {\n            operation: ['dataValidation'],\n          },\n        },\n        default: '',\n        description: 'Email address to validate',\n      },\n      {\n        displayName: 'File Path',\n        name: 'filePath',\n        type: 'string',\n        displayOptions: {\n          show: {\n            operation: ['fileProcessing'],\n          },\n        },\n        default: '',\n        description: 'Path to the file to process',\n      },\n      {\n        displayName: 'Error Handling Options',\n        name: 'errorOptions',\n        type: 'collection',\n        placeholder: 'Add Option',\n        default: {},\n        options: [\n          {\n            displayName: 'Continue on Error',\n            name: 'continueOnError',\n            type: 'boolean',\n            default: false,\n            description: 'Continue processing other items if one fails',\n          },\n          {\n            displayName: 'Retry Count',\n            name: 'retryCount',\n            type: 'number',\n            default: 3,\n            description: 'Number of times to retry failed operations',\n          },\n          {\n            displayName: 'Retry Delay (ms)',\n            name: 'retryDelay',\n            type: 'number',\n            default: 1000,\n            description: 'Delay between retry attempts',\n          },\n          {\n            displayName: 'Timeout (ms)',\n            name: 'timeout',\n            type: 'number',\n            default: 30000,\n            description: 'Request timeout in milliseconds',\n          },\n        ],\n      },\n    ],\n  };\n\n  async execute(this: IExecuteFunctions): Promise&lt;INodeExecutionData[][]&gt; {\n    const items = this.getInputData();\n    const returnData: INodeExecutionData[] = [];\n    const operation = this.getNodeParameter('operation', 0) as string;\n    const errorOptions = this.getNodeParameter('errorOptions', 0, {}) as any;\n\n    for (let i = 0; i &lt; items.length; i++) {\n      try {\n        let result: any;\n\n        switch (operation) {\n          case 'apiRequest':\n            result = await this.handleApiRequest(i, errorOptions);\n            break;\n          case 'dataValidation':\n            result = await this.handleDataValidation(i);\n            break;\n          case 'fileProcessing':\n            result = await this.handleFileProcessing(i);\n            break;\n          default:\n            throw new NodeOperationError(\n              this.getNode(),\n              `Unknown operation: ${operation}`,\n              { itemIndex: i }\n            );\n        }\n\n        returnData.push({ json: result });\n\n      } catch (error) {\n        // Handle errors based on configuration\n        if (errorOptions.continueOnError) {\n          // Add error information to output but continue processing\n          returnData.push({\n            json: {\n              error: true,\n              message: error.message,\n              itemIndex: i,\n              originalData: items[i].json,\n            },\n          });\n          continue;\n        } else {\n          // Re-throw the error to stop execution\n          throw error;\n        }\n      }\n    }\n\n    return [returnData];\n  }\n\n  private async handleApiRequest(itemIndex: number, errorOptions: any): Promise&lt;any&gt; {\n    const apiUrl = this.getNodeParameter('apiUrl', itemIndex) as string;\n    const retryCount = errorOptions.retryCount || 3;\n    const retryDelay = errorOptions.retryDelay || 1000;\n    const timeout = errorOptions.timeout || 30000;\n\n    // Validate URL format\n    try {\n      new URL(apiUrl);\n    } catch (error) {\n      throw new NodeOperationError(\n        this.getNode(),\n        `Invalid URL format: ${apiUrl}`,\n        {\n          description: 'Please provide a valid HTTP or HTTPS URL',\n          itemIndex,\n        }\n      );\n    }\n\n    let lastError: Error;\n\n    for (let attempt = 1; attempt &lt;= retryCount; attempt++) {\n      try {\n        const response = await this.helpers.request({\n          method: 'GET',\n          url: apiUrl,\n          timeout,\n          json: true,\n        });\n\n        return {\n          success: true,\n          data: response,\n          attempts: attempt,\n          url: apiUrl,\n        };\n\n      } catch (error) {\n        lastError = error;\n\n        // Handle different types of errors\n        if (error.code === 'ENOTFOUND') {\n          throw new NodeConnectionError(\n            this.getNode(),\n            `Cannot resolve hostname: ${apiUrl}`,\n            {\n              description: 'Check if the URL is correct and the server is accessible',\n              itemIndex,\n            }\n          );\n        }\n\n        if (error.code === 'ECONNREFUSED') {\n          throw new NodeConnectionError(\n            this.getNode(),\n            `Connection refused to: ${apiUrl}`,\n            {\n              description: 'The server is not accepting connections on this port',\n              itemIndex,\n            }\n          );\n        }\n\n        if (error.code === 'ETIMEDOUT') {\n          if (attempt === retryCount) {\n            throw new NodeApiError(\n              this.getNode(),\n              error,\n              {\n                message: `Request timed out after ${timeout}ms (${retryCount} attempts)`,\n                description: 'Try increasing the timeout or check if the server is responding slowly',\n                itemIndex,\n              }\n            );\n          }\n          // Continue to retry for timeout errors\n        } else if (error.response?.status &gt;= 400 &amp;&amp; error.response?.status &lt; 500) {\n          // Client errors (4xx) - don't retry\n          throw new NodeApiError(\n            this.getNode(),\n            error,\n            {\n              message: `API returned ${error.response.status}: ${error.response.statusText}`,\n              description: this.getApiErrorDescription(error.response.status),\n              itemIndex,\n            }\n          );\n        } else if (error.response?.status &gt;= 500) {\n          // Server errors (5xx) - retry\n          if (attempt === retryCount) {\n            throw new NodeApiError(\n              this.getNode(),\n              error,\n              {\n                message: `Server error ${error.response.status} after ${retryCount} attempts`,\n                description: 'The server is experiencing issues. Try again later.',\n                itemIndex,\n              }\n            );\n          }\n        } else {\n          // Unknown error - retry once then fail\n          if (attempt === retryCount) {\n            throw new NodeApiError(\n              this.getNode(),\n              error,\n              {\n                message: `Unexpected error: ${error.message}`,\n                itemIndex,\n              }\n            );\n          }\n        }\n\n        // Wait before retrying (exponential backoff)\n        if (attempt &lt; retryCount) {\n          const delay = retryDelay * Math.pow(2, attempt - 1);\n          await new Promise(resolve =&gt; setTimeout(resolve, delay));\n        }\n      }\n    }\n\n    // This should never be reached, but just in case\n    throw lastError;\n  }\n\n  private async handleDataValidation(itemIndex: number): Promise&lt;any&gt; {\n    const email = this.getNodeParameter('email', itemIndex) as string;\n\n    // Validate email is provided\n    if (!email || email.trim() === '') {\n      throw new NodeOperationError(\n        this.getNode(),\n        'Email address is required',\n        {\n          description: 'Please provide a valid email address',\n          itemIndex,\n        }\n      );\n    }\n\n    // Validate email format\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    if (!emailRegex.test(email)) {\n      throw new NodeOperationError(\n        this.getNode(),\n        `Invalid email format: ${email}`,\n        {\n          description: 'Please provide a valid email address (e.g., user@example.com)',\n          itemIndex,\n        }\n      );\n    }\n\n    // Validate email domain (basic check)\n    const domain = email.split('@')[1];\n    const commonDomains = ['gmail.com', 'yahoo.com', 'outlook.com', 'hotmail.com'];\n    const isCommonDomain = commonDomains.includes(domain.toLowerCase());\n\n    // Check for suspicious patterns\n    const suspiciousPatterns = [\n      /test@test\\.com/i,\n      /example@example\\.com/i,\n      /admin@admin\\.com/i,\n    ];\n\n    const isSuspicious = suspiciousPatterns.some(pattern =&gt; pattern.test(email));\n\n    if (isSuspicious) {\n      throw new NodeOperationError(\n        this.getNode(),\n        `Suspicious email pattern detected: ${email}`,\n        {\n          description: 'This appears to be a test or placeholder email address',\n          itemIndex,\n        }\n      );\n    }\n\n    return {\n      email,\n      domain,\n      isCommonDomain,\n      validation: {\n        format: 'valid',\n        domain: 'checked',\n        suspicious: false,\n      },\n    };\n  }\n\n  private async handleFileProcessing(itemIndex: number): Promise&lt;any&gt; {\n    const filePath = this.getNodeParameter('filePath', itemIndex) as string;\n\n    if (!filePath || filePath.trim() === '') {\n      throw new NodeOperationError(\n        this.getNode(),\n        'File path is required',\n        {\n          description: 'Please provide a valid file path',\n          itemIndex,\n        }\n      );\n    }\n\n    try {\n      // Simulate file processing\n      const fs = require('fs').promises;\n\n      // Check if file exists\n      try {\n        await fs.access(filePath);\n      } catch (error) {\n        throw new NodeOperationError(\n          this.getNode(),\n          `File not found: ${filePath}`,\n          {\n            description: 'Please check that the file path is correct and the file exists',\n            itemIndex,\n          }\n        );\n      }\n\n      // Get file stats\n      const stats = await fs.stat(filePath);\n\n      if (!stats.isFile()) {\n        throw new NodeOperationError(\n          this.getNode(),\n          `Path is not a file: ${filePath}`,\n          {\n            description: 'Please provide a path to a file, not a directory',\n            itemIndex,\n          }\n        );\n      }\n\n      // Check file size (limit to 10MB for this example)\n      const maxSize = 10 * 1024 * 1024; // 10MB\n      if (stats.size &gt; maxSize) {\n        throw new NodeOperationError(\n          this.getNode(),\n          `File too large: ${(stats.size / 1024 / 1024).toFixed(2)}MB`,\n          {\n            description: `File size must be less than ${maxSize / 1024 / 1024}MB`,\n            itemIndex,\n          }\n        );\n      }\n\n      // Read file content\n      const content = await fs.readFile(filePath, 'utf8');\n\n      return {\n        filePath,\n        size: stats.size,\n        sizeFormatted: `${(stats.size / 1024).toFixed(2)} KB`,\n        modified: stats.mtime,\n        contentLength: content.length,\n        preview: content.substring(0, 100) + (content.length &gt; 100 ? '...' : ''),\n      };\n\n    } catch (error) {\n      if (error.code === 'ENOENT') {\n        throw new NodeOperationError(\n          this.getNode(),\n          `File not found: ${filePath}`,\n          {\n            description: 'Please check that the file path is correct',\n            itemIndex,\n          }\n        );\n      } else if (error.code === 'EACCES') {\n        throw new NodeOperationError(\n          this.getNode(),\n          `Permission denied: ${filePath}`,\n          {\n            description: 'Please check that you have permission to read this file',\n            itemIndex,\n          }\n        );\n      } else if (error.code === 'EISDIR') {\n        throw new NodeOperationError(\n          this.getNode(),\n          `Path is a directory: ${filePath}`,\n          {\n            description: 'Please provide a path to a file, not a directory',\n            itemIndex,\n          }\n        );\n      } else {\n        // Re-throw if it's already a Node error\n        if (error.name === 'NodeOperationError') {\n          throw error;\n        }\n\n        // Wrap unknown errors\n        throw new NodeOperationError(\n          this.getNode(),\n          `File processing error: ${error.message}`,\n          {\n            description: 'An unexpected error occurred while processing the file',\n            itemIndex,\n          }\n        );\n      }\n    }\n  }\n\n  private getApiErrorDescription(statusCode: number): string {\n    switch (statusCode) {\n      case 400:\n        return 'Bad Request - Check your request parameters';\n      case 401:\n        return 'Unauthorized - Check your authentication credentials';\n      case 403:\n        return 'Forbidden - You do not have permission to access this resource';\n      case 404:\n        return 'Not Found - The requested resource does not exist';\n      case 429:\n        return 'Too Many Requests - You are being rate limited';\n      case 500:\n        return 'Internal Server Error - The server encountered an error';\n      case 502:\n        return 'Bad Gateway - The server received an invalid response';\n      case 503:\n        return 'Service Unavailable - The server is temporarily unavailable';\n      case 504:\n        return 'Gateway Timeout - The server did not respond in time';\n      default:\n        return 'An error occurred while making the API request';\n    }\n  }\n}\n</code></pre>"},{"location":"advanced/ErrorHandling/#advanced-error-handling-with-custom-error-classes","title":"Advanced Error Handling with Custom Error Classes","text":"<pre><code>import {\n  IExecuteFunctions,\n  INodeExecutionData,\n  INodeType,\n  INodeTypeDescription,\n  NodeApiError,\n  NodeOperationError,\n} from 'n8n-workflow';\n\n// Custom error classes for specific scenarios\nclass ValidationError extends Error {\n  constructor(\n    message: string,\n    public field: string,\n    public value: any,\n    public suggestions?: string[]\n  ) {\n    super(message);\n    this.name = 'ValidationError';\n  }\n}\n\nclass RateLimitError extends Error {\n  constructor(\n    message: string,\n    public retryAfter: number,\n    public limit: number,\n    public remaining: number\n  ) {\n    super(message);\n    this.name = 'RateLimitError';\n  }\n}\n\nclass QuotaExceededError extends Error {\n  constructor(\n    message: string,\n    public quotaType: string,\n    public limit: number,\n    public used: number,\n    public resetDate?: Date\n  ) {\n    super(message);\n    this.name = 'QuotaExceededError';\n  }\n}\n\nexport class AdvancedErrorHandling implements INodeType {\n  description: INodeTypeDescription = {\n    displayName: 'Advanced Error Handling',\n    name: 'advancedErrorHandling',\n    group: ['transform'],\n    version: 1,\n    description: 'Advanced error handling with custom error types and recovery strategies',\n    defaults: {\n      name: 'Advanced Error Handling',\n    },\n    inputs: ['main'],\n    outputs: ['main'],\n    properties: [\n      {\n        displayName: 'API Key',\n        name: 'apiKey',\n        type: 'string',\n        typeOptions: {\n          password: true,\n        },\n        default: '',\n        description: 'API key for authentication',\n      },\n      {\n        displayName: 'User Data',\n        name: 'userData',\n        type: 'json',\n        default: '{\"name\": \"\", \"email\": \"\", \"age\": 0}',\n        description: 'User data to validate and process',\n      },\n      {\n        displayName: 'Error Recovery',\n        name: 'errorRecovery',\n        type: 'collection',\n        placeholder: 'Add Recovery Option',\n        default: {},\n        options: [\n          {\n            displayName: 'Auto Retry',\n            name: 'autoRetry',\n            type: 'boolean',\n            default: true,\n            description: 'Automatically retry failed requests',\n          },\n          {\n            displayName: 'Fallback to Cache',\n            name: 'fallbackToCache',\n            type: 'boolean',\n            default: false,\n            description: 'Use cached data if API fails',\n          },\n          {\n            displayName: 'Skip Invalid Items',\n            name: 'skipInvalid',\n            type: 'boolean',\n            default: false,\n            description: 'Skip items that fail validation',\n          },\n          {\n            displayName: 'Partial Success Mode',\n            name: 'partialSuccess',\n            type: 'boolean',\n            default: false,\n            description: 'Return successful items even if some fail',\n          },\n        ],\n      },\n    ],\n  };\n\n  async execute(this: IExecuteFunctions): Promise&lt;INodeExecutionData[][]&gt; {\n    const items = this.getInputData();\n    const returnData: INodeExecutionData[] = [];\n    const errorRecovery = this.getNodeParameter('errorRecovery', 0, {}) as any;\n\n    const errors: any[] = [];\n    const successful: any[] = [];\n\n    for (let i = 0; i &lt; items.length; i++) {\n      try {\n        const result = await this.processItem(i);\n        successful.push(result);\n        returnData.push({ json: result });\n\n      } catch (error) {\n        const errorInfo = this.handleError(error, i, errorRecovery);\n\n        if (errorInfo.recovered) {\n          // Error was recovered, add the recovery result\n          successful.push(errorInfo.result);\n          returnData.push({ json: errorInfo.result });\n        } else if (errorRecovery.partialSuccess) {\n          // Track error but continue processing\n          errors.push(errorInfo);\n        } else {\n          // Re-throw to stop execution\n          throw errorInfo.nodeError;\n        }\n      }\n    }\n\n    // If we have errors but are in partial success mode, include error summary\n    if (errors.length &gt; 0 &amp;&amp; errorRecovery.partialSuccess) {\n      returnData.push({\n        json: {\n          summary: {\n            successful: successful.length,\n            failed: errors.length,\n            total: items.length,\n            errors: errors.map(e =&gt; ({\n              itemIndex: e.itemIndex,\n              type: e.type,\n              message: e.message,\n            })),\n          },\n        },\n      });\n    }\n\n    return [returnData];\n  }\n\n  private async processItem(itemIndex: number): Promise&lt;any&gt; {\n    const apiKey = this.getNodeParameter('apiKey', itemIndex) as string;\n    const userDataStr = this.getNodeParameter('userData', itemIndex) as string;\n\n    // Validate API key\n    if (!apiKey || apiKey.trim() === '') {\n      throw new ValidationError(\n        'API key is required',\n        'apiKey',\n        apiKey,\n        ['Obtain an API key from your service provider', 'Check your credential configuration']\n      );\n    }\n\n    // Parse and validate user data\n    let userData: any;\n    try {\n      userData = JSON.parse(userDataStr);\n    } catch (error) {\n      throw new ValidationError(\n        'Invalid JSON in user data',\n        'userData',\n        userDataStr,\n        ['Check JSON syntax', 'Use double quotes for strings', 'Ensure proper bracket matching']\n      );\n    }\n\n    // Validate required fields\n    this.validateUserData(userData);\n\n    // Simulate API call with various error scenarios\n    const result = await this.simulateApiCall(apiKey, userData);\n\n    return {\n      success: true,\n      userData,\n      apiResponse: result,\n      processedAt: new Date().toISOString(),\n    };\n  }\n\n  private validateUserData(userData: any): void {\n    const errors: string[] = [];\n\n    // Validate name\n    if (!userData.name || typeof userData.name !== 'string' || userData.name.trim() === '') {\n      throw new ValidationError(\n        'Name is required and must be a non-empty string',\n        'name',\n        userData.name,\n        ['Provide a valid name', 'Name must be at least 1 character long']\n      );\n    }\n\n    if (userData.name.length &gt; 100) {\n      throw new ValidationError(\n        'Name is too long (maximum 100 characters)',\n        'name',\n        userData.name,\n        ['Shorten the name to 100 characters or less']\n      );\n    }\n\n    // Validate email\n    if (!userData.email || typeof userData.email !== 'string') {\n      throw new ValidationError(\n        'Email is required and must be a string',\n        'email',\n        userData.email,\n        ['Provide a valid email address']\n      );\n    }\n\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    if (!emailRegex.test(userData.email)) {\n      throw new ValidationError(\n        'Invalid email format',\n        'email',\n        userData.email,\n        ['Use format: user@domain.com', 'Check for typos in email address']\n      );\n    }\n\n    // Validate age\n    if (userData.age !== undefined) {\n      if (typeof userData.age !== 'number' || !Number.isInteger(userData.age)) {\n        throw new ValidationError(\n          'Age must be an integer',\n          'age',\n          userData.age,\n          ['Provide age as a whole number', 'Remove decimal places']\n        );\n      }\n\n      if (userData.age &lt; 0 || userData.age &gt; 150) {\n        throw new ValidationError(\n          'Age must be between 0 and 150',\n          'age',\n          userData.age,\n          ['Provide a realistic age value']\n        );\n      }\n    }\n  }\n\n  private async simulateApiCall(apiKey: string, userData: any): Promise&lt;any&gt; {\n    // Simulate different error scenarios based on input\n    const email = userData.email.toLowerCase();\n\n    if (email.includes('ratelimit')) {\n      throw new RateLimitError(\n        'Rate limit exceeded',\n        3600, // retry after 1 hour\n        1000, // limit per hour\n        0     // remaining requests\n      );\n    }\n\n    if (email.includes('quota')) {\n      throw new QuotaExceededError(\n        'Monthly quota exceeded',\n        'monthly_requests',\n        10000,\n        10000,\n        new Date(Date.now() + 30 * 24 * 60 * 60 * 1000) // reset in 30 days\n      );\n    }\n\n    if (email.includes('server')) {\n      const error = new Error('Internal server error');\n      (error as any).response = { status: 500, statusText: 'Internal Server Error' };\n      throw error;\n    }\n\n    if (email.includes('timeout')) {\n      const error = new Error('Request timeout');\n      (error as any).code = 'ETIMEDOUT';\n      throw error;\n    }\n\n    if (email.includes('unauthorized')) {\n      const error = new Error('Unauthorized');\n      (error as any).response = { status: 401, statusText: 'Unauthorized' };\n      throw error;\n    }\n\n    // Simulate successful response\n    return {\n      id: Math.floor(Math.random() * 10000),\n      status: 'created',\n      userData,\n      timestamp: new Date().toISOString(),\n    };\n  }\n\n  private handleError(error: Error, itemIndex: number, errorRecovery: any): any {\n    // Handle custom error types\n    if (error instanceof ValidationError) {\n      const nodeError = new NodeOperationError(\n        this.getNode(),\n        `Validation failed for ${error.field}: ${error.message}`,\n        {\n          description: error.suggestions?.join('. ') || 'Please check your input data',\n          itemIndex,\n        }\n      );\n\n      if (errorRecovery.skipInvalid) {\n        return {\n          recovered: true,\n          result: {\n            error: true,\n            type: 'validation',\n            field: error.field,\n            message: error.message,\n            suggestions: error.suggestions,\n            itemIndex,\n          },\n        };\n      }\n\n      return { recovered: false, nodeError, type: 'validation', message: error.message, itemIndex };\n    }\n\n    if (error instanceof RateLimitError) {\n      const nodeError = new NodeApiError(\n        this.getNode(),\n        error,\n        {\n          message: `Rate limit exceeded. Retry after ${error.retryAfter} seconds`,\n          description: `You have exceeded the rate limit of ${error.limit} requests. ${error.remaining} requests remaining.`,\n          itemIndex,\n        }\n      );\n\n      // Could implement automatic retry with delay here\n      return { recovered: false, nodeError, type: 'rateLimit', message: error.message, itemIndex };\n    }\n\n    if (error instanceof QuotaExceededError) {\n      const resetInfo = error.resetDate ? ` Quota resets on ${error.resetDate.toLocaleDateString()}` : '';\n      const nodeError = new NodeApiError(\n        this.getNode(),\n        error,\n        {\n          message: `${error.quotaType} quota exceeded: ${error.used}/${error.limit}`,\n          description: `You have exceeded your ${error.quotaType} quota.${resetInfo}`,\n          itemIndex,\n        }\n      );\n\n      return { recovered: false, nodeError, type: 'quota', message: error.message, itemIndex };\n    }\n\n    // Handle HTTP errors\n    if ((error as any).response?.status) {\n      const status = (error as any).response.status;\n\n      if (status &gt;= 500 &amp;&amp; errorRecovery.fallbackToCache) {\n        // Simulate cache fallback\n        return {\n          recovered: true,\n          result: {\n            fromCache: true,\n            message: 'Server error - returned cached data',\n            data: { id: 'cached', status: 'fallback' },\n            itemIndex,\n          },\n        };\n      }\n\n      const nodeError = new NodeApiError(\n        this.getNode(),\n        error,\n        {\n          message: `HTTP ${status}: ${(error as any).response.statusText}`,\n          description: this.getHttpErrorDescription(status),\n          itemIndex,\n        }\n      );\n\n      return { recovered: false, nodeError, type: 'http', message: error.message, itemIndex };\n    }\n\n    // Handle connection errors\n    if ((error as any).code === 'ETIMEDOUT' &amp;&amp; errorRecovery.autoRetry) {\n      // Could implement retry logic here\n      return {\n        recovered: true,\n        result: {\n          error: true,\n          type: 'timeout',\n          message: 'Request timed out - skipped',\n          itemIndex,\n        },\n      };\n    }\n\n    // Default error handling\n    const nodeError = new NodeOperationError(\n      this.getNode(),\n      `Unexpected error: ${error.message}`,\n      {\n        description: 'An unexpected error occurred during processing',\n        itemIndex,\n      }\n    );\n\n    return { recovered: false, nodeError, type: 'unknown', message: error.message, itemIndex };\n  }\n\n  private getHttpErrorDescription(status: number): string {\n    const descriptions: { [key: number]: string } = {\n      400: 'Bad Request - Check your request parameters and data format',\n      401: 'Unauthorized - Verify your API key and authentication',\n      403: 'Forbidden - You do not have permission for this operation',\n      404: 'Not Found - The requested resource does not exist',\n      409: 'Conflict - The resource already exists or there is a conflict',\n      422: 'Unprocessable Entity - Check your data format and required fields',\n      429: 'Too Many Requests - You are being rate limited, try again later',\n      500: 'Internal Server Error - The server encountered an error',\n      502: 'Bad Gateway - The server received an invalid response',\n      503: 'Service Unavailable - The server is temporarily unavailable',\n      504: 'Gateway Timeout - The server did not respond in time',\n    };\n\n    return descriptions[status] || 'An HTTP error occurred';\n  }\n}\n</code></pre> <p>Key Error Handling Patterns:</p> <ol> <li>Specific Error Types:</li> <li>Use <code>NodeApiError</code> for API-related issues</li> <li>Use <code>NodeOperationError</code> for logic/validation issues</li> <li> <p>Use <code>NodeConnectionError</code> for network problems</p> </li> <li> <p>Error Context:</p> </li> <li>Always include <code>itemIndex</code> for batch processing</li> <li>Provide actionable descriptions and suggestions</li> <li> <p>Include relevant error details (status codes, retry info)</p> </li> <li> <p>Recovery Strategies:</p> </li> <li>Retry with exponential backoff</li> <li>Fallback to cached data</li> <li>Skip invalid items and continue</li> <li> <p>Partial success mode for batch operations</p> </li> <li> <p>Custom Error Classes:</p> </li> <li>Create specific error types for domain-specific issues</li> <li>Include relevant metadata (retry times, quotas, etc.)</li> <li> <p>Provide structured error information</p> </li> <li> <p>User-Friendly Messages:</p> </li> <li>Clear, actionable error descriptions</li> <li>Suggestions for resolution</li> <li>Context about what went wrong and why</li> </ol> <p>This comprehensive error handling approach ensures robust nodes that provide excellent user experience even when things go wrong!</p>"},{"location":"advanced/ToolMetadata/","title":"Tool Metadata for AI","text":"<p>Adding metadata to n8n nodes enables AI systems to understand and use your nodes more effectively.</p>"},{"location":"advanced/ToolMetadata/#key-concepts","title":"Key Concepts","text":"<ul> <li>Tool metadata describes what your node does and how to use it</li> <li>Includes parameters, examples, and usage patterns</li> <li>Helps AI systems generate correct workflows</li> <li>Improves discoverability and usability</li> </ul>"},{"location":"advanced/ToolMetadata/#metadata-structure","title":"Metadata Structure","text":"<pre><code>interface IToolMetadata {\n  name: string;\n  description: string;\n  parameters: IToolParameter[];\n  examples?: IToolExample[];\n  categories?: string[];\n  tags?: string[];\n  useCases?: string[];\n}\n</code></pre>"},{"location":"advanced/ToolMetadata/#complete-tool-metadata-examples","title":"Complete Tool Metadata Examples","text":""},{"location":"advanced/ToolMetadata/#ai-optimized-node-with-rich-metadata","title":"AI-Optimized Node with Rich Metadata","text":"<pre><code>import {\n  IExecuteFunctions,\n  INodeExecutionData,\n  INodeType,\n  INodeTypeDescription,\n  NodeOperationError,\n} from 'n8n-workflow';\n\nexport class AIOptimizedNode implements INodeType {\n  description: INodeTypeDescription = {\n    displayName: 'AI Data Processor',\n    name: 'aiDataProcessor',\n    icon: 'fa:robot',\n    group: ['transform'],\n    version: 1,\n    description: 'Process and analyze data using AI-friendly operations',\n    defaults: {\n      name: 'AI Data Processor',\n    },\n    inputs: ['main'],\n    outputs: ['main'],\n\n    // AI Tool Metadata\n    codex: {\n      categories: ['Data Processing', 'AI/ML', 'Analytics'],\n      subcategories: ['Text Analysis', 'Data Transformation', 'Pattern Recognition'],\n      resources: {\n        primaryDocumentation: [\n          {\n            url: 'https://docs.n8n.io/nodes/ai-data-processor',\n            description: 'Complete guide to AI data processing',\n          },\n        ],\n        generic: [\n          {\n            label: 'AI Processing Best Practices',\n            icon: '\ud83e\udd16',\n            url: 'https://docs.n8n.io/ai-best-practices',\n          },\n        ],\n      },\n      alias: ['ai processor', 'data analyzer', 'ml preprocessor'],\n    },\n\n    // Tool metadata for AI systems\n    toolMetadata: {\n      name: 'AI Data Processor',\n      description: 'Processes and analyzes data using various AI-friendly operations including text analysis, data cleaning, pattern recognition, and statistical analysis',\n      parameters: [\n        {\n          name: 'operation',\n          type: 'string',\n          description: 'The type of processing operation to perform',\n          required: true,\n          enum: ['analyze_text', 'clean_data', 'extract_patterns', 'calculate_stats', 'classify_content'],\n          examples: ['analyze_text', 'clean_data'],\n        },\n        {\n          name: 'input_data',\n          type: 'string|object|array',\n          description: 'The data to process - can be text, JSON object, or array of items',\n          required: true,\n          examples: [\n            'This is sample text to analyze',\n            '{\"name\": \"John\", \"age\": 30}',\n            '[{\"id\": 1, \"value\": \"data1\"}, {\"id\": 2, \"value\": \"data2\"}]',\n          ],\n        },\n        {\n          name: 'analysis_options',\n          type: 'object',\n          description: 'Configuration options for the analysis',\n          required: false,\n          properties: {\n            language: {\n              type: 'string',\n              description: 'Language for text analysis',\n              default: 'en',\n              examples: ['en', 'es', 'fr', 'de'],\n            },\n            confidence_threshold: {\n              type: 'number',\n              description: 'Minimum confidence level for results (0-1)',\n              default: 0.7,\n              examples: [0.8, 0.9],\n            },\n            include_metadata: {\n              type: 'boolean',\n              description: 'Whether to include processing metadata in results',\n              default: true,\n            },\n          },\n        },\n      ],\n      examples: [\n        {\n          name: 'Analyze customer feedback',\n          description: 'Extract sentiment and key topics from customer reviews',\n          input: {\n            operation: 'analyze_text',\n            input_data: 'The product is amazing! Great quality and fast shipping.',\n            analysis_options: {\n              language: 'en',\n              confidence_threshold: 0.8,\n              include_metadata: true,\n            },\n          },\n          output: {\n            sentiment: 'positive',\n            confidence: 0.95,\n            topics: ['product quality', 'shipping'],\n            metadata: {\n              word_count: 9,\n              processing_time: '0.2s',\n            },\n          },\n        },\n        {\n          name: 'Clean messy data',\n          description: 'Remove duplicates and standardize format',\n          input: {\n            operation: 'clean_data',\n            input_data: [\n              { name: 'John Doe', email: 'john@example.com' },\n              { name: 'john doe', email: 'john@example.com' },\n              { name: 'Jane Smith', email: 'jane@test.com' },\n            ],\n          },\n          output: {\n            cleaned_data: [\n              { name: 'John Doe', email: 'john@example.com' },\n              { name: 'Jane Smith', email: 'jane@test.com' },\n            ],\n            removed_duplicates: 1,\n            standardized_fields: ['name'],\n          },\n        },\n      ],\n      useCases: [\n        'Sentiment analysis of customer feedback',\n        'Data cleaning and deduplication',\n        'Content classification and tagging',\n        'Pattern recognition in datasets',\n        'Statistical analysis and reporting',\n        'Text preprocessing for ML models',\n        'Data quality assessment',\n      ],\n      tags: ['ai', 'ml', 'data-processing', 'analytics', 'nlp', 'text-analysis'],\n    },\n\n    properties: [\n      {\n        displayName: 'Operation',\n        name: 'operation',\n        type: 'options',\n        noDataExpression: true,\n        options: [\n          {\n            name: 'Analyze Text',\n            value: 'analyze_text',\n            description: 'Perform sentiment analysis and extract key information from text',\n            action: 'Analyze text content',\n          },\n          {\n            name: 'Clean Data',\n            value: 'clean_data',\n            description: 'Remove duplicates, standardize formats, and clean messy data',\n            action: 'Clean and standardize data',\n          },\n          {\n            name: 'Extract Patterns',\n            value: 'extract_patterns',\n            description: 'Identify patterns and anomalies in datasets',\n            action: 'Extract data patterns',\n          },\n          {\n            name: 'Calculate Statistics',\n            value: 'calculate_stats',\n            description: 'Generate statistical summaries and insights',\n            action: 'Calculate statistical metrics',\n          },\n          {\n            name: 'Classify Content',\n            value: 'classify_content',\n            description: 'Categorize and tag content automatically',\n            action: 'Classify and categorize content',\n          },\n        ],\n        default: 'analyze_text',\n        description: 'The type of AI processing operation to perform',\n      },\n      {\n        displayName: 'Input Data',\n        name: 'inputData',\n        type: 'json',\n        default: '{}',\n        description: 'The data to process (text, JSON object, or array)',\n        placeholder: '{\"text\": \"Sample data to analyze\"}',\n      },\n      {\n        displayName: 'Analysis Options',\n        name: 'analysisOptions',\n        type: 'collection',\n        placeholder: 'Add Option',\n        default: {},\n        options: [\n          {\n            displayName: 'Language',\n            name: 'language',\n            type: 'options',\n            options: [\n              { name: 'English', value: 'en' },\n              { name: 'Spanish', value: 'es' },\n              { name: 'French', value: 'fr' },\n              { name: 'German', value: 'de' },\n              { name: 'Auto-detect', value: 'auto' },\n            ],\n            default: 'en',\n            description: 'Language for text analysis',\n          },\n          {\n            displayName: 'Confidence Threshold',\n            name: 'confidenceThreshold',\n            type: 'number',\n            typeOptions: {\n              minValue: 0,\n              maxValue: 1,\n              numberStepSize: 0.1,\n            },\n            default: 0.7,\n            description: 'Minimum confidence level for results (0-1)',\n          },\n          {\n            displayName: 'Include Metadata',\n            name: 'includeMetadata',\n            type: 'boolean',\n            default: true,\n            description: 'Include processing metadata in results',\n          },\n          {\n            displayName: 'Max Results',\n            name: 'maxResults',\n            type: 'number',\n            default: 100,\n            description: 'Maximum number of results to return',\n          },\n        ],\n      },\n      {\n        displayName: 'Output Format',\n        name: 'outputFormat',\n        type: 'options',\n        options: [\n          { name: 'Detailed', value: 'detailed' },\n          { name: 'Summary', value: 'summary' },\n          { name: 'Raw', value: 'raw' },\n        ],\n        default: 'detailed',\n        description: 'Format for the output results',\n      },\n    ],\n  };\n\n  async execute(this: IExecuteFunctions): Promise&lt;INodeExecutionData[][]&gt; {\n    const items = this.getInputData();\n    const returnData: INodeExecutionData[] = [];\n\n    for (let i = 0; i &lt; items.length; i++) {\n      try {\n        const operation = this.getNodeParameter('operation', i) as string;\n        const inputDataStr = this.getNodeParameter('inputData', i) as string;\n        const analysisOptions = this.getNodeParameter('analysisOptions', i, {}) as any;\n        const outputFormat = this.getNodeParameter('outputFormat', i) as string;\n\n        // Parse input data\n        let inputData: any;\n        try {\n          inputData = JSON.parse(inputDataStr);\n        } catch (error) {\n          // If not valid JSON, treat as plain text\n          inputData = inputDataStr;\n        }\n\n        let result: any;\n\n        switch (operation) {\n          case 'analyze_text':\n            result = await this.analyzeText(inputData, analysisOptions);\n            break;\n          case 'clean_data':\n            result = await this.cleanData(inputData, analysisOptions);\n            break;\n          case 'extract_patterns':\n            result = await this.extractPatterns(inputData, analysisOptions);\n            break;\n          case 'calculate_stats':\n            result = await this.calculateStats(inputData, analysisOptions);\n            break;\n          case 'classify_content':\n            result = await this.classifyContent(inputData, analysisOptions);\n            break;\n          default:\n            throw new NodeOperationError(\n              this.getNode(),\n              `Unknown operation: ${operation}`,\n              { itemIndex: i }\n            );\n        }\n\n        // Format output based on user preference\n        const formattedResult = this.formatOutput(result, outputFormat);\n\n        returnData.push({\n          json: {\n            operation,\n            success: true,\n            ...formattedResult,\n            metadata: {\n              processed_at: new Date().toISOString(),\n              item_index: i,\n              processing_options: analysisOptions,\n            },\n          },\n        });\n\n      } catch (error) {\n        throw new NodeOperationError(\n          this.getNode(),\n          `Processing failed: ${error.message}`,\n          { itemIndex: i }\n        );\n      }\n    }\n\n    return [returnData];\n  }\n\n  private async analyzeText(inputData: any, options: any): Promise&lt;any&gt; {\n    const text = typeof inputData === 'string' ? inputData : inputData.text || JSON.stringify(inputData);\n    const language = options.language || 'en';\n    const confidenceThreshold = options.confidenceThreshold || 0.7;\n\n    // Simulate text analysis\n    const words = text.split(/\\s+/).filter(word =&gt; word.length &gt; 0);\n    const sentences = text.split(/[.!?]+/).filter(s =&gt; s.trim().length &gt; 0);\n\n    // Simple sentiment analysis simulation\n    const positiveWords = ['good', 'great', 'excellent', 'amazing', 'wonderful', 'fantastic'];\n    const negativeWords = ['bad', 'terrible', 'awful', 'horrible', 'disappointing'];\n\n    const positiveCount = words.filter(word =&gt; \n      positiveWords.some(pos =&gt; word.toLowerCase().includes(pos))\n    ).length;\n    const negativeCount = words.filter(word =&gt; \n      negativeWords.some(neg =&gt; word.toLowerCase().includes(neg))\n    ).length;\n\n    let sentiment = 'neutral';\n    let confidence = 0.5;\n\n    if (positiveCount &gt; negativeCount) {\n      sentiment = 'positive';\n      confidence = Math.min(0.95, 0.6 + (positiveCount / words.length) * 2);\n    } else if (negativeCount &gt; positiveCount) {\n      sentiment = 'negative';\n      confidence = Math.min(0.95, 0.6 + (negativeCount / words.length) * 2);\n    }\n\n    // Extract key topics (simplified)\n    const topics = words\n      .filter(word =&gt; word.length &gt; 4)\n      .reduce((acc: any, word) =&gt; {\n        const key = word.toLowerCase();\n        acc[key] = (acc[key] || 0) + 1;\n        return acc;\n      }, {});\n\n    const topTopics = Object.entries(topics)\n      .sort(([,a], [,b]) =&gt; (b as number) - (a as number))\n      .slice(0, 5)\n      .map(([topic]) =&gt; topic);\n\n    return {\n      sentiment,\n      confidence,\n      topics: topTopics,\n      statistics: {\n        word_count: words.length,\n        sentence_count: sentences.length,\n        avg_words_per_sentence: words.length / sentences.length,\n        language_detected: language,\n      },\n      analysis_metadata: {\n        confidence_threshold: confidenceThreshold,\n        processing_time: '0.1s',\n      },\n    };\n  }\n\n  private async cleanData(inputData: any, options: any): Promise&lt;any&gt; {\n    if (!Array.isArray(inputData)) {\n      throw new NodeOperationError(\n        this.getNode(),\n        'Clean data operation requires an array of objects'\n      );\n    }\n\n    const originalCount = inputData.length;\n    let cleanedData = [...inputData];\n\n    // Remove duplicates based on all fields\n    const seen = new Set();\n    cleanedData = cleanedData.filter(item =&gt; {\n      const key = JSON.stringify(item);\n      if (seen.has(key)) {\n        return false;\n      }\n      seen.add(key);\n      return true;\n    });\n\n    // Standardize string fields\n    const standardizedFields: string[] = [];\n    cleanedData = cleanedData.map(item =&gt; {\n      const cleaned = { ...item };\n      Object.keys(cleaned).forEach(key =&gt; {\n        if (typeof cleaned[key] === 'string') {\n          const original = cleaned[key];\n          cleaned[key] = cleaned[key].trim();\n\n          // Standardize name fields\n          if (key.toLowerCase().includes('name')) {\n            cleaned[key] = cleaned[key]\n              .split(' ')\n              .map((word: string) =&gt; word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())\n              .join(' ');\n            if (original !== cleaned[key] &amp;&amp; !standardizedFields.includes(key)) {\n              standardizedFields.push(key);\n            }\n          }\n        }\n      });\n      return cleaned;\n    });\n\n    return {\n      cleaned_data: cleanedData,\n      statistics: {\n        original_count: originalCount,\n        cleaned_count: cleanedData.length,\n        removed_duplicates: originalCount - cleanedData.length,\n        standardized_fields: standardizedFields,\n      },\n    };\n  }\n\n  private async extractPatterns(inputData: any, options: any): Promise&lt;any&gt; {\n    if (!Array.isArray(inputData)) {\n      throw new NodeOperationError(\n        this.getNode(),\n        'Pattern extraction requires an array of data'\n      );\n    }\n\n    // Analyze data structure patterns\n    const fieldTypes: { [key: string]: { [type: string]: number } } = {};\n    const fieldValues: { [key: string]: any[] } = {};\n\n    inputData.forEach(item =&gt; {\n      Object.entries(item).forEach(([key, value]) =&gt; {\n        if (!fieldTypes[key]) {\n          fieldTypes[key] = {};\n          fieldValues[key] = [];\n        }\n\n        const type = typeof value;\n        fieldTypes[key][type] = (fieldTypes[key][type] || 0) + 1;\n        fieldValues[key].push(value);\n      });\n    });\n\n    // Detect patterns\n    const patterns: any[] = [];\n\n    Object.entries(fieldValues).forEach(([field, values]) =&gt; {\n      const uniqueValues = [...new Set(values)];\n      const uniqueRatio = uniqueValues.length / values.length;\n\n      if (uniqueRatio &lt; 0.1) {\n        patterns.push({\n          type: 'low_cardinality',\n          field,\n          description: `Field '${field}' has low cardinality (${uniqueValues.length} unique values)`,\n          unique_values: uniqueValues.slice(0, 10),\n        });\n      }\n\n      if (field.toLowerCase().includes('email')) {\n        const emailPattern = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n        const validEmails = values.filter(v =&gt; typeof v === 'string' &amp;&amp; emailPattern.test(v));\n        if (validEmails.length !== values.length) {\n          patterns.push({\n            type: 'data_quality_issue',\n            field,\n            description: `Field '${field}' contains invalid email addresses`,\n            valid_count: validEmails.length,\n            total_count: values.length,\n          });\n        }\n      }\n    });\n\n    return {\n      patterns,\n      field_analysis: fieldTypes,\n      data_summary: {\n        total_records: inputData.length,\n        total_fields: Object.keys(fieldTypes).length,\n        patterns_found: patterns.length,\n      },\n    };\n  }\n\n  private async calculateStats(inputData: any, options: any): Promise&lt;any&gt; {\n    if (!Array.isArray(inputData)) {\n      throw new NodeOperationError(\n        this.getNode(),\n        'Statistical analysis requires an array of data'\n      );\n    }\n\n    const numericFields: { [key: string]: number[] } = {};\n    const textFields: { [key: string]: string[] } = {};\n\n    // Separate numeric and text fields\n    inputData.forEach(item =&gt; {\n      Object.entries(item).forEach(([key, value]) =&gt; {\n        if (typeof value === 'number') {\n          if (!numericFields[key]) numericFields[key] = [];\n          numericFields[key].push(value);\n        } else if (typeof value === 'string') {\n          if (!textFields[key]) textFields[key] = [];\n          textFields[key].push(value);\n        }\n      });\n    });\n\n    // Calculate statistics for numeric fields\n    const numericStats: { [key: string]: any } = {};\n    Object.entries(numericFields).forEach(([field, values]) =&gt; {\n      const sorted = [...values].sort((a, b) =&gt; a - b);\n      const sum = values.reduce((a, b) =&gt; a + b, 0);\n      const mean = sum / values.length;\n      const variance = values.reduce((acc, val) =&gt; acc + Math.pow(val - mean, 2), 0) / values.length;\n\n      numericStats[field] = {\n        count: values.length,\n        min: Math.min(...values),\n        max: Math.max(...values),\n        mean: Math.round(mean * 100) / 100,\n        median: sorted[Math.floor(sorted.length / 2)],\n        std_dev: Math.round(Math.sqrt(variance) * 100) / 100,\n        sum,\n      };\n    });\n\n    // Calculate statistics for text fields\n    const textStats: { [key: string]: any } = {};\n    Object.entries(textFields).forEach(([field, values]) =&gt; {\n      const lengths = values.map(v =&gt; v.length);\n      const uniqueValues = [...new Set(values)];\n\n      textStats[field] = {\n        count: values.length,\n        unique_count: uniqueValues.length,\n        avg_length: Math.round(lengths.reduce((a, b) =&gt; a + b, 0) / lengths.length * 100) / 100,\n        min_length: Math.min(...lengths),\n        max_length: Math.max(...lengths),\n        most_common: this.getMostCommon(values, 5),\n      };\n    });\n\n    return {\n      numeric_statistics: numericStats,\n      text_statistics: textStats,\n      overall_summary: {\n        total_records: inputData.length,\n        numeric_fields: Object.keys(numericFields).length,\n        text_fields: Object.keys(textFields).length,\n      },\n    };\n  }\n\n  private async classifyContent(inputData: any, options: any): Promise&lt;any&gt; {\n    const text = typeof inputData === 'string' ? inputData : inputData.text || JSON.stringify(inputData);\n    const confidenceThreshold = options.confidenceThreshold || 0.7;\n\n    // Simple content classification\n    const categories = [\n      { name: 'business', keywords: ['business', 'company', 'corporate', 'enterprise', 'commercial'] },\n      { name: 'technology', keywords: ['tech', 'software', 'computer', 'digital', 'ai', 'ml'] },\n      { name: 'health', keywords: ['health', 'medical', 'doctor', 'hospital', 'medicine'] },\n      { name: 'education', keywords: ['education', 'school', 'university', 'learning', 'student'] },\n      { name: 'entertainment', keywords: ['movie', 'music', 'game', 'entertainment', 'fun'] },\n    ];\n\n    const textLower = text.toLowerCase();\n    const scores = categories.map(category =&gt; {\n      const matches = category.keywords.filter(keyword =&gt; textLower.includes(keyword)).length;\n      const score = matches / category.keywords.length;\n      return { category: category.name, score, matches };\n    });\n\n    const topCategories = scores\n      .filter(s =&gt; s.score &gt;= confidenceThreshold)\n      .sort((a, b) =&gt; b.score - a.score)\n      .slice(0, 3);\n\n    // Generate tags based on content\n    const words = text.split(/\\s+/).filter(word =&gt; word.length &gt; 3);\n    const tags = [...new Set(words.map(w =&gt; w.toLowerCase()))]\n      .slice(0, 10);\n\n    return {\n      categories: topCategories,\n      primary_category: topCategories[0]?.category || 'uncategorized',\n      confidence: topCategories[0]?.score || 0,\n      tags,\n      classification_metadata: {\n        confidence_threshold: confidenceThreshold,\n        total_categories_evaluated: categories.length,\n        text_length: text.length,\n      },\n    };\n  }\n\n  private formatOutput(result: any, format: string): any {\n    switch (format) {\n      case 'summary':\n        return {\n          summary: this.createSummary(result),\n          key_insights: this.extractKeyInsights(result),\n        };\n      case 'raw':\n        return { raw_data: result };\n      case 'detailed':\n      default:\n        return result;\n    }\n  }\n\n  private createSummary(result: any): string {\n    if (result.sentiment) {\n      return `Text analysis completed: ${result.sentiment} sentiment (${(result.confidence * 100).toFixed(1)}% confidence)`;\n    }\n    if (result.cleaned_data) {\n      return `Data cleaning completed: ${result.statistics.removed_duplicates} duplicates removed from ${result.statistics.original_count} records`;\n    }\n    if (result.patterns) {\n      return `Pattern analysis completed: ${result.patterns.length} patterns found in ${result.data_summary.total_records} records`;\n    }\n    if (result.numeric_statistics) {\n      return `Statistical analysis completed: ${Object.keys(result.numeric_statistics).length} numeric fields analyzed`;\n    }\n    if (result.categories) {\n      return `Content classification completed: ${result.primary_category} (${(result.confidence * 100).toFixed(1)}% confidence)`;\n    }\n    return 'Processing completed successfully';\n  }\n\n  private extractKeyInsights(result: any): string[] {\n    const insights: string[] = [];\n\n    if (result.sentiment) {\n      insights.push(`Sentiment is ${result.sentiment} with high confidence`);\n      if (result.topics?.length &gt; 0) {\n        insights.push(`Key topics: ${result.topics.slice(0, 3).join(', ')}`);\n      }\n    }\n\n    if (result.patterns) {\n      result.patterns.forEach((pattern: any) =&gt; {\n        insights.push(`${pattern.type}: ${pattern.description}`);\n      });\n    }\n\n    if (result.categories) {\n      insights.push(`Primary category: ${result.primary_category}`);\n    }\n\n    return insights.slice(0, 5); // Limit to top 5 insights\n  }\n\n  private getMostCommon(arr: string[], limit: number): Array&lt;{ value: string; count: number }&gt; {\n    const counts: { [key: string]: number } = {};\n    arr.forEach(item =&gt; {\n      counts[item] = (counts[item] || 0) + 1;\n    });\n\n    return Object.entries(counts)\n      .sort(([,a], [,b]) =&gt; b - a)\n      .slice(0, limit)\n      .map(([value, count]) =&gt; ({ value, count }));\n  }\n}\n</code></pre> <p>Key Tool Metadata Patterns:</p> <ol> <li> <p>Rich Descriptions: <pre><code>toolMetadata: {\n  name: 'Clear, descriptive name',\n  description: 'Detailed explanation of what the tool does and its capabilities',\n}\n</code></pre></p> </li> <li> <p>Parameter Documentation: <pre><code>parameters: [\n  {\n    name: 'parameter_name',\n    type: 'string|number|boolean|object|array',\n    description: 'Clear description of what this parameter does',\n    required: true,\n    examples: ['example1', 'example2'],\n  }\n]\n</code></pre></p> </li> <li> <p>Usage Examples: <pre><code>examples: [\n  {\n    name: 'Example name',\n    description: 'What this example demonstrates',\n    input: { /* example input */ },\n    output: { /* expected output */ },\n  }\n]\n</code></pre></p> </li> <li> <p>Categorization: <pre><code>categories: ['Data Processing', 'AI/ML'],\ntags: ['ai', 'ml', 'data-processing'],\nuseCases: ['Specific use case descriptions'],\n</code></pre></p> </li> <li> <p>Codex Integration: <pre><code>codex: {\n  categories: ['Primary Category'],\n  subcategories: ['Specific Subcategory'],\n  alias: ['alternative names'],\n}\n</code></pre></p> </li> </ol> <p>This comprehensive metadata approach makes nodes highly discoverable and usable by AI systems, improving the overall automation experience!</p>"},{"location":"credential-patterns/APIKey/","title":"API Key Authentication","text":"<p>API key credentials are one of the simplest forms of authentication. The key is usually passed in a header or query parameter.</p>"},{"location":"credential-patterns/APIKey/#credential-definition","title":"Credential Definition","text":"<pre><code>export class ApiKeyAuth implements ICredentialType {\n  name = \"apiKeyAuth\"\n  displayName = \"API Key Auth\"\n  properties = [\n    {\n      displayName: \"API Key\",\n      name: \"apiKey\",\n      type: \"string\",\n      default: \"\",\n    },\n  ]\n  authenticate = {\n    type: \"generic\",\n    properties: {\n      headers: {\n        \"X-API-Key\": \"={{$credentials.apiKey}}\",\n      },\n    },\n  }\n}\n</code></pre>"},{"location":"credential-patterns/APIKey/#use-cases","title":"Use Cases","text":"<ul> <li>Public APIs with simple access control</li> <li>Services that don't require OAuth or user context</li> </ul>"},{"location":"credential-patterns/APIKey/#tips","title":"Tips","text":"<ul> <li>Always mark the field as <code>typeOptions: { password: true }</code> if sensitive</li> <li>Some APIs use <code>Authorization: Bearer</code> instead of a custom header</li> </ul>"},{"location":"credential-patterns/APIKey/#api-key-in-query-string-vs-header","title":"API Key in Query String vs Header","text":"<p>Here are examples showing both common API key authentication patterns:</p> <p>Header-based API Key: <pre><code>export class HeaderApiKeyAuth implements ICredentialType {\n  name = 'headerApiKeyAuth';\n  displayName = 'Header API Key Auth';\n  documentationUrl = 'https://docs.example.com/auth';\n  properties: INodeProperties[] = [\n    {\n      displayName: 'API Key',\n      name: 'apiKey',\n      type: 'string',\n      typeOptions: {\n        password: true,\n      },\n      default: '',\n      required: true,\n      description: 'Your API key from the service dashboard',\n    },\n  ];\n\n  authenticate: IAuthenticateGeneric = {\n    type: 'generic',\n    properties: {\n      headers: {\n        'X-API-Key': '={{$credentials.apiKey}}',\n      },\n    },\n  };\n}\n</code></pre></p> <p>Query Parameter API Key: <pre><code>export class QueryApiKeyAuth implements ICredentialType {\n  name = 'queryApiKeyAuth';\n  displayName = 'Query API Key Auth';\n  documentationUrl = 'https://docs.example.com/auth';\n  properties: INodeProperties[] = [\n    {\n      displayName: 'API Key',\n      name: 'apiKey',\n      type: 'string',\n      typeOptions: {\n        password: true,\n      },\n      default: '',\n      required: true,\n      description: 'Your API key from the service dashboard',\n    },\n  ];\n\n  authenticate: IAuthenticateGeneric = {\n    type: 'generic',\n    properties: {\n      qs: {\n        'api_key': '={{$credentials.apiKey}}',\n      },\n    },\n  };\n}\n</code></pre></p> <p>Bearer Token Style: <pre><code>export class BearerTokenAuth implements ICredentialType {\n  name = 'bearerTokenAuth';\n  displayName = 'Bearer Token Auth';\n  documentationUrl = 'https://docs.example.com/auth';\n  properties: INodeProperties[] = [\n    {\n      displayName: 'Access Token',\n      name: 'accessToken',\n      type: 'string',\n      typeOptions: {\n        password: true,\n      },\n      default: '',\n      required: true,\n      description: 'Your access token from the service',\n    },\n  ];\n\n  authenticate: IAuthenticateGeneric = {\n    type: 'generic',\n    properties: {\n      headers: {\n        'Authorization': 'Bearer ={{$credentials.accessToken}}',\n      },\n    },\n  };\n}\n</code></pre></p> <p>Choose the pattern that matches your API's authentication requirements. Most modern APIs prefer header-based authentication for security reasons.</p>"},{"location":"credential-patterns/CredentialTesting/","title":"Credential Testing","text":"<p>Credential testing allows users to verify their credentials before using them in a workflow.</p>"},{"location":"credential-patterns/CredentialTesting/#how-it-works","title":"How It Works","text":"<p>You define a <code>test</code> block in the credential class:</p> <pre><code>test: ICredentialTestRequest = {\n  request: {\n    baseURL: \"={{$credentials.baseUrl}}\",\n    url: \"/me\",\n    method: \"GET\",\n    headers: {\n      Authorization: \"Bearer {{$credentials.apiKey}}\",\n    },\n  },\n}\n</code></pre>"},{"location":"credential-patterns/CredentialTesting/#use-cases","title":"Use Cases","text":"<ul> <li>Validate API keys or tokens</li> <li>Confirm connectivity to external services</li> <li>Provide early feedback to users</li> </ul>"},{"location":"credential-patterns/CredentialTesting/#tips","title":"Tips","text":"<ul> <li>Use a lightweight endpoint like <code>/me</code> or <code>/ping</code></li> <li>Avoid endpoints that mutate data</li> <li>Use <code>{{$credentials.xxx}}</code> to interpolate values</li> </ul>"},{"location":"credential-patterns/CredentialTesting/#complete-credential-testing-examples","title":"Complete Credential Testing Examples","text":"<p>Here are comprehensive examples showing different credential testing patterns:</p> <p>Simple API Key Test: <pre><code>import {\n  ICredentialType,\n  INodeProperties,\n  ICredentialTestRequest,\n} from 'n8n-workflow';\n\nexport class SimpleApiCredentials implements ICredentialType {\n  name = 'simpleApiCredentials';\n  displayName = 'Simple API Credentials';\n  documentationUrl = 'https://docs.example.com/auth';\n  properties: INodeProperties[] = [\n    {\n      displayName: 'API Key',\n      name: 'apiKey',\n      type: 'string',\n      typeOptions: {\n        password: true,\n      },\n      default: '',\n      required: true,\n    },\n    {\n      displayName: 'Base URL',\n      name: 'baseUrl',\n      type: 'string',\n      default: 'https://api.example.com',\n      required: true,\n    },\n  ];\n\n  test: ICredentialTestRequest = {\n    request: {\n      baseURL: '={{$credentials.baseUrl}}',\n      url: '/user/profile',\n      method: 'GET',\n      headers: {\n        'X-API-Key': '={{$credentials.apiKey}}',\n      },\n    },\n  };\n}\n</code></pre></p> <p>OAuth2 Token Test: <pre><code>export class OAuth2ApiCredentials implements ICredentialType {\n  name = 'oAuth2ApiCredentials';\n  extends = ['oAuth2Api'];\n  displayName = 'OAuth2 API Credentials';\n  documentationUrl = 'https://docs.example.com/oauth';\n  properties: INodeProperties[] = [\n    {\n      displayName: 'Scope',\n      name: 'scope',\n      type: 'hidden',\n      default: 'read:user',\n    },\n  ];\n\n  test: ICredentialTestRequest = {\n    request: {\n      baseURL: 'https://api.example.com',\n      url: '/user',\n      method: 'GET',\n      // OAuth2 token automatically injected by n8n\n    },\n  };\n}\n</code></pre></p> <p>Custom Test with Error Handling: <pre><code>import {\n  ICredentialType,\n  INodeProperties,\n  ICredentialTestRequest,\n  ICredentialTestFunctions,\n  ICredentialDataDecryptedObject,\n} from 'n8n-workflow';\n\nexport class AdvancedApiCredentials implements ICredentialType {\n  name = 'advancedApiCredentials';\n  displayName = 'Advanced API Credentials';\n  documentationUrl = 'https://docs.example.com/auth';\n  properties: INodeProperties[] = [\n    {\n      displayName: 'Username',\n      name: 'username',\n      type: 'string',\n      default: '',\n      required: true,\n    },\n    {\n      displayName: 'Password',\n      name: 'password',\n      type: 'string',\n      typeOptions: {\n        password: true,\n      },\n      default: '',\n      required: true,\n    },\n    {\n      displayName: 'Server URL',\n      name: 'serverUrl',\n      type: 'string',\n      default: 'https://api.example.com',\n      required: true,\n    },\n  ];\n\n  async test(\n    this: ICredentialTestFunctions,\n    credential: ICredentialDataDecryptedObject,\n  ): Promise&lt;boolean&gt; {\n    const { username, password, serverUrl } = credential;\n\n    try {\n      // Custom authentication logic\n      const authResponse = await this.helpers.request({\n        method: 'POST',\n        url: `${serverUrl}/auth/login`,\n        body: {\n          username,\n          password,\n        },\n        json: true,\n      });\n\n      if (!authResponse.token) {\n        throw new Error('No authentication token received');\n      }\n\n      // Test the token with a protected endpoint\n      const testResponse = await this.helpers.request({\n        method: 'GET',\n        url: `${serverUrl}/user/profile`,\n        headers: {\n          'Authorization': `Bearer ${authResponse.token}`,\n        },\n        json: true,\n      });\n\n      // Validate response structure\n      if (!testResponse.id || !testResponse.email) {\n        throw new Error('Invalid user profile response');\n      }\n\n      return true;\n\n    } catch (error) {\n      if (error.statusCode === 401) {\n        throw new Error('Invalid username or password');\n      }\n\n      if (error.statusCode === 403) {\n        throw new Error('Account does not have sufficient permissions');\n      }\n\n      if (error.code === 'ENOTFOUND') {\n        throw new Error('Server URL is not reachable. Please check the URL.');\n      }\n\n      throw new Error(`Connection test failed: ${error.message}`);\n    }\n  }\n}\n</code></pre></p> <p>Database Connection Test: <pre><code>export class DatabaseCredentials implements ICredentialType {\n  name = 'databaseCredentials';\n  displayName = 'Database Credentials';\n  documentationUrl = 'https://docs.example.com/database';\n  properties: INodeProperties[] = [\n    {\n      displayName: 'Host',\n      name: 'host',\n      type: 'string',\n      default: 'localhost',\n      required: true,\n    },\n    {\n      displayName: 'Port',\n      name: 'port',\n      type: 'number',\n      default: 5432,\n      required: true,\n    },\n    {\n      displayName: 'Database',\n      name: 'database',\n      type: 'string',\n      default: '',\n      required: true,\n    },\n    {\n      displayName: 'Username',\n      name: 'username',\n      type: 'string',\n      default: '',\n      required: true,\n    },\n    {\n      displayName: 'Password',\n      name: 'password',\n      type: 'string',\n      typeOptions: {\n        password: true,\n      },\n      default: '',\n      required: true,\n    },\n  ];\n\n  async test(\n    this: ICredentialTestFunctions,\n    credential: ICredentialDataDecryptedObject,\n  ): Promise&lt;boolean&gt; {\n    const { host, port, database, username, password } = credential;\n\n    try {\n      // Example using a hypothetical database client\n      const { Client } = require('pg'); // PostgreSQL example\n\n      const client = new Client({\n        host: host as string,\n        port: port as number,\n        database: database as string,\n        user: username as string,\n        password: password as string,\n        connectionTimeoutMillis: 5000, // 5 second timeout\n      });\n\n      await client.connect();\n\n      // Test with a simple query\n      const result = await client.query('SELECT 1 as test');\n\n      await client.end();\n\n      if (result.rows[0].test !== 1) {\n        throw new Error('Database test query failed');\n      }\n\n      return true;\n\n    } catch (error) {\n      if (error.code === 'ENOTFOUND') {\n        throw new Error(`Cannot reach database host: ${host}`);\n      }\n\n      if (error.code === 'ECONNREFUSED') {\n        throw new Error(`Connection refused. Check if database is running on port ${port}`);\n      }\n\n      if (error.code === '28P01') {\n        throw new Error('Invalid username or password');\n      }\n\n      if (error.code === '3D000') {\n        throw new Error(`Database '${database}' does not exist`);\n      }\n\n      throw new Error(`Database connection failed: ${error.message}`);\n    }\n  }\n}\n</code></pre></p> <p>Multi-Step Validation Test: <pre><code>export class ComplexApiCredentials implements ICredentialType {\n  name = 'complexApiCredentials';\n  displayName = 'Complex API Credentials';\n  documentationUrl = 'https://docs.example.com/auth';\n  properties: INodeProperties[] = [\n    {\n      displayName: 'Client ID',\n      name: 'clientId',\n      type: 'string',\n      default: '',\n      required: true,\n    },\n    {\n      displayName: 'Client Secret',\n      name: 'clientSecret',\n      type: 'string',\n      typeOptions: {\n        password: true,\n      },\n      default: '',\n      required: true,\n    },\n    {\n      displayName: 'Environment',\n      name: 'environment',\n      type: 'options',\n      options: [\n        {\n          name: 'Production',\n          value: 'production',\n        },\n        {\n          name: 'Sandbox',\n          value: 'sandbox',\n        },\n      ],\n      default: 'sandbox',\n    },\n  ];\n\n  async test(\n    this: ICredentialTestFunctions,\n    credential: ICredentialDataDecryptedObject,\n  ): Promise&lt;boolean&gt; {\n    const { clientId, clientSecret, environment } = credential;\n\n    const baseUrl = environment === 'production' \n      ? 'https://api.example.com'\n      : 'https://sandbox-api.example.com';\n\n    try {\n      // Step 1: Get access token\n      const tokenResponse = await this.helpers.request({\n        method: 'POST',\n        url: `${baseUrl}/oauth/token`,\n        body: {\n          grant_type: 'client_credentials',\n          client_id: clientId,\n          client_secret: clientSecret,\n        },\n        json: true,\n      });\n\n      if (!tokenResponse.access_token) {\n        throw new Error('Failed to obtain access token');\n      }\n\n      // Step 2: Test token with API call\n      const apiResponse = await this.helpers.request({\n        method: 'GET',\n        url: `${baseUrl}/account/info`,\n        headers: {\n          'Authorization': `Bearer ${tokenResponse.access_token}`,\n        },\n        json: true,\n      });\n\n      // Step 3: Validate account permissions\n      if (!apiResponse.permissions || !Array.isArray(apiResponse.permissions)) {\n        throw new Error('Account permissions not found');\n      }\n\n      const requiredPermissions = ['read', 'write'];\n      const hasRequiredPermissions = requiredPermissions.every(\n        permission =&gt; apiResponse.permissions.includes(permission)\n      );\n\n      if (!hasRequiredPermissions) {\n        throw new Error(\n          `Account missing required permissions: ${requiredPermissions.join(', ')}`\n        );\n      }\n\n      return true;\n\n    } catch (error) {\n      if (error.statusCode === 401) {\n        throw new Error('Invalid client credentials');\n      }\n\n      if (error.statusCode === 403) {\n        throw new Error('Client does not have API access permissions');\n      }\n\n      throw new Error(`Credential test failed: ${error.message}`);\n    }\n  }\n}\n</code></pre></p> <p>These examples demonstrate: - Simple tests: Using the <code>test.request</code> property for basic validation - Custom tests: Using the <code>test()</code> method for complex validation logic - Error handling: Providing specific error messages for different failure scenarios - Multi-step validation: Testing authentication flow and permissions - Environment-specific testing: Different endpoints based on configuration</p> <p>Credential testing provides immediate feedback to users and prevents workflow failures due to invalid credentials.</p>"},{"location":"credential-patterns/ManualInjection/","title":"Manual Injection Authentication","text":"<p>Some nodes use credentials without <code>genericAuth</code> or <code>authenticate()</code>. Instead, the node manually injects the credential values into the request.</p>"},{"location":"credential-patterns/ManualInjection/#credential-definition","title":"Credential Definition","text":"<pre><code>export class TelegramApi implements ICredentialType {\n  name = \"telegramApi\"\n  displayName = \"Telegram API\"\n  properties = [\n    {\n      displayName: \"Access Token\",\n      name: \"accessToken\",\n      type: \"string\",\n      typeOptions: { password: true },\n      default: \"\",\n    },\n  ]\n}\n</code></pre>"},{"location":"credential-patterns/ManualInjection/#node-usage","title":"Node Usage","text":"<pre><code>const credentials = await this.getCredentials(\"telegramApi\")\nconst url = `${credentials.baseUrl}/bot${credentials.accessToken}/sendMessage`\n</code></pre>"},{"location":"credential-patterns/ManualInjection/#use-cases","title":"Use Cases","text":"<ul> <li>Simple token-based APIs</li> <li>Nodes that construct custom URLs or headers</li> </ul>"},{"location":"credential-patterns/ManualInjection/#tips","title":"Tips","text":"<ul> <li>Use <code>typeOptions: { password: true }</code> for sensitive fields</li> <li>Add a <code>test</code> block to validate credentials</li> </ul>"},{"location":"credential-patterns/ManualInjection/#manual-credential-access-in-execute","title":"Manual Credential Access in Execute","text":"<p>Here's how to manually access and use credentials in your node's execute method:</p> <p>Simple Token Injection: <pre><code>import {\n  IExecuteFunctions,\n  INodeExecutionData,\n  INodeType,\n  INodeTypeDescription,\n  NodeApiError,\n} from 'n8n-workflow';\n\nexport class TelegramNode implements INodeType {\n  description: INodeTypeDescription = {\n    displayName: 'Telegram',\n    name: 'telegram',\n    icon: 'file:telegram.svg',\n    group: ['communication'],\n    version: 1,\n    description: 'Send messages via Telegram Bot API',\n    defaults: {\n      name: 'Telegram',\n    },\n    inputs: ['main'],\n    outputs: ['main'],\n    credentials: [\n      {\n        name: 'telegramApi',\n        required: true,\n      },\n    ],\n    properties: [\n      {\n        displayName: 'Chat ID',\n        name: 'chatId',\n        type: 'string',\n        default: '',\n        required: true,\n        description: 'The chat ID to send the message to',\n      },\n      {\n        displayName: 'Message',\n        name: 'message',\n        type: 'string',\n        default: '',\n        required: true,\n        description: 'The message to send',\n      },\n    ],\n  };\n\n  async execute(this: IExecuteFunctions): Promise&lt;INodeExecutionData[][]&gt; {\n    const items = this.getInputData();\n    const returnData: INodeExecutionData[] = [];\n\n    // Get credentials manually\n    const credentials = await this.getCredentials('telegramApi');\n\n    if (!credentials) {\n      throw new NodeApiError(this.getNode(), {\n        message: 'No credentials found',\n        description: 'Please configure Telegram API credentials',\n      });\n    }\n\n    for (let i = 0; i &lt; items.length; i++) {\n      const chatId = this.getNodeParameter('chatId', i) as string;\n      const message = this.getNodeParameter('message', i) as string;\n\n      try {\n        // Manually construct the URL with the token\n        const url = `https://api.telegram.org/bot${credentials.accessToken}/sendMessage`;\n\n        const response = await this.helpers.request({\n          method: 'POST',\n          url,\n          body: {\n            chat_id: chatId,\n            text: message,\n          },\n          json: true,\n        });\n\n        returnData.push({\n          json: response,\n        });\n\n      } catch (error) {\n        throw new NodeApiError(this.getNode(), error, {\n          message: `Failed to send Telegram message to chat ${chatId}`,\n          description: error.message,\n        });\n      }\n    }\n\n    return [returnData];\n  }\n}\n</code></pre></p> <p>Complex Credential Processing: <pre><code>export class CustomApiNode implements INodeType {\n  // ... node description ...\n\n  async execute(this: IExecuteFunctions): Promise&lt;INodeExecutionData[][]&gt; {\n    const items = this.getInputData();\n    const returnData: INodeExecutionData[] = [];\n\n    // Get credentials with type safety\n    const credentials = await this.getCredentials('customApi') as {\n      apiKey: string;\n      secretKey: string;\n      baseUrl: string;\n      region?: string;\n    };\n\n    for (let i = 0; i &lt; items.length; i++) {\n      const operation = this.getNodeParameter('operation', i) as string;\n\n      try {\n        let requestOptions: any = {\n          method: 'GET',\n          json: true,\n        };\n\n        // Manually construct authentication based on operation\n        if (operation === 'listUsers') {\n          // Simple API key in header\n          requestOptions.url = `${credentials.baseUrl}/users`;\n          requestOptions.headers = {\n            'X-API-Key': credentials.apiKey,\n          };\n\n        } else if (operation === 'createUser') {\n          // Signed request with secret\n          const timestamp = Date.now().toString();\n          const signature = this.createSignature(\n            credentials.secretKey,\n            timestamp,\n            'POST',\n            '/users'\n          );\n\n          requestOptions.method = 'POST';\n          requestOptions.url = `${credentials.baseUrl}/users`;\n          requestOptions.headers = {\n            'X-API-Key': credentials.apiKey,\n            'X-Timestamp': timestamp,\n            'X-Signature': signature,\n          };\n          requestOptions.body = {\n            name: this.getNodeParameter('userName', i),\n            email: this.getNodeParameter('userEmail', i),\n          };\n\n        } else if (operation === 'regionalQuery') {\n          // Region-specific endpoint\n          const region = credentials.region || 'us-east-1';\n          requestOptions.url = `https://${region}.${credentials.baseUrl}/query`;\n          requestOptions.headers = {\n            'Authorization': `Bearer ${credentials.apiKey}`,\n            'X-Region': region,\n          };\n        }\n\n        const response = await this.helpers.request(requestOptions);\n\n        returnData.push({\n          json: {\n            operation,\n            result: response,\n            credentials_used: {\n              baseUrl: credentials.baseUrl,\n              region: credentials.region,\n              // Never log sensitive data!\n              apiKey: '***',\n              secretKey: '***',\n            },\n          },\n        });\n\n      } catch (error) {\n        throw new NodeApiError(this.getNode(), error, {\n          message: `Failed to execute ${operation}`,\n          description: error.message,\n        });\n      }\n    }\n\n    return [returnData];\n  }\n\n  private createSignature(\n    secretKey: string,\n    timestamp: string,\n    method: string,\n    path: string\n  ): string {\n    // Example signature creation (adjust for your API)\n    const crypto = require('crypto');\n    const message = `${method}${path}${timestamp}`;\n    return crypto.createHmac('sha256', secretKey).update(message).digest('hex');\n  }\n}\n</code></pre></p> <p>Credential Validation: <pre><code>export class ValidatedApiNode implements INodeType {\n  // ... node description ...\n\n  async execute(this: IExecuteFunctions): Promise&lt;INodeExecutionData[][]&gt; {\n    const items = this.getInputData();\n    const returnData: INodeExecutionData[] = [];\n\n    // Get and validate credentials\n    const credentials = await this.getCredentials('myApi');\n\n    // Validate required fields\n    if (!credentials.apiKey) {\n      throw new NodeApiError(this.getNode(), {\n        message: 'API Key is required',\n        description: 'Please provide a valid API key in the credentials',\n      });\n    }\n\n    if (!credentials.baseUrl) {\n      throw new NodeApiError(this.getNode(), {\n        message: 'Base URL is required',\n        description: 'Please provide the API base URL in the credentials',\n      });\n    }\n\n    // Validate URL format\n    try {\n      new URL(credentials.baseUrl as string);\n    } catch {\n      throw new NodeApiError(this.getNode(), {\n        message: 'Invalid Base URL',\n        description: 'The provided base URL is not a valid URL format',\n      });\n    }\n\n    for (let i = 0; i &lt; items.length; i++) {\n      try {\n        const response = await this.helpers.request({\n          method: 'GET',\n          url: `${credentials.baseUrl}/data`,\n          headers: {\n            'Authorization': `Bearer ${credentials.apiKey}`,\n          },\n          json: true,\n        });\n\n        returnData.push({ json: response });\n\n      } catch (error) {\n        if (error.statusCode === 401) {\n          throw new NodeApiError(this.getNode(), {\n            message: 'Authentication failed',\n            description: 'The provided API key is invalid or expired',\n          });\n        }\n\n        throw new NodeApiError(this.getNode(), error);\n      }\n    }\n\n    return [returnData];\n  }\n}\n</code></pre></p> <p>These examples show: - Simple token injection: Manually adding tokens to URLs or headers - Complex processing: Different auth methods based on operation - Credential validation: Checking required fields and formats - Error handling: Proper error messages for auth failures</p> <p>Use manual injection when you need fine-grained control over how credentials are used in requests.</p>"},{"location":"credential-patterns/OAuth2/","title":"OAuth2 Authentication","text":"<p>OAuth2 is a secure and standardized way to authorize access to APIs on behalf of a user or service account.</p>"},{"location":"credential-patterns/OAuth2/#credential-definition","title":"Credential Definition","text":"<pre><code>export class OAuth2Api implements ICredentialType {\n  name = \"oAuth2Api\"\n  displayName = \"OAuth2 API\"\n  extends = [\"oAuth2\"]\n  properties = [\n    {\n      displayName: \"Client ID\",\n      name: \"clientId\",\n      type: \"string\",\n      default: \"\",\n    },\n    {\n      displayName: \"Client Secret\",\n      name: \"clientSecret\",\n      type: \"string\",\n      typeOptions: { password: true },\n      default: \"\",\n    },\n    {\n      displayName: \"Token URL\",\n      name: \"tokenUrl\",\n      type: \"string\",\n      default: \"\",\n    },\n    {\n      displayName: \"Auth URL\",\n      name: \"authUrl\",\n      type: \"string\",\n      default: \"\",\n    },\n  ]\n}\n</code></pre>"},{"location":"credential-patterns/OAuth2/#use-cases","title":"Use Cases","text":"<ul> <li>APIs that require user consent (e.g. Google, Slack)</li> <li>Secure access with refresh tokens</li> </ul>"},{"location":"credential-patterns/OAuth2/#tips","title":"Tips","text":"<ul> <li>Use <code>extends = [\"oAuth2\"]</code> to inherit built-in behavior</li> <li>Use scopes to limit access</li> <li>Use <code>authenticate()</code> for service account flows</li> </ul>"},{"location":"credential-patterns/OAuth2/#oauth2-with-scopes-and-token-refresh","title":"OAuth2 with Scopes and Token Refresh","text":"<p>Here's a complete OAuth2 credential configuration with scopes and automatic token refresh:</p> <pre><code>import {\n  ICredentialType,\n  INodeProperties,\n  ICredentialTestRequest,\n  ICredentialDataDecryptedObject,\n} from 'n8n-workflow';\n\nexport class GoogleSheetsOAuth2Api implements ICredentialType {\n  name = 'googleSheetsOAuth2Api';\n  extends = ['googleOAuth2Api'];\n  displayName = 'Google Sheets OAuth2 API';\n  documentationUrl = 'https://developers.google.com/sheets/api/guides/authorizing';\n  properties: INodeProperties[] = [\n    {\n      displayName: 'Scope',\n      name: 'scope',\n      type: 'hidden',\n      default: 'https://www.googleapis.com/auth/spreadsheets',\n    },\n  ];\n\n  test: ICredentialTestRequest = {\n    request: {\n      baseURL: 'https://sheets.googleapis.com',\n      url: '/v4/spreadsheets',\n      method: 'GET',\n    },\n  };\n}\n</code></pre> <p>Full OAuth2 Configuration with Custom URLs: <pre><code>export class CustomOAuth2Api implements ICredentialType {\n  name = 'customOAuth2Api';\n  displayName = 'Custom OAuth2 API';\n  documentationUrl = 'https://docs.example.com/oauth';\n  properties: INodeProperties[] = [\n    {\n      displayName: 'Grant Type',\n      name: 'grantType',\n      type: 'hidden',\n      default: 'authorizationCode',\n    },\n    {\n      displayName: 'Authorization URL',\n      name: 'authUrl',\n      type: 'string',\n      default: 'https://api.example.com/oauth/authorize',\n      required: true,\n    },\n    {\n      displayName: 'Access Token URL',\n      name: 'accessTokenUrl',\n      type: 'string',\n      default: 'https://api.example.com/oauth/token',\n      required: true,\n    },\n    {\n      displayName: 'Client ID',\n      name: 'clientId',\n      type: 'string',\n      default: '',\n      required: true,\n    },\n    {\n      displayName: 'Client Secret',\n      name: 'clientSecret',\n      type: 'string',\n      typeOptions: {\n        password: true,\n      },\n      default: '',\n      required: true,\n    },\n    {\n      displayName: 'Scope',\n      name: 'scope',\n      type: 'string',\n      default: 'read write',\n      description: 'Space-separated list of scopes',\n    },\n    {\n      displayName: 'Auth URI Query Parameters',\n      name: 'authQueryParameters',\n      type: 'hidden',\n      default: 'response_type=code',\n    },\n    {\n      displayName: 'Authentication',\n      name: 'authentication',\n      type: 'hidden',\n      default: 'header',\n    },\n  ];\n\n  authenticate: IAuthenticateGeneric = {\n    type: 'oauth2',\n    properties: {\n      tokenType: 'Bearer',\n    },\n  };\n\n  test: ICredentialTestRequest = {\n    request: {\n      baseURL: 'https://api.example.com',\n      url: '/user/profile',\n      method: 'GET',\n    },\n  };\n}\n</code></pre></p> <p>Client Credentials Flow (Service Account): <pre><code>export class ServiceAccountOAuth2 implements ICredentialType {\n  name = 'serviceAccountOAuth2';\n  displayName = 'Service Account OAuth2';\n  documentationUrl = 'https://docs.example.com/service-auth';\n  properties: INodeProperties[] = [\n    {\n      displayName: 'Grant Type',\n      name: 'grantType',\n      type: 'hidden',\n      default: 'clientCredentials',\n    },\n    {\n      displayName: 'Access Token URL',\n      name: 'accessTokenUrl',\n      type: 'string',\n      default: 'https://api.example.com/oauth/token',\n      required: true,\n    },\n    {\n      displayName: 'Client ID',\n      name: 'clientId',\n      type: 'string',\n      default: '',\n      required: true,\n    },\n    {\n      displayName: 'Client Secret',\n      name: 'clientSecret',\n      type: 'string',\n      typeOptions: {\n        password: true,\n      },\n      default: '',\n      required: true,\n    },\n    {\n      displayName: 'Scope',\n      name: 'scope',\n      type: 'string',\n      default: 'api:read api:write',\n      description: 'Space-separated list of scopes for service access',\n    },\n  ];\n\n  authenticate: IAuthenticateGeneric = {\n    type: 'oauth2',\n    properties: {\n      tokenType: 'Bearer',\n      grantType: 'clientCredentials',\n    },\n  };\n\n  test: ICredentialTestRequest = {\n    request: {\n      baseURL: 'https://api.example.com',\n      url: '/health',\n      method: 'GET',\n    },\n  };\n}\n</code></pre></p> <p>These examples show different OAuth2 flows: - Authorization Code: For user consent flows (most common) - Client Credentials: For service-to-service authentication - Custom URLs: For APIs with non-standard OAuth endpoints</p> <p>The <code>test</code> property automatically validates credentials when users save them in the n8n UI.</p>"},{"location":"credential-patterns/ServiceAccount/","title":"Service Account Authentication","text":"<p>Service accounts are used for server-to-server authentication, often with JWT or OAuth2 flows.</p>"},{"location":"credential-patterns/ServiceAccount/#credential-definition","title":"Credential Definition","text":"<pre><code>export class GoogleServiceAccount implements ICredentialType {\n  name = \"googleServiceAccount\"\n  displayName = \"Google Service Account\"\n  properties = [\n    {\n      displayName: \"Email\",\n      name: \"email\",\n      type: \"string\",\n      default: \"\",\n    },\n    {\n      displayName: \"Private Key\",\n      name: \"privateKey\",\n      type: \"string\",\n      typeOptions: { password: true },\n      default: \"\",\n    },\n  ]\n\n  async authenticate(credentials, requestOptions) {\n    const jwt = signJwt(credentials.email, credentials.privateKey)\n    const token = await exchangeJwtForToken(jwt)\n    requestOptions.headers = {\n      ...requestOptions.headers,\n      Authorization: `Bearer ${token}`,\n    }\n    return requestOptions\n  }\n}\n</code></pre>"},{"location":"credential-patterns/ServiceAccount/#use-cases","title":"Use Cases","text":"<ul> <li>Google Cloud APIs</li> <li>Internal APIs with JWT-based auth</li> </ul>"},{"location":"credential-patterns/ServiceAccount/#tips","title":"Tips","text":"<ul> <li>Normalize newlines in private key (<code>.replace(/\\\\n/g, '\\n')</code>)</li> <li>Use <code>authenticate()</code> to inject token dynamically</li> </ul>"},{"location":"credential-patterns/ServiceAccount/#service-account-with-jwt","title":"Service Account with JWT","text":"<p>Here's a complete service account credential that generates JWTs for authentication:</p> <pre><code>import {\n  ICredentialType,\n  INodeProperties,\n  ICredentialTestRequest,\n  ICredentialDataDecryptedObject,\n  IHttpRequestOptions,\n} from 'n8n-workflow';\nimport { sign } from 'jsonwebtoken';\n\nexport class JwtServiceAccount implements ICredentialType {\n  name = 'jwtServiceAccount';\n  displayName = 'JWT Service Account';\n  documentationUrl = 'https://docs.example.com/service-account';\n  properties: INodeProperties[] = [\n    {\n      displayName: 'Service Account Email',\n      name: 'email',\n      type: 'string',\n      default: '',\n      required: true,\n      placeholder: 'service-account@project.iam.gserviceaccount.com',\n      description: 'The email address of the service account',\n    },\n    {\n      displayName: 'Private Key',\n      name: 'privateKey',\n      type: 'string',\n      typeOptions: {\n        password: true,\n        rows: 5,\n      },\n      default: '',\n      required: true,\n      placeholder: '-----BEGIN PRIVATE KEY-----\\n...\\n-----END PRIVATE KEY-----',\n      description: 'The private key for the service account (PEM format)',\n    },\n    {\n      displayName: 'Token URL',\n      name: 'tokenUrl',\n      type: 'string',\n      default: 'https://oauth2.googleapis.com/token',\n      required: true,\n      description: 'The URL to exchange JWT for access token',\n    },\n    {\n      displayName: 'Scope',\n      name: 'scope',\n      type: 'string',\n      default: 'https://www.googleapis.com/auth/cloud-platform',\n      description: 'Space-separated list of scopes',\n    },\n  ];\n\n  async authenticate(\n    credentials: ICredentialDataDecryptedObject,\n    requestOptions: IHttpRequestOptions,\n  ): Promise&lt;IHttpRequestOptions&gt; {\n    const { email, privateKey, tokenUrl, scope } = credentials;\n\n    // Normalize private key (handle escaped newlines)\n    const normalizedPrivateKey = (privateKey as string).replace(/\\\\n/g, '\\n');\n\n    // Create JWT payload\n    const now = Math.floor(Date.now() / 1000);\n    const payload = {\n      iss: email as string,\n      sub: email as string,\n      aud: tokenUrl as string,\n      iat: now,\n      exp: now + 3600, // 1 hour\n      scope: scope as string,\n    };\n\n    try {\n      // Sign JWT\n      const jwt = sign(payload, normalizedPrivateKey, {\n        algorithm: 'RS256',\n        keyid: 'key-id', // Optional: add key ID if required\n      });\n\n      // Exchange JWT for access token\n      const tokenResponse = await this.helpers.request({\n        method: 'POST',\n        url: tokenUrl as string,\n        form: {\n          grant_type: 'urn:ietf:params:oauth:grant-type:jwt-bearer',\n          assertion: jwt,\n        },\n        json: true,\n      });\n\n      // Add access token to request headers\n      requestOptions.headers = {\n        ...requestOptions.headers,\n        Authorization: `Bearer ${tokenResponse.access_token}`,\n      };\n\n      return requestOptions;\n    } catch (error) {\n      throw new Error(`JWT authentication failed: ${error.message}`);\n    }\n  }\n\n  test: ICredentialTestRequest = {\n    request: {\n      baseURL: 'https://www.googleapis.com',\n      url: '/oauth2/v1/tokeninfo',\n      method: 'GET',\n    },\n  };\n}\n</code></pre> <p>Google Service Account (Simplified): <pre><code>export class GoogleServiceAccountSimple implements ICredentialType {\n  name = 'googleServiceAccountSimple';\n  displayName = 'Google Service Account (JSON)';\n  documentationUrl = 'https://cloud.google.com/iam/docs/service-accounts';\n  properties: INodeProperties[] = [\n    {\n      displayName: 'Service Account JSON',\n      name: 'serviceAccountJson',\n      type: 'json',\n      typeOptions: {\n        rows: 10,\n      },\n      default: '',\n      required: true,\n      description: 'The entire JSON key file downloaded from Google Cloud Console',\n    },\n    {\n      displayName: 'Scope',\n      name: 'scope',\n      type: 'options',\n      options: [\n        {\n          name: 'Cloud Platform (Full Access)',\n          value: 'https://www.googleapis.com/auth/cloud-platform',\n        },\n        {\n          name: 'Sheets (Read/Write)',\n          value: 'https://www.googleapis.com/auth/spreadsheets',\n        },\n        {\n          name: 'Drive (Read/Write)',\n          value: 'https://www.googleapis.com/auth/drive',\n        },\n      ],\n      default: 'https://www.googleapis.com/auth/cloud-platform',\n      description: 'The scope of access for the service account',\n    },\n  ];\n\n  async authenticate(\n    credentials: ICredentialDataDecryptedObject,\n    requestOptions: IHttpRequestOptions,\n  ): Promise&lt;IHttpRequestOptions&gt; {\n    const serviceAccountJson = JSON.parse(credentials.serviceAccountJson as string);\n    const scope = credentials.scope as string;\n\n    const { client_email, private_key, token_uri } = serviceAccountJson;\n\n    // Create JWT payload\n    const now = Math.floor(Date.now() / 1000);\n    const payload = {\n      iss: client_email,\n      sub: client_email,\n      aud: token_uri,\n      iat: now,\n      exp: now + 3600,\n      scope,\n    };\n\n    try {\n      // Sign JWT\n      const jwt = sign(payload, private_key, { algorithm: 'RS256' });\n\n      // Exchange JWT for access token\n      const tokenResponse = await this.helpers.request({\n        method: 'POST',\n        url: token_uri,\n        form: {\n          grant_type: 'urn:ietf:params:oauth:grant-type:jwt-bearer',\n          assertion: jwt,\n        },\n        json: true,\n      });\n\n      // Add access token to request headers\n      requestOptions.headers = {\n        ...requestOptions.headers,\n        Authorization: `Bearer ${tokenResponse.access_token}`,\n      };\n\n      return requestOptions;\n    } catch (error) {\n      throw new Error(`Google Service Account authentication failed: ${error.message}`);\n    }\n  }\n\n  test: ICredentialTestRequest = {\n    request: {\n      baseURL: 'https://www.googleapis.com',\n      url: '/oauth2/v1/tokeninfo',\n      method: 'GET',\n    },\n  };\n}\n</code></pre></p> <p>AWS Service Account (IAM Role): <pre><code>export class AwsServiceAccount implements ICredentialType {\n  name = 'awsServiceAccount';\n  displayName = 'AWS Service Account';\n  documentationUrl = 'https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_access-keys.html';\n  properties: INodeProperties[] = [\n    {\n      displayName: 'Access Key ID',\n      name: 'accessKeyId',\n      type: 'string',\n      default: '',\n      required: true,\n      description: 'AWS Access Key ID',\n    },\n    {\n      displayName: 'Secret Access Key',\n      name: 'secretAccessKey',\n      type: 'string',\n      typeOptions: {\n        password: true,\n      },\n      default: '',\n      required: true,\n      description: 'AWS Secret Access Key',\n    },\n    {\n      displayName: 'Region',\n      name: 'region',\n      type: 'string',\n      default: 'us-east-1',\n      required: true,\n      description: 'AWS Region',\n    },\n    {\n      displayName: 'Session Token',\n      name: 'sessionToken',\n      type: 'string',\n      typeOptions: {\n        password: true,\n      },\n      default: '',\n      description: 'AWS Session Token (for temporary credentials)',\n    },\n  ];\n\n  authenticate: IAuthenticateGeneric = {\n    type: 'generic',\n    properties: {\n      headers: {\n        'Authorization': '={{$credentials.accessKeyId}}:{{$credentials.secretAccessKey}}',\n        'X-Amz-Security-Token': '={{$credentials.sessionToken}}',\n      },\n    },\n  };\n\n  test: ICredentialTestRequest = {\n    request: {\n      baseURL: 'https://sts.amazonaws.com',\n      url: '/?Action=GetCallerIdentity&amp;Version=2011-06-15',\n      method: 'GET',\n    },\n  };\n}\n</code></pre></p> <p>These examples show different service account patterns: - JWT-based: Generate and sign JWTs for token exchange - JSON Key File: Use Google's service account JSON format - AWS IAM: Use access keys for AWS service authentication</p> <p>The <code>authenticate</code> method dynamically generates tokens, while the <code>test</code> property validates the credentials.</p>"},{"location":"patterns/DeclarativePattern/key-features/","title":"Key Features of the Declarative Pattern","text":"Feature Description <code>routing.request</code> Defines HTTP method, URL, headers, and query string <code>type: 'options'</code> Creates dropdowns for selecting operations or resources <code>type: 'collection'</code> Groups optional fields under \u201cAdditional Fields\u201d <code>displayOptions</code> Controls conditional visibility of fields <code>authenticate</code> Injects credentials (e.g. API key via query string) No <code>execute()</code> All behavior is declarative\u2014no imperative logic <p>These features make declarative nodes easy to build, maintain, and understand\u2014especially for simple use cases.</p>"},{"location":"patterns/DeclarativePattern/key-features/#using-default-and-required","title":"Using <code>default</code> and <code>required</code>","text":"<p>Declarative nodes make it easy to enforce required fields and provide sensible defaults:</p> <pre><code>{\n  displayName: 'Operation',\n  name: 'operation',\n  type: 'options',\n  required: true,\n  default: 'get',\n  options: [\n    {\n      name: 'Get User',\n      value: 'get',\n    },\n    {\n      name: 'List Users',\n      value: 'list',\n    },\n  ],\n},\n{\n  displayName: 'Limit',\n  name: 'limit',\n  type: 'number',\n  default: 10,\n  description: 'Maximum number of results to return',\n  displayOptions: {\n    show: {\n      operation: ['list'],\n    },\n  },\n}\n</code></pre> <p>The <code>required: true</code> field ensures users must select an operation, while <code>default: 'get'</code> provides a sensible starting point. The limit field has a default of 10 and only appears for list operations.</p>"},{"location":"patterns/DeclarativePattern/limitations/","title":"Limitations of the Declarative Pattern","text":"<p>While the declarative pattern is great for simple use cases, it has several limitations:</p> <ul> <li>\u274c No custom logic or transformation</li> <li>\u274c Cannot handle pagination or retries</li> <li>\u274c No support for binary data</li> <li>\u274c Limited error handling</li> <li>\u274c Cannot dynamically modify requests or responses</li> <li>\u274c Harder to debug when things go wrong</li> <li>\u274c Not suitable for complex authentication flows</li> </ul> <p>If your node needs any of the above, consider using the programmatic or modular declarative pattern instead.</p> <p>[TODO: inline code]</p>"},{"location":"patterns/DeclarativePattern/overview/","title":"Declarative Pattern Overview","text":"<p>The declarative pattern in n8n allows you to define node behavior entirely through metadata\u2014no <code>execute()</code> method required. It\u2019s ideal for simple REST APIs and CRUD-style operations.</p> <p>This pattern is best suited for: - Simple HTTP requests - Static routing - Minimal transformation logic</p>"},{"location":"patterns/DeclarativePattern/overview/#complete-example","title":"Complete Example","text":"<p>Here\u2019s a minimal but complete declarative node using <code>request</code> and <code>routing</code>:</p> <pre><code>import { INodeType, INodeTypeDescription } from 'n8n-workflow'\n\nexport class DeclarativeExample implements INodeType {\n  description: INodeTypeDescription = {\n    displayName: 'Declarative Example',\n    name: 'declarativeExample',\n    group: ['transform'],\n    version: 1,\n    description: 'A simple declarative node',\n    defaults: {\n      name: 'Declarative Example',\n    },\n    inputs: ['main'],\n    outputs: ['main'],\n    requestDefaults: {\n      baseURL: 'https://jsonplaceholder.typicode.com',\n    },\n    properties: [\n      {\n        displayName: 'Resource',\n        name: 'resource',\n        type: 'options',\n        options: [\n          {\n            name: 'User',\n            value: 'user',\n          },\n        ],\n        default: 'user',\n      },\n      {\n        displayName: 'Operation',\n        name: 'operation',\n        type: 'options',\n        options: [\n          {\n            name: 'Get',\n            value: 'get',\n          },\n        ],\n        default: 'get',\n      },\n      {\n        displayName: 'User ID',\n        name: 'userId',\n        type: 'string',\n        default: '',\n        displayOptions: {\n          show: {\n            operation: ['get'],\n          },\n        },\n      },\n    ],\n    routing: {\n      request: {\n        method: 'GET',\n        url: '=/users/{{$parameter.userId}}',\n      },\n    },\n  }\n}\n</code></pre> <p>This node performs a GET request to <code>/users/{userId}</code> using declarative routing.</p> <p>One of the most common features in declarative nodes is conditional field visibility using <code>displayOptions</code>:</p> <pre><code>{\n  displayName: 'User ID',\n  name: 'userId',\n  type: 'string',\n  displayOptions: {\n    show: {\n      operation: ['get', 'update', 'delete'],\n    },\n  },\n  default: '',\n  description: 'The ID of the user to operate on',\n}\n</code></pre> <p>This field will only appear when the <code>operation</code> parameter is set to 'get', 'update', or 'delete'. You can also use <code>hide</code> to do the opposite:</p> <pre><code>displayOptions: {\n  hide: {\n    operation: ['list'],\n  },\n}\n</code></pre>"},{"location":"patterns/DeclarativePattern/summary/","title":"Declarative Pattern Summary","text":"Strengths Limitations Easy to build and maintain No logic layer Great for onboarding Limited control Clean UI integration Harder to debug Fast to prototype Not suitable for complex APIs <p>The declarative pattern is a powerful tool for simple use cases, and a great way to get started with custom n8n nodes.</p>"},{"location":"patterns/DeclarativePattern/summary/#basic-execute-returning-json-array","title":"Basic <code>execute</code> Returning JSON Array","text":"<p>Sometimes you need a simple <code>execute</code> method for testing or returning hardcoded data:</p> <pre><code>async execute(this: IExecuteFunctions): Promise&lt;INodeExecutionData[][]&gt; {\n  const items = this.getInputData();\n  const returnData: INodeExecutionData[] = [];\n\n  for (let i = 0; i &lt; items.length; i++) {\n    const operation = this.getNodeParameter('operation', i) as string;\n\n    if (operation === 'test') {\n      // Return some test data\n      returnData.push({\n        json: {\n          id: 1,\n          name: 'Test User',\n          email: 'test@example.com',\n          status: 'active',\n        },\n      });\n    }\n  }\n\n  return [returnData];\n}\n</code></pre> <p>This simple execute method checks the operation parameter and returns hardcoded test data. It's useful for prototyping or when you need minimal custom logic alongside declarative routing.</p>"},{"location":"patterns/DeclarativePattern/when-to-use/","title":"When to Use the Declarative Pattern","text":"<p>The declarative pattern is best suited for:</p> <ul> <li>Simple REST APIs with predictable endpoints</li> <li>CRUD operations (Create, Read, Update, Delete)</li> <li>Nodes that don\u2019t require custom logic or transformation</li> <li>APIs that use static query parameters or headers</li> <li>Prototyping or teaching new node authors</li> </ul> <p>Avoid using this pattern when: - You need to transform data dynamically - You need to handle pagination, retries, or conditional logic - You need to work with binary data - You need to interact with complex authentication flows</p>"},{"location":"patterns/DeclarativePattern/when-to-use/#loadoptionsmethod-with-static-options","title":"<code>loadOptionsMethod</code> with Static Options","text":"<p>Declarative nodes can provide dropdown options using <code>loadOptionsMethod</code>. Here's a simple example that returns static options:</p> <pre><code>// In the node description\n{\n  displayName: 'Priority',\n  name: 'priority',\n  type: 'options',\n  typeOptions: {\n    loadOptionsMethod: 'getPriorities',\n  },\n  default: 'medium',\n  description: 'Priority level for the task',\n}\n\n// In the methods section\nmethods = {\n  loadOptions: {\n    async getPriorities(): Promise&lt;INodePropertyOptions[]&gt; {\n      return [\n        {\n          name: 'Low',\n          value: 'low',\n        },\n        {\n          name: 'Medium',\n          value: 'medium',\n        },\n        {\n          name: 'High',\n          value: 'high',\n        },\n        {\n          name: 'Critical',\n          value: 'critical',\n        },\n      ];\n    },\n  },\n};\n</code></pre> <p>This creates a dropdown with predefined priority levels. The method can also make API calls to fetch dynamic options.</p>"},{"location":"patterns/ModularDeclarativePattern/key-features/","title":"Key Features of the Modular Declarative Pattern","text":"Feature Description <code>loadOptionsMethod</code> Dynamically load dropdown options from external files <code>routing</code> Declarative HTTP request configuration per operation <code>hooks</code> Add pre/post-processing logic without <code>execute()</code> <code>modular structure</code> Split operations/resources into separate files <code>shared utils</code> Reuse logic across operations (e.g. request builders, helpers) <p>This pattern is great for large, complex APIs that still benefit from declarative structure.</p>"},{"location":"patterns/ModularDeclarativePattern/key-features/#methodsloadoptions-in-a-separate-file","title":"<code>methods.loadOptions</code> in a Separate File","text":"<p>Move load options logic into a dedicated <code>methods.ts</code> file for better organization:</p> <p>MyNode.node.ts: <pre><code>import { INodeType, INodeTypeDescription } from 'n8n-workflow';\nimport { description } from './description';\nimport { methods } from './methods';\n\nexport class MyNode implements INodeType {\n  description: INodeTypeDescription = description;\n  methods = methods;\n\n  async execute(this: IExecuteFunctions): Promise&lt;INodeExecutionData[][]&gt; {\n    // Implementation here\n    return [[]];\n  }\n}\n</code></pre></p> <p>methods.ts: <pre><code>import { ILoadOptionsFunctions, INodePropertyOptions } from 'n8n-workflow';\n\nexport const methods = {\n  loadOptions: {\n    async getProjects(this: ILoadOptionsFunctions): Promise&lt;INodePropertyOptions[]&gt; {\n      const credentials = await this.getCredentials('myApiCredentials');\n\n      const response = await this.helpers.request({\n        method: 'GET',\n        url: 'https://api.example.com/projects',\n        headers: {\n          'Authorization': `Bearer ${credentials.apiKey}`,\n        },\n        json: true,\n      });\n\n      return response.projects.map((project: any) =&gt; ({\n        name: project.name,\n        value: project.id,\n      }));\n    },\n\n    async getUsers(this: ILoadOptionsFunctions): Promise&lt;INodePropertyOptions[]&gt; {\n      const credentials = await this.getCredentials('myApiCredentials');\n\n      const response = await this.helpers.request({\n        method: 'GET',\n        url: 'https://api.example.com/users',\n        headers: {\n          'Authorization': `Bearer ${credentials.apiKey}`,\n        },\n        json: true,\n      });\n\n      return response.users.map((user: any) =&gt; ({\n        name: `${user.firstName} ${user.lastName}`,\n        value: user.id,\n      }));\n    },\n  },\n};\n</code></pre></p> <p>This keeps your main node file clean while organizing all dynamic option loading in one place.</p>"},{"location":"patterns/ModularDeclarativePattern/limitations/","title":"Limitations of the Modular Declarative Pattern","text":"<p>While this pattern is powerful and scalable, it has a few trade-offs:</p> <ul> <li>\u274c More files and structure to manage</li> <li>\u274c Slightly more complex to onboard new contributors</li> <li>\u274c Requires understanding of <code>loadOptionsMethod</code>, <code>hooks</code>, and <code>routing</code></li> <li>\u274c Can be overkill for small or single-operation nodes</li> </ul> <p>Use this pattern when modularity and maintainability outweigh the added complexity.</p> <p>[TODO: inline code]</p>"},{"location":"patterns/ModularDeclarativePattern/overview/","title":"Modular Declarative Pattern Overview","text":"<p>The modular declarative pattern combines the simplicity of declarative routing with the flexibility of modular code organization. It\u2019s ideal for large nodes with many operations or resources.</p> <p>This pattern is best suited for: - APIs with many endpoints or resources - Nodes that benefit from code reuse and separation - Declarative nodes that need dynamic routing or metadata</p> <p>It uses <code>loadOptionsMethod</code>, <code>routing</code>, and <code>hooks</code> to dynamically build behavior from modular files.</p>"},{"location":"patterns/ModularDeclarativePattern/overview/#complete-example","title":"Complete Example","text":"<p>Here\u2019s a minimal but complete modular declarative node:</p> <p>ModularDeclarativeExample.node.ts <pre><code>import { INodeType, INodeTypeDescription } from 'n8n-workflow'\nimport { description } from './description'\n\nexport class ModularDeclarativeExample implements INodeType {\n  description: INodeTypeDescription = description\n}\n</code></pre></p> <p>description.ts <pre><code>import { INodeTypeDescription } from 'n8n-workflow'\n\nexport const description: INodeTypeDescription = {\n  displayName: 'Modular Declarative Example',\n  name: 'modularDeclarativeExample',\n  group: ['transform'],\n  version: 1,\n  description: 'A modular declarative node',\n  defaults: {\n    name: 'Modular Declarative Example',\n  },\n  inputs: ['main'],\n  outputs: ['main'],\n  requestDefaults: {\n    baseURL: 'https://jsonplaceholder.typicode.com',\n  },\n  properties: [\n    {\n      displayName: 'User ID',\n      name: 'userId',\n      type: 'string',\n      default: '',\n    },\n  ],\n  routing: {\n    request: {\n      method: 'GET',\n      url: '=/users/{{$parameter.userId}}',\n    },\n  },\n}\n</code></pre></p> <p>This node separates the description into its own file for better maintainability.</p> <p>Separate your node description into a dedicated file for better organization:</p> <p>MyNode.node.ts: <pre><code>import { INodeType, INodeTypeDescription } from 'n8n-workflow';\nimport { description } from './description';\n\nexport class MyNode implements INodeType {\n  description: INodeTypeDescription = description;\n\n  async execute(this: IExecuteFunctions): Promise&lt;INodeExecutionData[][]&gt; {\n    // Implementation here\n    return [[]];\n  }\n}\n</code></pre></p> <p>description.ts: <pre><code>import { INodeTypeDescription } from 'n8n-workflow';\n\nexport const description: INodeTypeDescription = {\n  displayName: 'My API',\n  name: 'myApi',\n  icon: 'file:myapi.svg',\n  group: ['transform'],\n  version: 1,\n  subtitle: '={{$parameter[\"operation\"] + \": \" + $parameter[\"resource\"]}}',\n  description: 'Interact with My API',\n  defaults: {\n    name: 'My API',\n  },\n  inputs: ['main'],\n  outputs: ['main'],\n  credentials: [\n    {\n      name: 'myApiCredentials',\n      required: true,\n    },\n  ],\n  properties: [\n    {\n      displayName: 'Resource',\n      name: 'resource',\n      type: 'options',\n      noDataExpression: true,\n      options: [\n        {\n          name: 'User',\n          value: 'user',\n        },\n        {\n          name: 'Project',\n          value: 'project',\n        },\n      ],\n      default: 'user',\n    },\n    // More properties...\n  ],\n};\n</code></pre></p> <p>This separation makes large node descriptions much more manageable and easier to maintain.</p>"},{"location":"patterns/ModularDeclarativePattern/summary/","title":"Modular Declarative Pattern Summary","text":"Strengths Limitations Scales well with many operations More files and structure to manage Encourages code reuse Slightly more complex to onboard Declarative + dynamic behavior Requires understanding of advanced features Clean separation of concerns Overkill for small nodes <p>This pattern is ideal for large, complex APIs that benefit from modularity and declarative structure.</p>"},{"location":"patterns/ModularDeclarativePattern/summary/#execute-using-helper-functions","title":"<code>execute</code> Using Helper Functions","text":"<p>Keep your <code>execute</code> method clean by importing utility functions:</p> <p>MyNode.node.ts: <pre><code>import { IExecuteFunctions, INodeExecutionData } from 'n8n-workflow';\nimport { description } from './description';\nimport { methods } from './methods';\nimport { handleUserOperations } from './utils/userOperations';\nimport { handleProjectOperations } from './utils/projectOperations';\nimport { validateInputs } from './utils/validation';\n\nexport class MyNode implements INodeType {\n  description: INodeTypeDescription = description;\n  methods = methods;\n\n  async execute(this: IExecuteFunctions): Promise&lt;INodeExecutionData[][]&gt; {\n    const items = this.getInputData();\n    const returnData: INodeExecutionData[] = [];\n\n    for (let i = 0; i &lt; items.length; i++) {\n      const resource = this.getNodeParameter('resource', i) as string;\n      const operation = this.getNodeParameter('operation', i) as string;\n\n      // Validate inputs using helper function\n      validateInputs(resource, operation);\n\n      let result;\n\n      if (resource === 'user') {\n        result = await handleUserOperations.call(this, operation, i);\n      } else if (resource === 'project') {\n        result = await handleProjectOperations.call(this, operation, i);\n      }\n\n      if (result) {\n        returnData.push({ json: result });\n      }\n    }\n\n    return [returnData];\n  }\n}\n</code></pre></p> <p>utils/userOperations.ts: <pre><code>import { IExecuteFunctions } from 'n8n-workflow';\nimport { makeApiRequest } from './apiHelpers';\n\nexport async function handleUserOperations(\n  this: IExecuteFunctions,\n  operation: string,\n  itemIndex: number,\n): Promise&lt;any&gt; {\n  switch (operation) {\n    case 'create':\n      const userData = {\n        name: this.getNodeParameter('name', itemIndex) as string,\n        email: this.getNodeParameter('email', itemIndex) as string,\n      };\n      return await makeApiRequest.call(this, 'POST', '/users', userData);\n\n    case 'get':\n      const userId = this.getNodeParameter('userId', itemIndex) as string;\n      return await makeApiRequest.call(this, 'GET', `/users/${userId}`);\n\n    default:\n      throw new Error(`Unknown user operation: ${operation}`);\n  }\n}\n</code></pre></p> <p>This modular approach keeps your main execute method readable while organizing complex logic into focused utility functions.</p>"},{"location":"patterns/ModularDeclarativePattern/when-to-use/","title":"When to Use the Modular Declarative Pattern","text":"<p>This pattern is ideal when you want the simplicity of declarative routing but need to scale across many operations or resources.</p> <p>Use this pattern when: - You have many endpoints or operations to organize - You want to split logic into separate files for maintainability - You want to reuse shared logic across operations - You want to dynamically load options or metadata - You want to use <code>hooks</code> or <code>loadOptionsMethod</code> to enhance declarative behavior</p> <p>Avoid this pattern if: - You only have one or two operations - You don\u2019t need dynamic behavior or modularity</p>"},{"location":"patterns/ModularDeclarativePattern/when-to-use/#modular-file-structure-example","title":"Modular File Structure Example","text":"<p>Here's how to organize a large API node with many operations:</p> <p>File Structure: <pre><code>MyApiNode/\n\u251c\u2500\u2500 MyApiNode.node.ts          # Main node class\n\u251c\u2500\u2500 description.ts             # Node description\n\u251c\u2500\u2500 methods.ts                 # Load options methods\n\u251c\u2500\u2500 operations/\n\u2502   \u251c\u2500\u2500 user/\n\u2502   \u2502   \u251c\u2500\u2500 create.ts         # User creation logic\n\u2502   \u2502   \u251c\u2500\u2500 update.ts         # User update logic\n\u2502   \u2502   \u2514\u2500\u2500 index.ts          # User operations export\n\u2502   \u251c\u2500\u2500 project/\n\u2502   \u2502   \u251c\u2500\u2500 create.ts         # Project creation logic\n\u2502   \u2502   \u251c\u2500\u2500 list.ts           # Project listing logic\n\u2502   \u2502   \u2514\u2500\u2500 index.ts          # Project operations export\n\u2502   \u2514\u2500\u2500 index.ts              # All operations export\n\u2514\u2500\u2500 utils/\n    \u251c\u2500\u2500 apiHelpers.ts         # Shared API utilities\n    \u2514\u2500\u2500 validation.ts         # Shared validation logic\n</code></pre></p> <p>operations/user/create.ts: <pre><code>import { INodeProperties } from 'n8n-workflow';\n\nexport const userCreateDescription: INodeProperties[] = [\n  {\n    displayName: 'Name',\n    name: 'name',\n    type: 'string',\n    required: true,\n    displayOptions: {\n      show: {\n        resource: ['user'],\n        operation: ['create'],\n      },\n    },\n    default: '',\n    description: 'Name of the user to create',\n  },\n  {\n    displayName: 'Email',\n    name: 'email',\n    type: 'string',\n    required: true,\n    displayOptions: {\n      show: {\n        resource: ['user'],\n        operation: ['create'],\n      },\n    },\n    default: '',\n    description: 'Email address of the user',\n  },\n];\n\nexport const userCreateRouting = {\n  request: {\n    method: 'POST' as const,\n    url: '/users',\n    body: {\n      name: '={{ $parameter.name }}',\n      email: '={{ $parameter.email }}',\n    },\n  },\n};\n</code></pre></p> <p>operations/index.ts: <pre><code>import { userCreateDescription, userCreateRouting } from './user/create';\nimport { userUpdateDescription, userUpdateRouting } from './user/update';\nimport { projectCreateDescription, projectCreateRouting } from './project/create';\nimport { projectListDescription, projectListRouting } from './project/list';\n\nexport const operationDescriptions = [\n  ...userCreateDescription,\n  ...userUpdateDescription,\n  ...projectCreateDescription,\n  ...projectListDescription,\n];\n\nexport const operationRouting = {\n  'user:create': userCreateRouting,\n  'user:update': userUpdateRouting,\n  'project:create': projectCreateRouting,\n  'project:list': projectListRouting,\n};\n</code></pre></p> <p>This modular approach makes it easy to maintain large nodes with dozens of operations while keeping each operation's logic isolated and reusable.</p>"},{"location":"patterns/OtherPatterns/BinaryNodes/","title":"Binary Nodes","text":"<p>Binary nodes are designed to handle file data such as images, PDFs, or any other binary content. They work with the <code>binary</code> property on each item.</p>"},{"location":"patterns/OtherPatterns/BinaryNodes/#examples","title":"Examples","text":"<ul> <li>Read Binary File</li> <li>Move Binary Data</li> <li>HTTP Request (file download)</li> </ul>"},{"location":"patterns/OtherPatterns/BinaryNodes/#key-concepts","title":"Key Concepts","text":"<ul> <li>Binary data is stored in <code>item.binary</code></li> <li>Each binary property has metadata and a file buffer</li> <li>Use <code>this.helpers.prepareBinaryData()</code> to attach binary content</li> <li>Use <code>this.helpers.getBinaryStream()</code> to read binary content</li> </ul>"},{"location":"patterns/OtherPatterns/BinaryNodes/#use-cases","title":"Use Cases","text":"<ul> <li>Download a file from a URL</li> <li>Convert a file format</li> <li>Upload a file to an external service</li> </ul>"},{"location":"patterns/OtherPatterns/BinaryNodes/#binary-node-that-reads-a-file","title":"Binary Node that Reads a File","text":"<p>Here's how to create a node that reads a file and returns it as binary data:</p> <pre><code>import {\n  IExecuteFunctions,\n  INodeExecutionData,\n  INodeType,\n  INodeTypeDescription,\n  NodeOperationError,\n} from 'n8n-workflow';\nimport { readFile } from 'fs/promises';\nimport { basename } from 'path';\n\nexport class ReadBinaryFile implements INodeType {\n  description: INodeTypeDescription = {\n    displayName: 'Read Binary File',\n    name: 'readBinaryFile',\n    icon: 'file:file.svg',\n    group: ['input'],\n    version: 1,\n    description: 'Reads a file from the filesystem and returns it as binary data',\n    defaults: {\n      name: 'Read Binary File',\n    },\n    inputs: ['main'],\n    outputs: ['main'],\n    properties: [\n      {\n        displayName: 'File Path',\n        name: 'filePath',\n        type: 'string',\n        default: '',\n        required: true,\n        description: 'Path to the file to read',\n        placeholder: '/path/to/file.pdf',\n      },\n      {\n        displayName: 'Property Name',\n        name: 'binaryPropertyName',\n        type: 'string',\n        default: 'data',\n        required: true,\n        description: 'Name of the binary property to store the file data',\n      },\n    ],\n  };\n\n  async execute(this: IExecuteFunctions): Promise&lt;INodeExecutionData[][]&gt; {\n    const items = this.getInputData();\n    const returnData: INodeExecutionData[] = [];\n\n    for (let i = 0; i &lt; items.length; i++) {\n      const filePath = this.getNodeParameter('filePath', i) as string;\n      const binaryPropertyName = this.getNodeParameter('binaryPropertyName', i) as string;\n\n      try {\n        // Read the file from filesystem\n        const fileBuffer = await readFile(filePath);\n        const fileName = basename(filePath);\n\n        // Prepare binary data\n        const binaryData = await this.helpers.prepareBinaryData(\n          fileBuffer,\n          fileName,\n        );\n\n        // Return the item with binary data attached\n        returnData.push({\n          json: {\n            fileName,\n            filePath,\n            fileSize: fileBuffer.length,\n          },\n          binary: {\n            [binaryPropertyName]: binaryData,\n          },\n        });\n      } catch (error) {\n        if (this.continueOnFail()) {\n          returnData.push({\n            json: {\n              error: `Failed to read file: ${error.message}`,\n              filePath,\n            },\n          });\n        } else {\n          throw new NodeOperationError(\n            this.getNode(),\n            `Failed to read file '${filePath}': ${error.message}`,\n            { itemIndex: i },\n          );\n        }\n      }\n    }\n\n    return [returnData];\n  }\n}\n</code></pre> <p>This node reads a file from the filesystem and attaches it as binary data, making it available for other nodes to process or download.</p>"},{"location":"patterns/OtherPatterns/Pagination/","title":"Pagination","text":"<p>Pagination is used when an API returns results in pages. Your node must loop through all pages to collect the full dataset.</p>"},{"location":"patterns/OtherPatterns/Pagination/#strategies","title":"Strategies","text":"<ul> <li>Offset-based (e.g. <code>?page=2</code>)</li> <li>Cursor-based (e.g. <code>?next=abc123</code>)</li> <li>Link header-based (e.g. <code>Link: &lt;url&gt;; rel=\"next\"</code>)</li> </ul>"},{"location":"patterns/OtherPatterns/Pagination/#key-concepts","title":"Key Concepts","text":"<ul> <li>Use a <code>while</code> loop in <code>execute()</code> to fetch all pages</li> <li>Append results to a single array</li> <li>Respect API rate limits and max page size</li> </ul>"},{"location":"patterns/OtherPatterns/Pagination/#use-cases","title":"Use Cases","text":"<ul> <li>Fetch all users from a paginated API</li> <li>Download all records from a CRM</li> <li>Sync large datasets from external services</li> </ul>"},{"location":"patterns/OtherPatterns/Pagination/#pagination-using-nextpage","title":"Pagination Using <code>nextPage</code>","text":"<p>Here's how to implement pagination that loops through all pages of an API:</p> <pre><code>import {\n  IExecuteFunctions,\n  INodeExecutionData,\n  INodeType,\n  INodeTypeDescription,\n  NodeApiError,\n} from 'n8n-workflow';\n\nexport class PaginatedApiNode implements INodeType {\n  description: INodeTypeDescription = {\n    displayName: 'Paginated API',\n    name: 'paginatedApi',\n    icon: 'file:api.svg',\n    group: ['input'],\n    version: 1,\n    description: 'Fetch all data from a paginated API',\n    defaults: {\n      name: 'Paginated API',\n    },\n    inputs: ['main'],\n    outputs: ['main'],\n    credentials: [\n      {\n        name: 'myApiCredentials',\n        required: true,\n      },\n    ],\n    properties: [\n      {\n        displayName: 'Resource',\n        name: 'resource',\n        type: 'options',\n        options: [\n          {\n            name: 'Users',\n            value: 'users',\n          },\n          {\n            name: 'Projects',\n            value: 'projects',\n          },\n        ],\n        default: 'users',\n      },\n      {\n        displayName: 'Max Results',\n        name: 'maxResults',\n        type: 'number',\n        default: 1000,\n        description: 'Maximum number of results to fetch (0 = no limit)',\n      },\n    ],\n  };\n\n  async execute(this: IExecuteFunctions): Promise&lt;INodeExecutionData[][]&gt; {\n    const items = this.getInputData();\n    const returnData: INodeExecutionData[] = [];\n\n    for (let i = 0; i &lt; items.length; i++) {\n      const resource = this.getNodeParameter('resource', i) as string;\n      const maxResults = this.getNodeParameter('maxResults', i) as number;\n      const credentials = await this.getCredentials('myApiCredentials');\n\n      let allResults: any[] = [];\n      let nextPage: string | null = null;\n      let pageCount = 0;\n      const maxPages = 100; // Safety limit\n\n      try {\n        do {\n          pageCount++;\n\n          // Build request URL with pagination\n          const url = new URL(`https://api.example.com/${resource}`);\n          url.searchParams.set('limit', '50'); // Page size\n\n          if (nextPage) {\n            url.searchParams.set('page', nextPage);\n          }\n\n          const response = await this.helpers.request({\n            method: 'GET',\n            url: url.toString(),\n            headers: {\n              'Authorization': `Bearer ${credentials.apiKey}`,\n            },\n            json: true,\n          });\n\n          // Add results from this page\n          if (response.data &amp;&amp; Array.isArray(response.data)) {\n            allResults = allResults.concat(response.data);\n          }\n\n          // Check for next page\n          nextPage = response.pagination?.nextPage || null;\n\n          // Safety checks\n          if (pageCount &gt;= maxPages) {\n            console.warn(`Reached maximum page limit (${maxPages})`);\n            break;\n          }\n\n          if (maxResults &gt; 0 &amp;&amp; allResults.length &gt;= maxResults) {\n            allResults = allResults.slice(0, maxResults);\n            break;\n          }\n\n          // Rate limiting - small delay between requests\n          if (nextPage) {\n            await new Promise(resolve =&gt; setTimeout(resolve, 100));\n          }\n\n        } while (nextPage);\n\n        // Return all collected results\n        returnData.push({\n          json: {\n            resource,\n            totalResults: allResults.length,\n            pagesFetched: pageCount,\n            data: allResults,\n          },\n        });\n\n      } catch (error) {\n        throw new NodeApiError(this.getNode(), error, {\n          message: `Failed to fetch paginated data from ${resource}`,\n          description: error.message,\n        });\n      }\n    }\n\n    return [returnData];\n  }\n}\n</code></pre> <p>This example demonstrates: - Looping through all pages until no <code>nextPage</code> is returned - Collecting results from all pages into a single array - Safety limits to prevent infinite loops - Rate limiting between requests - Respecting a maximum result count</p>"},{"location":"patterns/OtherPatterns/TriggerNodes/","title":"Trigger Nodes","text":"<p>Trigger nodes are special nodes that start a workflow when an external event occurs. They do not require input and are typically the first node in a workflow.</p>"},{"location":"patterns/OtherPatterns/TriggerNodes/#examples","title":"Examples","text":"<ul> <li>Webhook Trigger</li> <li>Schedule Trigger</li> <li>Polling-based Triggers (e.g. RSS, Email)</li> </ul>"},{"location":"patterns/OtherPatterns/TriggerNodes/#key-concepts","title":"Key Concepts","text":"<ul> <li>Must define <code>trigger</code> property in the node description</li> <li>Can use <code>webhookMethods</code>, <code>polling</code>, or <code>interval</code> strategies</li> <li>Must return data in the same format as regular nodes</li> </ul>"},{"location":"patterns/OtherPatterns/TriggerNodes/#use-cases","title":"Use Cases","text":"<ul> <li>Start a workflow when a form is submitted</li> <li>Run a workflow every hour</li> <li>React to a new email or webhook</li> </ul>"},{"location":"patterns/OtherPatterns/TriggerNodes/#trigger-node-with-polling","title":"Trigger Node with Polling","text":"<p>Here's how to create a polling trigger that checks for new data on a schedule:</p> <pre><code>import {\n  ITriggerFunctions,\n  INodeType,\n  INodeTypeDescription,\n  ITriggerResponse,\n  INodeExecutionData,\n} from 'n8n-workflow';\n\nexport class MyPollingTrigger implements INodeType {\n  description: INodeTypeDescription = {\n    displayName: 'My Polling Trigger',\n    name: 'myPollingTrigger',\n    icon: 'file:trigger.svg',\n    group: ['trigger'],\n    version: 1,\n    description: 'Polls an API for new data',\n    defaults: {\n      name: 'My Polling Trigger',\n    },\n    inputs: [],\n    outputs: ['main'],\n    credentials: [\n      {\n        name: 'myApiCredentials',\n        required: true,\n      },\n    ],\n    polling: true,\n    properties: [\n      {\n        displayName: 'Trigger On',\n        name: 'event',\n        type: 'options',\n        options: [\n          {\n            name: 'New User',\n            value: 'newUser',\n          },\n          {\n            name: 'Updated Project',\n            value: 'updatedProject',\n          },\n        ],\n        default: 'newUser',\n      },\n    ],\n  };\n\n  async poll(this: ITriggerFunctions): Promise&lt;INodeExecutionData[][] | null&gt; {\n    const event = this.getNodeParameter('event') as string;\n    const credentials = await this.getCredentials('myApiCredentials');\n\n    try {\n      const response = await this.helpers.request({\n        method: 'GET',\n        url: `https://api.example.com/${event === 'newUser' ? 'users' : 'projects'}`,\n        headers: {\n          'Authorization': `Bearer ${credentials.apiKey}`,\n        },\n        qs: {\n          since: this.getLastPollTime(),\n        },\n        json: true,\n      });\n\n      if (response.data &amp;&amp; response.data.length &gt; 0) {\n        return [response.data.map((item: any) =&gt; ({ json: item }))];\n      }\n\n      return null; // No new data\n    } catch (error) {\n      throw new Error(`Polling failed: ${error.message}`);\n    }\n  }\n}\n</code></pre> <p>This trigger polls the API every time the workflow is scheduled to run, checking for new data since the last poll time.</p>"},{"location":"patterns/ProgrammaticPattern/key-features/","title":"Key Features of the Programmatic Pattern","text":"Feature Description <code>execute()</code> Full control over logic, inputs, and outputs <code>getNodeParameter</code> Dynamically access user input <code>this.helpers</code> Access built-in utilities (e.g. HTTP requests, OAuth, etc.) <code>continueOnFail()</code> Gracefully handle errors per item Modular Dispatch Use a <code>router</code> to delegate to resource/operation handlers <p>These features make the programmatic pattern ideal for complex, dynamic, or high-control use cases.</p>"},{"location":"patterns/ProgrammaticPattern/key-features/#using-thishelpersrequest","title":"Using <code>this.helpers.request</code>","text":"<p>The <code>this.helpers.request</code> method is the standard way to make HTTP requests in n8n nodes:</p> <pre><code>async execute(this: IExecuteFunctions): Promise&lt;INodeExecutionData[][]&gt; {\n  const items = this.getInputData();\n  const returnData: INodeExecutionData[] = [];\n\n  for (let i = 0; i &lt; items.length; i++) {\n    const userId = this.getNodeParameter('userId', i) as string;\n\n    try {\n      const response = await this.helpers.request({\n        method: 'GET',\n        url: `https://api.example.com/users/${userId}`,\n        headers: {\n          'Authorization': 'Bearer YOUR_TOKEN',\n          'Content-Type': 'application/json',\n        },\n        json: true,\n      });\n\n      returnData.push({\n        json: response,\n      });\n    } catch (error) {\n      if (this.continueOnFail()) {\n        returnData.push({\n          json: { error: error.message },\n          error,\n        });\n      } else {\n        throw error;\n      }\n    }\n  }\n\n  return [returnData];\n}\n</code></pre> <p>This example shows how to make authenticated API requests with proper error handling using <code>continueOnFail()</code>.</p>"},{"location":"patterns/ProgrammaticPattern/limitations/","title":"Limitations of the Programmatic Pattern","text":"<p>While the programmatic pattern is powerful, it comes with trade-offs:</p> <ul> <li>\u274c More boilerplate and setup required</li> <li>\u274c Slightly steeper learning curve</li> <li>\u274c Requires more testing and debugging</li> <li>\u274c Harder to visually inspect behavior in the UI</li> <li>\u274c Can be overkill for simple use cases</li> </ul> <p>Use this pattern when you need the power\u2014but don\u2019t default to it if a declarative node will do the job.</p> <p>[TODO: inline code]</p>"},{"location":"patterns/ProgrammaticPattern/overview/","title":"Programmatic Pattern Overview","text":"<p>The programmatic pattern in n8n gives you full control over node behavior by implementing an <code>execute()</code> method. It\u2019s the go-to approach for complex APIs, dynamic logic, and advanced workflows.</p> <p>This pattern is best suited for: - APIs with dynamic or conditional behavior - Nodes that need to transform or validate data - Workflows that require pagination, retries, or binary handling</p>"},{"location":"patterns/ProgrammaticPattern/overview/#complete-example","title":"Complete Example","text":"<p>Here\u2019s a minimal but complete programmatic node:</p> <pre><code>import { INodeType, INodeTypeDescription, IExecuteFunctions, INodeExecutionData } from 'n8n-workflow'\n\nexport class ProgrammaticExample implements INodeType {\n  description: INodeTypeDescription = {\n    displayName: 'Programmatic Example',\n    name: 'programmaticExample',\n    group: ['transform'],\n    version: 1,\n    description: 'A simple programmatic node',\n    defaults: {\n      name: 'Programmatic Example',\n    },\n    inputs: ['main'],\n    outputs: ['main'],\n    properties: [\n      {\n        displayName: 'Operation',\n        name: 'operation',\n        type: 'options',\n        options: [\n          {\n            name: 'Greet',\n            value: 'greet',\n          },\n        ],\n        default: 'greet',\n      },\n      {\n        displayName: 'Name',\n        name: 'name',\n        type: 'string',\n        default: 'World',\n      },\n    ],\n  }\n\n  async execute(this: IExecuteFunctions): Promise&lt;INodeExecutionData[][]&gt; {\n    const items = this.getInputData()\n    const returnData: INodeExecutionData[] = []\n\n    for (let i = 0; i &lt; items.length; i++) {\n      const name = this.getNodeParameter('name', i) as string\n      returnData.push({ json: { message: `Hello, ${name}!` } })\n    }\n\n    return [returnData]\n  }\n}\n</code></pre> <p>This node uses the <code>execute()</code> method to return a greeting message.</p> <p>The heart of programmatic nodes is the <code>execute()</code> method with branching logic:</p> <pre><code>async execute(this: IExecuteFunctions): Promise&lt;INodeExecutionData[][]&gt; {\n  const items = this.getInputData();\n  const returnData: INodeExecutionData[] = [];\n\n  for (let i = 0; i &lt; items.length; i++) {\n    const operation = this.getNodeParameter('operation', i) as string;\n    const resource = this.getNodeParameter('resource', i) as string;\n\n    if (resource === 'user') {\n      if (operation === 'create') {\n        const name = this.getNodeParameter('name', i) as string;\n        const email = this.getNodeParameter('email', i) as string;\n\n        // Create user logic\n        const newUser = {\n          id: Math.floor(Math.random() * 1000),\n          name,\n          email,\n          created_at: new Date().toISOString(),\n        };\n\n        returnData.push({ json: newUser });\n      } else if (operation === 'get') {\n        const userId = this.getNodeParameter('userId', i) as string;\n\n        // Get user logic\n        const user = {\n          id: userId,\n          name: 'John Doe',\n          email: 'john@example.com',\n        };\n\n        returnData.push({ json: user });\n      }\n    }\n  }\n\n  return [returnData];\n}\n</code></pre> <p>This pattern allows you to handle different operations and resources with custom logic for each case.</p>"},{"location":"patterns/ProgrammaticPattern/summary/","title":"Programmatic Pattern Summary","text":"Strengths Limitations Full control over logic More code to maintain Supports complex workflows Requires deeper n8n knowledge Great for advanced integrations Not as beginner-friendly Modular and scalable Less declarative UI integration <p>The programmatic pattern is the most powerful and flexible way to build custom n8n nodes. It\u2019s the right choice when you need to go beyond what declarative routing can offer.</p>"},{"location":"patterns/ProgrammaticPattern/summary/#error-handling-with-nodeapierror","title":"Error Handling with <code>NodeApiError</code>","text":"<p>Proper error handling is crucial in programmatic nodes. Use <code>NodeApiError</code> for consistent error formatting:</p> <pre><code>import { NodeApiError } from 'n8n-workflow';\n\nasync execute(this: IExecuteFunctions): Promise&lt;INodeExecutionData[][]&gt; {\n  const items = this.getInputData();\n  const returnData: INodeExecutionData[] = [];\n\n  for (let i = 0; i &lt; items.length; i++) {\n    try {\n      const response = await this.helpers.request({\n        method: 'GET',\n        url: 'https://api.example.com/data',\n        json: true,\n      });\n\n      returnData.push({ json: response });\n    } catch (error) {\n      // Check if it's an HTTP error\n      if (error.response?.status) {\n        throw new NodeApiError(this.getNode(), error, {\n          message: `API request failed with status ${error.response.status}`,\n          description: error.response.data?.message || 'Unknown API error',\n          httpCode: error.response.status,\n        });\n      }\n\n      // Handle other errors\n      throw new NodeApiError(this.getNode(), error, {\n        message: 'Request failed',\n        description: error.message,\n      });\n    }\n  }\n\n  return [returnData];\n}\n</code></pre> <p>This provides users with clear, actionable error messages in the n8n UI.</p>"},{"location":"patterns/ProgrammaticPattern/when-to-use/","title":"When to Use the Programmatic Pattern","text":"<p>The programmatic pattern is ideal when your node needs to do more than just send a static HTTP request.</p> <p>Use this pattern when: - You need to transform or validate input data - You need to loop over items or handle pagination - You need to make multiple requests per item - You need to handle binary data - You need to implement conditional logic or branching - You need to support complex authentication flows - You want to use helper utilities like <code>this.helpers.request</code></p> <p>Avoid this pattern if your node can be fully described using declarative routing\u2014it\u2019s more powerful, but also more complex.</p>"},{"location":"patterns/ProgrammaticPattern/when-to-use/#complex-data-transformation-example","title":"Complex Data Transformation Example","text":"<p>Here's when you'd choose programmatic over declarative - when you need complex data processing:</p> <pre><code>async execute(this: IExecuteFunctions): Promise&lt;INodeExecutionData[][]&gt; {\n  const items = this.getInputData();\n  const returnData: INodeExecutionData[] = [];\n\n  for (let i = 0; i &lt; items.length; i++) {\n    const operation = this.getNodeParameter('operation', i) as string;\n    const inputData = items[i].json;\n\n    if (operation === 'processCustomers') {\n      // Complex validation and transformation\n      const customers = inputData.customers as any[];\n\n      if (!Array.isArray(customers)) {\n        throw new Error('Input must contain a customers array');\n      }\n\n      const processedCustomers = customers\n        .filter(customer =&gt; customer.email &amp;&amp; customer.status === 'active')\n        .map(customer =&gt; ({\n          id: customer.id,\n          fullName: `${customer.firstName} ${customer.lastName}`.trim(),\n          email: customer.email.toLowerCase(),\n          totalOrders: customer.orders?.length || 0,\n          lastOrderDate: customer.orders?.[0]?.date || null,\n          tier: customer.orders?.length &gt; 10 ? 'premium' : 'standard',\n        }))\n        .sort((a, b) =&gt; b.totalOrders - a.totalOrders);\n\n      // Make API calls for each processed customer\n      for (const customer of processedCustomers) {\n        try {\n          const enrichedData = await this.helpers.request({\n            method: 'GET',\n            url: `https://api.example.com/customers/${customer.id}/analytics`,\n            json: true,\n          });\n\n          customer.analytics = enrichedData;\n        } catch (error) {\n          customer.analytics = null;\n          console.warn(`Failed to enrich customer ${customer.id}:`, error.message);\n        }\n      }\n\n      returnData.push({ json: { processedCustomers } });\n    }\n  }\n\n  return [returnData];\n}\n</code></pre> <p>This type of complex data processing, validation, and multiple API calls per item would be impossible with declarative routing alone.</p>"},{"location":"public-api/","title":"Public Node API Reference","text":"<p>This section documents the complete public API available to n8n node developers. These interfaces and methods are stable, officially supported, and safe to use in custom nodes.</p>"},{"location":"public-api/#overview","title":"Overview","text":"<p>When developing custom n8n nodes, you have access to different execution contexts depending on the type of node and method you're implementing:</p> <pre><code>graph TD\n    A[Node Type] --&gt; B[Regular Node]\n    A --&gt; C[Trigger Node]\n    A --&gt; D[Polling Node]\n    A --&gt; E[Webhook Node]\n\n    B --&gt; F[IExecuteFunctions]\n    B --&gt; G[IExecuteSingleFunctions]\n    B --&gt; H[ILoadOptionsFunctions]\n\n    C --&gt; I[ITriggerFunctions]\n    D --&gt; J[IPollFunctions]\n    E --&gt; K[IWebhookFunctions]\n    E --&gt; L[IHookFunctions]\n\n    F --&gt; M[helpers]\n    G --&gt; M\n    H --&gt; M\n    I --&gt; M\n    J --&gt; M\n    K --&gt; M\n    L --&gt; M\n</code></pre>"},{"location":"public-api/#quick-navigation","title":"Quick Navigation","text":""},{"location":"public-api/#execution-contexts","title":"\ud83c\udfaf Execution Contexts","text":"<p>Different interfaces available depending on your node type: - IExecuteFunctions - Main execution context for regular nodes - IExecuteSingleFunctions - Single-item execution context - ILoadOptionsFunctions - Loading dynamic options - ITriggerFunctions - Trigger node execution - IPollFunctions - Polling node execution - IWebhookFunctions - Webhook handling - IHookFunctions - Webhook setup/teardown</p>"},{"location":"public-api/#helper-functions","title":"\ud83d\udee0\ufe0f Helper Functions","text":"<p>Utility functions available via the <code>helpers</code> object: - Binary Helpers - Working with binary data and files - HTTP Helpers - Making HTTP requests with authentication - Filesystem Helpers - File system operations - Deduplication Helpers - Preventing duplicate processing - Base Helpers - Core utility functions</p>"},{"location":"public-api/#parameter-access","title":"\ud83d\udcdd Parameter Access","text":"<p>Methods for accessing node parameters and evaluating expressions: - getNodeParameter - Access node configuration - evaluateExpression - Evaluate n8n expressions - getCurrentNodeParameter - Access current parameter values</p>"},{"location":"public-api/#workflow-execution","title":"\ud83d\udd04 Workflow &amp; Execution","text":"<p>Methods for workflow control and execution: - getWorkflow - Access workflow metadata - getWorkflowStaticData - Persistent workflow data - executeWorkflow - Execute sub-workflows - putExecutionToWait - Pause execution</p>"},{"location":"public-api/#advanced-apis","title":"\ud83d\ude80 Advanced APIs","text":"<p>Advanced functionality for specialized use cases: - startJob - Start background jobs - logAiEvent - Log AI-related events - sendMessageToUI - Send messages to the UI</p>"},{"location":"public-api/#reference","title":"\ud83d\udcda Reference","text":"<p>Type definitions and interface documentation: - Common Types - Frequently used type definitions - Full Interfaces - Complete interface definitions</p>"},{"location":"public-api/#api-stability","title":"API Stability","text":""},{"location":"public-api/#stable-supported","title":"\u2705 Stable &amp; Supported","text":"<p>All APIs documented in this section are: - Officially supported by the n8n team - Stable across minor version updates - Safe to use in production nodes - Backwards compatible within major versions</p>"},{"location":"public-api/#version-compatibility","title":"\u26a0\ufe0f Version Compatibility","text":"<ul> <li>APIs may be added in new versions</li> <li>Deprecated APIs will be marked clearly</li> <li>Breaking changes only occur in major versions</li> <li>Check the <code>@since</code> tags for minimum version requirements</li> </ul>"},{"location":"public-api/#internal-apis","title":"\ud83d\udd12 Internal APIs","text":"<p>Avoid using: - Methods not documented here - Methods prefixed with <code>_</code> or <code>__</code> - Methods marked as <code>@internal</code> - Direct access to internal properties</p>"},{"location":"public-api/#getting-started","title":"Getting Started","text":"<p>If you're new to n8n node development, start with:</p> <ol> <li>IExecuteFunctions - The main execution context</li> <li>getNodeParameter - Accessing user configuration</li> <li>HTTP Helpers - Making API calls</li> <li>Binary Helpers - Working with files</li> </ol>"},{"location":"public-api/#examples","title":"Examples","text":""},{"location":"public-api/#basic-node-execution","title":"Basic Node Execution","text":"<pre><code>import { IExecuteFunctions, INodeExecutionData } from 'n8n-workflow';\n\nexport async function execute(this: IExecuteFunctions): Promise&lt;INodeExecutionData[][]&gt; {\n  const items = this.getInputData();\n  const returnData: INodeExecutionData[] = [];\n\n  for (let i = 0; i &lt; items.length; i++) {\n    const name = this.getNodeParameter('name', i) as string;\n\n    returnData.push({\n      json: {\n        message: `Hello, ${name}!`,\n        timestamp: new Date().toISOString(),\n      },\n    });\n  }\n\n  return [returnData];\n}\n</code></pre>"},{"location":"public-api/#making-http-requests","title":"Making HTTP Requests","text":"<pre><code>const response = await this.helpers.httpRequest({\n  method: 'GET',\n  url: 'https://api.example.com/data',\n  headers: {\n    'Authorization': `Bearer ${token}`,\n  },\n});\n</code></pre>"},{"location":"public-api/#working-with-binary-data","title":"Working with Binary Data","text":"<pre><code>const binaryData = await this.helpers.prepareBinaryData(\n  buffer,\n  'filename.pdf',\n  'application/pdf'\n);\n\nreturn [{\n  json: { success: true },\n  binary: { data: binaryData },\n}];\n</code></pre>"},{"location":"public-api/#need-help","title":"Need Help?","text":"<ul> <li>Check the specific API documentation for detailed examples</li> <li>Look at the Real World Examples for complete node implementations</li> <li>Review the Patterns section for architectural guidance</li> <li>See Error Handling for robust error management</li> </ul>"},{"location":"public-api/advanced/logAiEvent/","title":"logAiEvent","text":"<p>The <code>logAiEvent</code> function allows nodes to log AI-related events during workflow execution. These logs are useful for observability, debugging, and analytics when working with AI agents, tools, or workflows.</p>"},{"location":"public-api/advanced/logAiEvent/#when-to-use","title":"When to Use","text":"<p>Use <code>logAiEvent</code> when your node: - Interacts with AI models or agents - Embeds or retrieves documents for vector search - Tracks AI tool usage or output - Needs to emit structured telemetry for AI operations - Implements custom AI logic or orchestration</p>"},{"location":"public-api/advanced/logAiEvent/#function-signature","title":"Function Signature","text":"<pre><code>logAiEvent(eventName: AiEvent, msg?: string): void\n</code></pre>"},{"location":"public-api/advanced/logAiEvent/#parameters","title":"Parameters","text":"<ul> <li>eventName: A string enum representing the type of AI event (see below)</li> <li>msg (optional): A human-readable message or context string</li> </ul>"},{"location":"public-api/advanced/logAiEvent/#event-types","title":"Event Types","text":"<p>The <code>eventName</code> must be one of the following predefined AI event types:</p> Event Name Description <code>ai-messages-retrieved-from-memory</code> Retrieved messages from memory context <code>ai-message-added-to-memory</code> Added a message to memory <code>ai-output-parsed</code> Parsed output from an LLM <code>ai-documents-retrieved</code> Retrieved documents for context <code>ai-document-embedded</code> Embedded a document into a vector store <code>ai-query-embedded</code> Embedded a query for vector search <code>ai-document-processed</code> Processed a document for AI use <code>ai-text-split</code> Split text into chunks <code>ai-tool-called</code> Called an AI tool <code>ai-vector-store-searched</code> Queried a vector store <code>ai-llm-generated-output</code> LLM generated a response <code>ai-llm-errored</code> LLM call failed <code>ai-vector-store-populated</code> Populated a vector store <code>ai-vector-store-updated</code> Updated a vector store"},{"location":"public-api/advanced/logAiEvent/#basic-usage","title":"Basic Usage","text":"<pre><code>import { IExecuteFunctions } from 'n8n-workflow'\n\nexport async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n\n  this.logAiEvent('ai-llm-generated-output', 'LLM returned a response for user query')\n\n  return [items]\n}\n</code></pre>"},{"location":"public-api/advanced/logAiEvent/#advanced-usage","title":"Advanced Usage","text":""},{"location":"public-api/advanced/logAiEvent/#logging-multiple-events","title":"Logging Multiple Events","text":"<pre><code>this.logAiEvent('ai-query-embedded', 'Embedding user query for semantic search')\nthis.logAiEvent('ai-vector-store-searched', 'Searching vector store for top 5 matches')\nthis.logAiEvent('ai-llm-generated-output', 'LLM generated summary from retrieved context')\n</code></pre>"},{"location":"public-api/advanced/logAiEvent/#logging-errors","title":"Logging Errors","text":"<pre><code>try {\n  const result = await callLLM()\n  this.logAiEvent('ai-llm-generated-output', 'LLM call succeeded')\n} catch (error) {\n  this.logAiEvent('ai-llm-errored', `LLM call failed: ${error.message}`)\n  throw error\n}\n</code></pre>"},{"location":"public-api/advanced/logAiEvent/#best-practices","title":"Best Practices","text":"<ol> <li>Use structured event names from the <code>AiEvent</code> enum</li> <li>Include context in the message to aid debugging</li> <li>Log before and after key AI operations</li> <li>Avoid logging sensitive data in messages</li> <li>Use consistent phrasing for easier filtering</li> </ol>"},{"location":"public-api/advanced/logAiEvent/#related-documentation","title":"Related Documentation","text":"<ul> <li>startJob - For launching background jobs</li> <li>sendMessageToUI - For communicating with the UI</li> <li>IExecuteFunctions - Main execution context</li> </ul>"},{"location":"public-api/advanced/sendMessageToUI/","title":"sendMessageToUI","text":"<p>The <code>sendMessageToUI</code> function allows a node to send custom messages to the n8n Editor UI during execution. This is useful for providing real-time feedback, progress updates, or custom UI interactions while a workflow is running.</p>"},{"location":"public-api/advanced/sendMessageToUI/#when-to-use","title":"When to Use","text":"<p>Use <code>sendMessageToUI</code> when your node needs to: - Display progress or status updates in the UI - Send custom messages to the frontend - Trigger UI-side behavior during execution - Provide real-time feedback for long-running operations - Communicate structured data to the UI for visualization</p>"},{"location":"public-api/advanced/sendMessageToUI/#function-signature","title":"Function Signature","text":"<pre><code>sendMessageToUI(message: any): void\n</code></pre>"},{"location":"public-api/advanced/sendMessageToUI/#parameters","title":"Parameters","text":"<ul> <li>message: Any serializable object to send to the UI. It should include a <code>type</code> field to identify the message kind.</li> </ul>"},{"location":"public-api/advanced/sendMessageToUI/#return-value","title":"Return Value","text":"<p>This function does not return a value. It sends a message to the UI asynchronously.</p>"},{"location":"public-api/advanced/sendMessageToUI/#basic-usage","title":"Basic Usage","text":"<pre><code>import { IExecuteFunctions } from 'n8n-workflow'\n\nexport async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n\n  this.sendMessageToUI({\n    type: 'progress',\n    message: 'Starting processing...',\n    timestamp: new Date().toISOString()\n  })\n\n  // Simulate work\n  await new Promise(resolve =&gt; setTimeout(resolve, 1000))\n\n  this.sendMessageToUI({\n    type: 'progress',\n    message: 'Processing complete!',\n    timestamp: new Date().toISOString()\n  })\n\n  return [items]\n}\n</code></pre>"},{"location":"public-api/advanced/sendMessageToUI/#advanced-usage","title":"Advanced Usage","text":""},{"location":"public-api/advanced/sendMessageToUI/#sending-structured-data","title":"Sending Structured Data","text":"<pre><code>this.sendMessageToUI({\n  type: 'chart-data',\n  chartType: 'bar',\n  data: {\n    labels: ['A', 'B', 'C'],\n    values: [10, 20, 30]\n  }\n})\n</code></pre>"},{"location":"public-api/advanced/sendMessageToUI/#sending-error-notifications","title":"Sending Error Notifications","text":"<pre><code>this.sendMessageToUI({\n  type: 'error',\n  message: 'Something went wrong during processing',\n  details: {\n    node: this.getNode().name,\n    time: new Date().toISOString()\n  }\n})\n</code></pre>"},{"location":"public-api/advanced/sendMessageToUI/#best-practices","title":"Best Practices","text":"<ol> <li>Use a <code>type</code> field to distinguish message types</li> <li>Avoid sending large payloads to the UI</li> <li>Throttle frequent updates to prevent UI overload</li> <li>Use consistent message formats for easier handling</li> <li>Document expected message types for frontend developers</li> </ol>"},{"location":"public-api/advanced/sendMessageToUI/#ui-integration","title":"UI Integration","text":"<p>To handle messages in the UI, listen for <code>nodeExecutionMessage</code> events in the n8n Editor. Custom plugins or extensions can use this to display progress bars, charts, or logs.</p>"},{"location":"public-api/advanced/sendMessageToUI/#related-documentation","title":"Related Documentation","text":"<ul> <li>startJob - For launching background jobs</li> <li>logAiEvent - For logging AI-related events</li> <li>IExecuteFunctions - Main execution context</li> </ul>"},{"location":"public-api/advanced/startJob/","title":"startJob","text":"<p>The <code>startJob</code> function allows a node to launch a background job and await its result. This is useful for offloading long-running or asynchronous tasks to a separate execution context while maintaining control and observability.</p>"},{"location":"public-api/advanced/startJob/#when-to-use","title":"When to Use","text":"<p>Use <code>startJob</code> when your node needs to: - Launch a long-running or asynchronous task - Offload work to a background worker - Integrate with job queues or task runners - Perform parallel or distributed processing - Await a result from an external system or service</p>"},{"location":"public-api/advanced/startJob/#function-signature","title":"Function Signature","text":"<pre><code>startJob&lt;T = unknown, E = unknown&gt;(\n  jobType: string,\n  settings: unknown,\n  itemIndex: number\n): Promise&lt;Result&lt;T, E&gt;&gt;\n</code></pre>"},{"location":"public-api/advanced/startJob/#parameters","title":"Parameters","text":"<ul> <li>jobType: A string identifier for the type of job to start</li> <li>settings: Arbitrary configuration or payload for the job</li> <li>itemIndex: The index of the item in the input data this job is associated with</li> </ul>"},{"location":"public-api/advanced/startJob/#return-value","title":"Return Value","text":"<p>Returns a <code>Promise&lt;Result&lt;T, E&gt;&gt;</code> where: - <code>T</code> is the success result type - <code>E</code> is the error result type - The result is a discriminated union with <code>success: true</code> or <code>success: false</code></p>"},{"location":"public-api/advanced/startJob/#basic-usage","title":"Basic Usage","text":"<pre><code>import { IExecuteFunctions } from 'n8n-workflow'\n\nexport async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n  const results = []\n\n  for (let i = 0; i &lt; items.length; i++) {\n    const jobSettings = {\n      userId: items[i].json.userId,\n      action: 'generateReport'\n    }\n\n    const result = await this.startJob('report-generator', jobSettings, i)\n\n    if (result.success) {\n      results.push({\n        json: {\n          ...items[i].json,\n          reportUrl: result.data.url,\n          jobStatus: 'completed'\n        }\n      })\n    } else {\n      results.push({\n        json: {\n          ...items[i].json,\n          jobStatus: 'failed',\n          error: result.error\n        }\n      })\n    }\n  }\n\n  return [results]\n}\n</code></pre>"},{"location":"public-api/advanced/startJob/#advanced-usage","title":"Advanced Usage","text":""},{"location":"public-api/advanced/startJob/#retrying-failed-jobs","title":"Retrying Failed Jobs","text":"<pre><code>const maxRetries = 3\nlet attempt = 0\nlet result\n\ndo {\n  result = await this.startJob('data-sync', { recordId }, itemIndex)\n  attempt++\n} while (!result.success &amp;&amp; attempt &lt; maxRetries)\n\nif (!result.success) {\n  throw new Error(`Job failed after ${maxRetries} attempts: ${result.error}`)\n}\n</code></pre>"},{"location":"public-api/advanced/startJob/#parallel-job-launching","title":"Parallel Job Launching","text":"<pre><code>const jobPromises = items.map((item, index) =&gt;\n  this.startJob('image-processing', { imageUrl: item.json.url }, index)\n)\n\nconst jobResults = await Promise.all(jobPromises)\n\nconst results = jobResults.map((result, i) =&gt; ({\n  json: {\n    ...items[i].json,\n    status: result.success ? 'done' : 'error',\n    output: result.success ? result.data : result.error\n  }\n}))\n\nreturn [results]\n</code></pre>"},{"location":"public-api/advanced/startJob/#best-practices","title":"Best Practices","text":"<ol> <li>Use unique jobType strings to distinguish job handlers</li> <li>Validate job settings before launching</li> <li>Handle both success and error cases from the result</li> <li>Avoid blocking jobs that take too long to return</li> <li>Use retries or backoff for transient failures</li> <li>Log job metadata for observability</li> </ol>"},{"location":"public-api/advanced/startJob/#related-documentation","title":"Related Documentation","text":"<ul> <li>logAiEvent - For logging AI-related events</li> <li>sendMessageToUI - For communicating with the UI</li> <li>IExecuteFunctions - Main execution context</li> </ul>"},{"location":"public-api/execution-contexts/IExecuteFunctions/","title":"IExecuteFunctions","text":"<p>The primary execution context for regular n8n nodes. This interface provides access to all the methods and helpers needed to implement the <code>execute()</code> method of a node.</p>"},{"location":"public-api/execution-contexts/IExecuteFunctions/#when-to-use","title":"When to Use","text":"<p><code>IExecuteFunctions</code> is used in: - The <code>execute()</code> method of regular nodes - Custom operation functions in declarative nodes - Any node that processes multiple items</p> <pre><code>export async function execute(this: IExecuteFunctions): Promise&lt;INodeExecutionData[][]&gt; {\n  // Your node logic here\n}\n</code></pre>"},{"location":"public-api/execution-contexts/IExecuteFunctions/#interface-overview","title":"Interface Overview","text":"<pre><code>classDiagram\n    class IExecuteFunctions {\n        +getInputData()\n        +getNodeParameter()\n        +getCredentials()\n        +helpers\n        +executeWorkflow()\n        +putExecutionToWait()\n        +sendMessageToUI()\n        +evaluateExpression()\n        +getWorkflow()\n        +getWorkflowStaticData()\n        +continueOnFail()\n        +getExecutionId()\n    }\n\n    class Helpers {\n        +httpRequest()\n        +prepareBinaryData()\n        +returnJsonArray()\n        +normalizeItems()\n        +getBinaryDataBuffer()\n        +assertBinaryData()\n    }\n\n    IExecuteFunctions --&gt; Helpers\n</code></pre>"},{"location":"public-api/execution-contexts/IExecuteFunctions/#core-methods","title":"Core Methods","text":""},{"location":"public-api/execution-contexts/IExecuteFunctions/#data-access","title":"Data Access","text":""},{"location":"public-api/execution-contexts/IExecuteFunctions/#getinputdatainputindex-connectiontype","title":"<code>getInputData(inputIndex?, connectionType?)</code>","text":"<p>Gets the input data for the node.</p> <pre><code>getInputData(inputIndex?: number, connectionType?: NodeConnectionType): INodeExecutionData[]\n</code></pre> <p>Parameters: - <code>inputIndex</code> - Which input to get data from (default: 0) - <code>connectionType</code> - Type of connection (default: 'main')</p> <p>Example: <pre><code>const items = this.getInputData();\n// Process each item\nfor (let i = 0; i &lt; items.length; i++) {\n  const item = items[i];\n  console.log(item.json); // The JSON data\n  console.log(item.binary); // Any binary data\n}\n</code></pre></p>"},{"location":"public-api/execution-contexts/IExecuteFunctions/#getnodeparameterparametername-itemindex-fallbackvalue-options","title":"<code>getNodeParameter(parameterName, itemIndex, fallbackValue?, options?)</code>","text":"<p>Gets a parameter value configured by the user.</p> <pre><code>getNodeParameter(\n  parameterName: string,\n  itemIndex: number,\n  fallbackValue?: any,\n  options?: IGetNodeParameterOptions\n): NodeParameterValueType | object\n</code></pre> <p>Parameters: - <code>parameterName</code> - Name of the parameter - <code>itemIndex</code> - Index of the current item being processed - <code>fallbackValue</code> - Default value if parameter is not set - <code>options</code> - Additional options for parameter retrieval</p> <p>Example: <pre><code>const operation = this.getNodeParameter('operation', 0) as string;\nconst limit = this.getNodeParameter('limit', 0, 100) as number;\nconst options = this.getNodeParameter('additionalFields', 0, {}) as IDataObject;\n</code></pre></p> <p>Type-Safe Overloads: <pre><code>// String parameters\nconst resource = this.getNodeParameter('resource', itemIndex) as string;\n\n// Boolean parameters  \nconst returnAll = this.getNodeParameter('returnAll', itemIndex) as boolean;\n\n// Number parameters\nconst limit = this.getNodeParameter('limit', itemIndex) as number;\n\n// Object parameters\nconst filters = this.getNodeParameter('filters', itemIndex, {}) as IDataObject;\n</code></pre></p>"},{"location":"public-api/execution-contexts/IExecuteFunctions/#credentials","title":"Credentials","text":""},{"location":"public-api/execution-contexts/IExecuteFunctions/#getcredentialstype-itemindex","title":"<code>getCredentials(type, itemIndex?)</code>","text":"<p>Gets decrypted credentials for the specified type.</p> <pre><code>getCredentials&lt;T extends object = ICredentialDataDecryptedObject&gt;(\n  type: string,\n  itemIndex?: number\n): Promise&lt;T&gt;\n</code></pre> <p>Example: <pre><code>const credentials = await this.getCredentials('httpBasicAuth');\nconst username = credentials.user as string;\nconst password = credentials.password as string;\n\n// Type-safe approach\ninterface MyApiCredentials {\n  apiKey: string;\n  baseUrl: string;\n}\n\nconst creds = await this.getCredentials&lt;MyApiCredentials&gt;('myApi');\nconsole.log(creds.apiKey); // TypeScript knows this is a string\n</code></pre></p>"},{"location":"public-api/execution-contexts/IExecuteFunctions/#workflow-control","title":"Workflow Control","text":""},{"location":"public-api/execution-contexts/IExecuteFunctions/#executeworkflowworkflowinfo-inputdata-parentcallbackmanager-options","title":"<code>executeWorkflow(workflowInfo, inputData?, parentCallbackManager?, options?)</code>","text":"<p>Executes another workflow from within the current node.</p> <pre><code>executeWorkflow(\n  workflowInfo: IExecuteWorkflowInfo,\n  inputData?: INodeExecutionData[],\n  parentCallbackManager?: CallbackManager,\n  options?: {\n    doNotWaitToFinish?: boolean;\n    parentExecution?: RelatedExecution;\n  }\n): Promise&lt;ExecuteWorkflowData&gt;\n</code></pre> <p>Example: <pre><code>const result = await this.executeWorkflow(\n  { id: 'workflow-id-123' },\n  [{ json: { message: 'Hello from parent workflow' } }]\n);\n\nconsole.log(result.data); // Results from the sub-workflow\n</code></pre></p>"},{"location":"public-api/execution-contexts/IExecuteFunctions/#putexecutiontowaitwaittill","title":"<code>putExecutionToWait(waitTill)</code>","text":"<p>Pauses the workflow execution until a specified time.</p> <pre><code>putExecutionToWait(waitTill: Date): Promise&lt;void&gt;\n</code></pre> <p>Example: <pre><code>// Wait for 5 minutes\nconst waitUntil = new Date(Date.now() + 5 * 60 * 1000);\nawait this.putExecutionToWait(waitUntil);\n</code></pre></p>"},{"location":"public-api/execution-contexts/IExecuteFunctions/#expression-evaluation","title":"Expression Evaluation","text":""},{"location":"public-api/execution-contexts/IExecuteFunctions/#evaluateexpressionexpression-itemindex","title":"<code>evaluateExpression(expression, itemIndex)</code>","text":"<p>Evaluates an n8n expression in the context of the current item.</p> <pre><code>evaluateExpression(expression: string, itemIndex: number): NodeParameterValueType\n</code></pre> <p>Example: <pre><code>const result = this.evaluateExpression('{{ $json.name.toUpperCase() }}', 0);\nconst timestamp = this.evaluateExpression('{{ $now }}', 0);\nconst itemCount = this.evaluateExpression('{{ $items.length }}', 0);\n</code></pre></p>"},{"location":"public-api/execution-contexts/IExecuteFunctions/#metadata-access","title":"Metadata Access","text":""},{"location":"public-api/execution-contexts/IExecuteFunctions/#getworkflow","title":"<code>getWorkflow()</code>","text":"<p>Gets metadata about the current workflow.</p> <pre><code>getWorkflow(): IWorkflowMetadata\n</code></pre> <p>Example: <pre><code>const workflow = this.getWorkflow();\nconsole.log(workflow.name); // Workflow name\nconsole.log(workflow.active); // Whether workflow is active\nconsole.log(workflow.id); // Workflow ID\n</code></pre></p>"},{"location":"public-api/execution-contexts/IExecuteFunctions/#getnode","title":"<code>getNode()</code>","text":"<p>Gets information about the current node.</p> <pre><code>getNode(): INode\n</code></pre> <p>Example: <pre><code>const node = this.getNode();\nconsole.log(node.name); // Node name\nconsole.log(node.type); // Node type\nconsole.log(node.parameters); // Node parameters\n</code></pre></p>"},{"location":"public-api/execution-contexts/IExecuteFunctions/#getexecutionid","title":"<code>getExecutionId()</code>","text":"<p>Gets the current execution ID.</p> <pre><code>getExecutionId(): string\n</code></pre> <p>Example: <pre><code>const executionId = this.getExecutionId();\nconsole.log(`Processing in execution: ${executionId}`);\n</code></pre></p>"},{"location":"public-api/execution-contexts/IExecuteFunctions/#error-handling","title":"Error Handling","text":""},{"location":"public-api/execution-contexts/IExecuteFunctions/#continueonfail","title":"<code>continueOnFail()</code>","text":"<p>Checks if the node should continue on failure.</p> <pre><code>continueOnFail(): boolean\n</code></pre> <p>Example: <pre><code>try {\n  // Risky operation\n  await this.helpers.httpRequest(options);\n} catch (error) {\n  if (this.continueOnFail()) {\n    return [{ json: { error: error.message } }];\n  }\n  throw error;\n}\n</code></pre></p>"},{"location":"public-api/execution-contexts/IExecuteFunctions/#ui-communication","title":"UI Communication","text":""},{"location":"public-api/execution-contexts/IExecuteFunctions/#sendmessagetouimessage","title":"<code>sendMessageToUI(message)</code>","text":"<p>Sends a message to the n8n UI (useful for progress updates).</p> <pre><code>sendMessageToUI(message: any): void\n</code></pre> <p>Example: <pre><code>this.sendMessageToUI(`Processing item ${i + 1} of ${items.length}`);\n</code></pre></p>"},{"location":"public-api/execution-contexts/IExecuteFunctions/#sendresponseresponse","title":"<code>sendResponse(response)</code>","text":"<p>Sends a response back to the caller (for webhook nodes).</p> <pre><code>sendResponse(response: IExecuteResponsePromiseData): void\n</code></pre>"},{"location":"public-api/execution-contexts/IExecuteFunctions/#helpers-object","title":"Helpers Object","text":"<p>The <code>helpers</code> object provides utility functions for common operations:</p>"},{"location":"public-api/execution-contexts/IExecuteFunctions/#http-helpers","title":"HTTP Helpers","text":"<pre><code>// Make HTTP requests\nawait this.helpers.httpRequest(options);\nawait this.helpers.httpRequestWithAuthentication('credentialType', options);\n</code></pre>"},{"location":"public-api/execution-contexts/IExecuteFunctions/#binary-helpers","title":"Binary Helpers","text":"<pre><code>// Prepare binary data\nconst binaryData = await this.helpers.prepareBinaryData(buffer, 'file.pdf');\n\n// Get binary data as buffer\nconst buffer = await this.helpers.getBinaryDataBuffer(itemIndex, 'data');\n\n// Assert binary data exists\nconst binaryData = this.helpers.assertBinaryData(itemIndex, 'data');\n</code></pre>"},{"location":"public-api/execution-contexts/IExecuteFunctions/#utility-helpers","title":"Utility Helpers","text":"<pre><code>// Return data as array\nreturn this.helpers.returnJsonArray(data);\n\n// Normalize items\nconst normalized = this.helpers.normalizeItems(items);\n\n// Construct execution metadata\nconst withMetadata = this.helpers.constructExecutionMetaData(inputData, {\n  itemData: { item: 0 }\n});\n</code></pre>"},{"location":"public-api/execution-contexts/IExecuteFunctions/#complete-example","title":"Complete Example","text":"<pre><code>import {\n  IExecuteFunctions,\n  INodeExecutionData,\n  INodeType,\n  INodeTypeDescription,\n  NodeOperationError,\n} from 'n8n-workflow';\n\nexport class ExampleNode implements INodeType {\n  description: INodeTypeDescription = {\n    displayName: 'Example Node',\n    name: 'exampleNode',\n    group: ['transform'],\n    version: 1,\n    description: 'Example node using IExecuteFunctions',\n    defaults: { name: 'Example Node' },\n    inputs: ['main'],\n    outputs: ['main'],\n    properties: [\n      {\n        displayName: 'Operation',\n        name: 'operation',\n        type: 'options',\n        options: [\n          { name: 'Get Data', value: 'getData' },\n          { name: 'Process Data', value: 'processData' },\n        ],\n        default: 'getData',\n      },\n      {\n        displayName: 'API URL',\n        name: 'apiUrl',\n        type: 'string',\n        default: 'https://api.example.com',\n        displayOptions: {\n          show: { operation: ['getData'] },\n        },\n      },\n    ],\n    credentials: [\n      {\n        name: 'httpBasicAuth',\n        required: true,\n      },\n    ],\n  };\n\n  async execute(this: IExecuteFunctions): Promise&lt;INodeExecutionData[][]&gt; {\n    const items = this.getInputData();\n    const returnData: INodeExecutionData[] = [];\n    const operation = this.getNodeParameter('operation', 0) as string;\n\n    // Get credentials\n    const credentials = await this.getCredentials('httpBasicAuth');\n\n    for (let i = 0; i &lt; items.length; i++) {\n      try {\n        if (operation === 'getData') {\n          const apiUrl = this.getNodeParameter('apiUrl', i) as string;\n\n          // Make HTTP request with authentication\n          const response = await this.helpers.httpRequestWithAuthentication(\n            'httpBasicAuth',\n            {\n              method: 'GET',\n              url: apiUrl,\n              json: true,\n            }\n          );\n\n          returnData.push({\n            json: response,\n            pairedItem: { item: i },\n          });\n\n        } else if (operation === 'processData') {\n          const inputData = items[i].json;\n\n          // Process the data\n          const processedData = {\n            ...inputData,\n            processed: true,\n            processedAt: new Date().toISOString(),\n            executionId: this.getExecutionId(),\n          };\n\n          returnData.push({\n            json: processedData,\n            pairedItem: { item: i },\n          });\n        }\n\n        // Send progress update\n        this.sendMessageToUI(`Processed item ${i + 1} of ${items.length}`);\n\n      } catch (error) {\n        if (this.continueOnFail()) {\n          returnData.push({\n            json: { error: error.message },\n            pairedItem: { item: i },\n          });\n        } else {\n          throw new NodeOperationError(this.getNode(), error.message, { itemIndex: i });\n        }\n      }\n    }\n\n    return [returnData];\n  }\n}\n</code></pre>"},{"location":"public-api/execution-contexts/IExecuteFunctions/#best-practices","title":"Best Practices","text":""},{"location":"public-api/execution-contexts/IExecuteFunctions/#error-handling_1","title":"Error Handling","text":"<pre><code>try {\n  // Your operation\n} catch (error) {\n  if (this.continueOnFail()) {\n    return [{ json: { error: error.message } }];\n  }\n  throw new NodeOperationError(this.getNode(), error.message, { itemIndex: i });\n}\n</code></pre>"},{"location":"public-api/execution-contexts/IExecuteFunctions/#type-safety","title":"Type Safety","text":"<pre><code>// Use type assertions for known parameter types\nconst operation = this.getNodeParameter('operation', i) as string;\nconst limit = this.getNodeParameter('limit', i, 100) as number;\n\n// Use interfaces for complex credentials\ninterface MyApiCredentials {\n  apiKey: string;\n  baseUrl: string;\n}\nconst creds = await this.getCredentials&lt;MyApiCredentials&gt;('myApi');\n</code></pre>"},{"location":"public-api/execution-contexts/IExecuteFunctions/#performance","title":"Performance","text":"<pre><code>// Process items in batches for large datasets\nconst batchSize = 100;\nfor (let i = 0; i &lt; items.length; i += batchSize) {\n  const batch = items.slice(i, i + batchSize);\n  // Process batch\n}\n</code></pre>"},{"location":"public-api/execution-contexts/IExecuteFunctions/#paired-items","title":"Paired Items","text":"<pre><code>// Always include pairedItem for data lineage\nreturnData.push({\n  json: processedData,\n  pairedItem: { item: i },\n});\n</code></pre>"},{"location":"public-api/execution-contexts/IExecuteFunctions/#see-also","title":"See Also","text":"<ul> <li>IExecuteSingleFunctions - Single-item execution context</li> <li>HTTP Helpers - Making HTTP requests</li> <li>Binary Helpers - Working with binary data</li> <li>Error Handling - Robust error management</li> </ul>"},{"location":"public-api/execution-contexts/IExecuteSingleFunctions/","title":"IExecuteSingleFunctions","text":"<p>The execution context for nodes that process items one at a time. This interface is used when your node needs to handle each input item individually, typically for operations that don't benefit from batch processing.</p>"},{"location":"public-api/execution-contexts/IExecuteSingleFunctions/#when-to-use","title":"When to Use","text":"<p>Use <code>IExecuteSingleFunctions</code> when: - Processing items individually is more efficient - Each item requires different processing logic - You need to handle errors per item - The operation doesn't support batch processing</p>"},{"location":"public-api/execution-contexts/IExecuteSingleFunctions/#interface-definition","title":"Interface Definition","text":"<pre><code>interface IExecuteSingleFunctions extends IExecuteFunctions {\n  getInputData(): INodeExecutionData;\n  // Inherits all methods from IExecuteFunctions\n}\n</code></pre>"},{"location":"public-api/execution-contexts/IExecuteSingleFunctions/#key-differences-from-iexecutefunctions","title":"Key Differences from IExecuteFunctions","text":"Feature IExecuteFunctions IExecuteSingleFunctions Input handling <code>getInputData()</code> returns array <code>getInputData()</code> returns single item Item processing Loop through items Process current item Return format Array of items Single item or array Use case Batch operations Individual item operations"},{"location":"public-api/execution-contexts/IExecuteSingleFunctions/#core-methods","title":"Core Methods","text":""},{"location":"public-api/execution-contexts/IExecuteSingleFunctions/#getinputdata","title":"getInputData()","text":"<p>Returns the current input item being processed.</p> <pre><code>getInputData(): INodeExecutionData\n</code></pre> <p>Returns: Single <code>INodeExecutionData</code> object containing: - <code>json</code> - The JSON data - <code>binary?</code> - Binary data if present - <code>pairedItem?</code> - Reference to source item</p>"},{"location":"public-api/execution-contexts/IExecuteSingleFunctions/#implementation-example","title":"Implementation Example","text":"<pre><code>import {\n  IExecuteSingleFunctions,\n  INodeExecutionData,\n  INodeType,\n  INodeTypeDescription,\n  NodeOperationError,\n} from 'n8n-workflow';\n\nexport class SingleProcessorNode implements INodeType {\n  description: INodeTypeDescription = {\n    displayName: 'Single Processor',\n    name: 'singleProcessor',\n    group: ['transform'],\n    version: 1,\n    description: 'Process items individually',\n    defaults: {\n      name: 'Single Processor',\n    },\n    inputs: ['main'],\n    outputs: ['main'],\n    properties: [\n      {\n        displayName: 'Operation',\n        name: 'operation',\n        type: 'options',\n        options: [\n          {\n            name: 'Transform',\n            value: 'transform',\n          },\n          {\n            name: 'Validate',\n            value: 'validate',\n          },\n        ],\n        default: 'transform',\n      },\n    ],\n  };\n\n  async executeSingle(this: IExecuteSingleFunctions): Promise&lt;INodeExecutionData&gt; {\n    const operation = this.getNodeParameter('operation', 0) as string;\n    const item = this.getInputData();\n\n    try {\n      switch (operation) {\n        case 'transform':\n          return await this.transformItem(item);\n        case 'validate':\n          return await this.validateItem(item);\n        default:\n          throw new NodeOperationError(\n            this.getNode(),\n            `Unknown operation: ${operation}`\n          );\n      }\n    } catch (error) {\n      if (this.continueOnFail()) {\n        return {\n          json: { error: error.message },\n          pairedItem: item.pairedItem,\n        };\n      }\n      throw error;\n    }\n  }\n\n  private async transformItem(item: INodeExecutionData): Promise&lt;INodeExecutionData&gt; {\n    // Transform the item\n    const transformedData = {\n      ...item.json,\n      processed: true,\n      timestamp: new Date().toISOString(),\n    };\n\n    return {\n      json: transformedData,\n      binary: item.binary,\n      pairedItem: item.pairedItem,\n    };\n  }\n\n  private async validateItem(item: INodeExecutionData): Promise&lt;INodeExecutionData&gt; {\n    // Validate the item\n    const isValid = this.validateData(item.json);\n\n    return {\n      json: {\n        ...item.json,\n        isValid,\n        validatedAt: new Date().toISOString(),\n      },\n      binary: item.binary,\n      pairedItem: item.pairedItem,\n    };\n  }\n\n  private validateData(data: any): boolean {\n    // Custom validation logic\n    return data &amp;&amp; typeof data === 'object' &amp;&amp; Object.keys(data).length &gt; 0;\n  }\n}\n</code></pre>"},{"location":"public-api/execution-contexts/IExecuteSingleFunctions/#common-patterns","title":"Common Patterns","text":""},{"location":"public-api/execution-contexts/IExecuteSingleFunctions/#error-handling-per-item","title":"Error Handling Per Item","text":"<pre><code>async executeSingle(this: IExecuteSingleFunctions): Promise&lt;INodeExecutionData&gt; {\n  const item = this.getInputData();\n\n  try {\n    // Process the item\n    const result = await this.processItem(item);\n    return result;\n  } catch (error) {\n    if (this.continueOnFail()) {\n      // Return error information but continue processing\n      return {\n        json: {\n          error: error.message,\n          originalData: item.json,\n        },\n        pairedItem: item.pairedItem,\n      };\n    }\n\n    // Re-throw to stop execution\n    throw new NodeOperationError(\n      this.getNode(),\n      `Failed to process item: ${error.message}`,\n      { itemIndex: 0 }\n    );\n  }\n}\n</code></pre>"},{"location":"public-api/execution-contexts/IExecuteSingleFunctions/#conditional-processing","title":"Conditional Processing","text":"<pre><code>async executeSingle(this: IExecuteSingleFunctions): Promise&lt;INodeExecutionData&gt; {\n  const item = this.getInputData();\n  const condition = this.getNodeParameter('condition', 0) as string;\n\n  // Check if item meets condition\n  if (!this.meetsCondition(item.json, condition)) {\n    // Return item unchanged\n    return item;\n  }\n\n  // Process the item\n  const processedData = await this.processItem(item.json);\n\n  return {\n    json: processedData,\n    binary: item.binary,\n    pairedItem: item.pairedItem,\n  };\n}\n</code></pre>"},{"location":"public-api/execution-contexts/IExecuteSingleFunctions/#binary-data-handling","title":"Binary Data Handling","text":"<pre><code>async executeSingle(this: IExecuteSingleFunctions): Promise&lt;INodeExecutionData&gt; {\n  const item = this.getInputData();\n\n  // Process binary data if present\n  if (item.binary) {\n    const processedBinary: IBinaryKeyData = {};\n\n    for (const [key, binaryData] of Object.entries(item.binary)) {\n      const buffer = await this.helpers.getBinaryDataBuffer(0, key);\n      const processedBuffer = await this.processBinaryData(buffer);\n\n      processedBinary[key] = await this.helpers.prepareBinaryData(\n        processedBuffer,\n        binaryData.fileName,\n        binaryData.mimeType\n      );\n    }\n\n    return {\n      json: item.json,\n      binary: processedBinary,\n      pairedItem: item.pairedItem,\n    };\n  }\n\n  return item;\n}\n</code></pre>"},{"location":"public-api/execution-contexts/IExecuteSingleFunctions/#performance-considerations","title":"Performance Considerations","text":""},{"location":"public-api/execution-contexts/IExecuteSingleFunctions/#when-to-use-single-vs-batch-processing","title":"When to Use Single vs Batch Processing","text":"<pre><code>// \u2705 Good for single processing\n- API calls that don't support batch operations\n- File processing where each file is different\n- Complex transformations that vary per item\n- Operations that need individual error handling\n\n// \u274c Better with batch processing (IExecuteFunctions)\n- Database operations that support batch inserts\n- Simple transformations applied to all items\n- Operations where order matters across items\n- Aggregation operations\n</code></pre>"},{"location":"public-api/execution-contexts/IExecuteSingleFunctions/#memory-management","title":"Memory Management","text":"<pre><code>async executeSingle(this: IExecuteSingleFunctions): Promise&lt;INodeExecutionData&gt; {\n  const item = this.getInputData();\n\n  // Process large data efficiently\n  if (this.isLargeDataItem(item)) {\n    // Stream processing for large items\n    return await this.processLargeItem(item);\n  }\n\n  // Standard processing for normal items\n  return await this.processNormalItem(item);\n}\n\nprivate isLargeDataItem(item: INodeExecutionData): boolean {\n  const jsonSize = JSON.stringify(item.json).length;\n  const binarySize = item.binary ? Object.keys(item.binary).length : 0;\n\n  return jsonSize &gt; 1000000 || binarySize &gt; 0; // 1MB threshold\n}\n</code></pre>"},{"location":"public-api/execution-contexts/IExecuteSingleFunctions/#best-practices","title":"Best Practices","text":""},{"location":"public-api/execution-contexts/IExecuteSingleFunctions/#1-preserve-item-context","title":"1. Preserve Item Context","text":"<pre><code>// \u2705 Good - preserve pairedItem for traceability\nreturn {\n  json: processedData,\n  binary: item.binary,\n  pairedItem: item.pairedItem,\n};\n\n// \u274c Bad - lose item context\nreturn {\n  json: processedData,\n};\n</code></pre>"},{"location":"public-api/execution-contexts/IExecuteSingleFunctions/#2-handle-missing-data-gracefully","title":"2. Handle Missing Data Gracefully","text":"<pre><code>async executeSingle(this: IExecuteSingleFunctions): Promise&lt;INodeExecutionData&gt; {\n  const item = this.getInputData();\n\n  // Validate required fields\n  const requiredField = item.json.requiredField;\n  if (!requiredField) {\n    if (this.continueOnFail()) {\n      return {\n        json: {\n          ...item.json,\n          error: 'Missing required field',\n        },\n        pairedItem: item.pairedItem,\n      };\n    }\n    throw new NodeOperationError(\n      this.getNode(),\n      'Required field is missing'\n    );\n  }\n\n  // Process item\n  return await this.processItem(item);\n}\n</code></pre>"},{"location":"public-api/execution-contexts/IExecuteSingleFunctions/#3-use-type-safety","title":"3. Use Type Safety","text":"<pre><code>interface InputData {\n  id: string;\n  name: string;\n  email?: string;\n}\n\ninterface OutputData extends InputData {\n  processed: boolean;\n  timestamp: string;\n}\n\nasync executeSingle(this: IExecuteSingleFunctions): Promise&lt;INodeExecutionData&gt; {\n  const item = this.getInputData();\n  const inputData = item.json as InputData;\n\n  // Type-safe processing\n  const outputData: OutputData = {\n    ...inputData,\n    processed: true,\n    timestamp: new Date().toISOString(),\n  };\n\n  return {\n    json: outputData,\n    binary: item.binary,\n    pairedItem: item.pairedItem,\n  };\n}\n</code></pre>"},{"location":"public-api/execution-contexts/IExecuteSingleFunctions/#error-handling","title":"Error Handling","text":""},{"location":"public-api/execution-contexts/IExecuteSingleFunctions/#graceful-degradation","title":"Graceful Degradation","text":"<pre><code>async executeSingle(this: IExecuteSingleFunctions): Promise&lt;INodeExecutionData&gt; {\n  const item = this.getInputData();\n\n  try {\n    // Primary processing\n    return await this.primaryProcess(item);\n  } catch (primaryError) {\n    try {\n      // Fallback processing\n      return await this.fallbackProcess(item);\n    } catch (fallbackError) {\n      if (this.continueOnFail()) {\n        return {\n          json: {\n            ...item.json,\n            error: `Primary: ${primaryError.message}, Fallback: ${fallbackError.message}`,\n          },\n          pairedItem: item.pairedItem,\n        };\n      }\n      throw new NodeOperationError(\n        this.getNode(),\n        `All processing methods failed: ${primaryError.message}`\n      );\n    }\n  }\n}\n</code></pre>"},{"location":"public-api/execution-contexts/IExecuteSingleFunctions/#see-also","title":"See Also","text":"<ul> <li>IExecuteFunctions - Batch processing context</li> <li>getNodeParameter - Accessing node parameters</li> <li>Error Handling - Robust error management</li> <li>Binary Data - Working with files and binary data</li> </ul>"},{"location":"public-api/execution-contexts/IHookFunctions/","title":"IHookFunctions","text":"<p>The execution context for lifecycle hook functions that execute at specific points in a workflow's lifecycle. This interface is used when your node needs to perform setup, cleanup, or monitoring operations during workflow execution.</p>"},{"location":"public-api/execution-contexts/IHookFunctions/#when-to-use","title":"When to Use","text":"<p>Use <code>IHookFunctions</code> when: - Performing setup operations before workflow execution - Cleaning up resources after workflow completion - Monitoring workflow progress and performance - Implementing custom logging or analytics</p>"},{"location":"public-api/execution-contexts/IHookFunctions/#interface-definition","title":"Interface Definition","text":"<pre><code>interface IHookFunctions extends IExecuteFunctions {\n  getMode(): WorkflowExecuteMode;\n  getActivationMode(): WorkflowActivateMode;\n  getWorkflowStaticData(type: string): IDataObject;\n  helpers: IHookFunctionsHelpers;\n}\n</code></pre>"},{"location":"public-api/execution-contexts/IHookFunctions/#core-methods","title":"Core Methods","text":""},{"location":"public-api/execution-contexts/IHookFunctions/#getmode","title":"getMode()","text":"<p>Returns the current workflow execution mode.</p> <pre><code>getMode(): WorkflowExecuteMode\n</code></pre> <p>Returns: The execution mode ('manual', 'trigger', 'webhook', etc.)</p>"},{"location":"public-api/execution-contexts/IHookFunctions/#getactivationmode","title":"getActivationMode()","text":"<p>Returns how the workflow was activated.</p> <pre><code>getActivationMode(): WorkflowActivateMode\n</code></pre> <p>Returns: The activation mode ('init', 'create', 'update', etc.)</p>"},{"location":"public-api/execution-contexts/IHookFunctions/#getworkflowstaticdata","title":"getWorkflowStaticData()","text":"<p>Gets persistent data that survives across workflow executions.</p> <pre><code>getWorkflowStaticData(type: string): IDataObject\n</code></pre> <p>Parameters: - <code>type</code> - The type of static data ('global' or 'node')</p> <p>Returns: Static data object</p>"},{"location":"public-api/execution-contexts/IHookFunctions/#hook-types","title":"Hook Types","text":""},{"location":"public-api/execution-contexts/IHookFunctions/#beforeexecute","title":"beforeExecute","text":"<p>Runs before the workflow starts executing.</p> <pre><code>async beforeExecute(this: IHookFunctions): Promise&lt;void&gt; {\n  // Setup operations\n}\n</code></pre>"},{"location":"public-api/execution-contexts/IHookFunctions/#afterexecute","title":"afterExecute","text":"<p>Runs after the workflow completes execution.</p> <pre><code>async afterExecute(this: IHookFunctions, data: IRunExecutionData): Promise&lt;void&gt; {\n  // Cleanup operations\n}\n</code></pre>"},{"location":"public-api/execution-contexts/IHookFunctions/#onerror","title":"onError","text":"<p>Runs when the workflow encounters an error.</p> <pre><code>async onError(this: IHookFunctions, error: Error): Promise&lt;void&gt; {\n  // Error handling\n}\n</code></pre>"},{"location":"public-api/execution-contexts/IHookFunctions/#implementation-example","title":"Implementation Example","text":"<pre><code>import {\n  IHookFunctions,\n  INodeType,\n  INodeTypeDescription,\n  IRunExecutionData,\n  NodeOperationError,\n} from 'n8n-workflow';\n\nexport class WorkflowMonitor implements INodeType {\n  description: INodeTypeDescription = {\n    displayName: 'Workflow Monitor',\n    name: 'workflowMonitor',\n    icon: 'fa:chart-line',\n    group: ['utility'],\n    version: 1,\n    description: 'Monitors workflow execution and performance',\n    defaults: {\n      name: 'Workflow Monitor',\n    },\n    inputs: ['main'],\n    outputs: ['main'],\n    properties: [\n      {\n        displayName: 'Enable Performance Tracking',\n        name: 'enablePerformanceTracking',\n        type: 'boolean',\n        default: true,\n        description: 'Track execution time and performance metrics',\n      },\n      {\n        displayName: 'Log Level',\n        name: 'logLevel',\n        type: 'options',\n        options: [\n          { name: 'Debug', value: 'debug' },\n          { name: 'Info', value: 'info' },\n          { name: 'Warning', value: 'warning' },\n          { name: 'Error', value: 'error' },\n        ],\n        default: 'info',\n        description: 'Minimum log level to record',\n      },\n      {\n        displayName: 'Send Notifications',\n        name: 'sendNotifications',\n        type: 'boolean',\n        default: false,\n        description: 'Send notifications on workflow events',\n      },\n    ],\n  };\n\n  hooks = {\n    beforeExecute: [\n      async function(this: IHookFunctions): Promise&lt;void&gt; {\n        const enablePerformanceTracking = this.getNodeParameter('enablePerformanceTracking', 0) as boolean;\n\n        if (enablePerformanceTracking) {\n          // Initialize performance tracking\n          const staticData = this.getWorkflowStaticData('global');\n          staticData.executionStartTime = Date.now();\n          staticData.executionCount = (staticData.executionCount as number || 0) + 1;\n\n          this.logger.info('Workflow execution started', {\n            executionId: this.getExecutionId(),\n            executionCount: staticData.executionCount,\n            mode: this.getMode(),\n          });\n        }\n      },\n    ],\n\n    afterExecute: [\n      async function(this: IHookFunctions, data: IRunExecutionData): Promise&lt;void&gt; {\n        const enablePerformanceTracking = this.getNodeParameter('enablePerformanceTracking', 0) as boolean;\n        const sendNotifications = this.getNodeParameter('sendNotifications', 0) as boolean;\n\n        if (enablePerformanceTracking) {\n          const staticData = this.getWorkflowStaticData('global');\n          const executionTime = Date.now() - (staticData.executionStartTime as number);\n\n          // Update performance metrics\n          staticData.totalExecutionTime = (staticData.totalExecutionTime as number || 0) + executionTime;\n          staticData.averageExecutionTime = staticData.totalExecutionTime / staticData.executionCount;\n\n          this.logger.info('Workflow execution completed', {\n            executionId: this.getExecutionId(),\n            executionTime,\n            averageExecutionTime: staticData.averageExecutionTime,\n            success: data.resultData.runData ? true : false,\n          });\n        }\n\n        if (sendNotifications) {\n          await this.sendSuccessNotification(data);\n        }\n      },\n    ],\n\n    onError: [\n      async function(this: IHookFunctions, error: Error): Promise&lt;void&gt; {\n        const logLevel = this.getNodeParameter('logLevel', 0) as string;\n        const sendNotifications = this.getNodeParameter('sendNotifications', 0) as boolean;\n\n        // Log error details\n        this.logger.error('Workflow execution failed', {\n          executionId: this.getExecutionId(),\n          error: error.message,\n          stack: error.stack,\n          mode: this.getMode(),\n        });\n\n        // Update error statistics\n        const staticData = this.getWorkflowStaticData('global');\n        staticData.errorCount = (staticData.errorCount as number || 0) + 1;\n        staticData.lastError = {\n          message: error.message,\n          timestamp: new Date().toISOString(),\n        };\n\n        if (sendNotifications) {\n          await this.sendErrorNotification(error);\n        }\n      },\n    ],\n  };\n\n  private async sendSuccessNotification(data: IRunExecutionData): Promise&lt;void&gt; {\n    try {\n      await this.helpers.httpRequest({\n        method: 'POST',\n        url: 'https://api.example.com/notifications',\n        body: {\n          type: 'workflow_success',\n          workflowId: this.getWorkflow().id,\n          executionId: this.getExecutionId(),\n          timestamp: new Date().toISOString(),\n        },\n        headers: {\n          'Content-Type': 'application/json',\n        },\n      });\n    } catch (error) {\n      this.logger.warning('Failed to send success notification', { error: error.message });\n    }\n  }\n\n  private async sendErrorNotification(error: Error): Promise&lt;void&gt; {\n    try {\n      await this.helpers.httpRequest({\n        method: 'POST',\n        url: 'https://api.example.com/notifications',\n        body: {\n          type: 'workflow_error',\n          workflowId: this.getWorkflow().id,\n          executionId: this.getExecutionId(),\n          error: error.message,\n          timestamp: new Date().toISOString(),\n        },\n        headers: {\n          'Content-Type': 'application/json',\n        },\n      });\n    } catch (notificationError) {\n      this.logger.warning('Failed to send error notification', { \n        error: notificationError.message \n      });\n    }\n  }\n}\n</code></pre>"},{"location":"public-api/execution-contexts/IHookFunctions/#common-patterns","title":"Common Patterns","text":""},{"location":"public-api/execution-contexts/IHookFunctions/#resource-management-hook","title":"Resource Management Hook","text":"<pre><code>hooks = {\n  beforeExecute: [\n    async function(this: IHookFunctions): Promise&lt;void&gt; {\n      // Initialize database connections\n      const staticData = this.getWorkflowStaticData('global');\n\n      if (!staticData.dbConnection) {\n        const connectionString = this.getNodeParameter('connectionString', 0) as string;\n        staticData.dbConnection = await this.helpers.dbConnect(connectionString);\n\n        this.logger.info('Database connection established');\n      }\n\n      // Initialize cache\n      if (!staticData.cache) {\n        staticData.cache = new Map();\n        this.logger.info('Cache initialized');\n      }\n    },\n  ],\n\n  afterExecute: [\n    async function(this: IHookFunctions): Promise&lt;void&gt; {\n      const staticData = this.getWorkflowStaticData('global');\n\n      // Clean up temporary resources\n      if (staticData.tempFiles) {\n        for (const file of staticData.tempFiles as string[]) {\n          try {\n            await this.helpers.deleteFile(file);\n          } catch (error) {\n            this.logger.warning(`Failed to delete temp file: ${file}`);\n          }\n        }\n        staticData.tempFiles = [];\n      }\n\n      // Clear cache if it gets too large\n      if (staticData.cache &amp;&amp; staticData.cache.size &gt; 1000) {\n        staticData.cache.clear();\n        this.logger.info('Cache cleared due to size limit');\n      }\n    },\n  ],\n\n  onError: [\n    async function(this: IHookFunctions, error: Error): Promise&lt;void&gt; {\n      const staticData = this.getWorkflowStaticData('global');\n\n      // Close database connection on critical errors\n      if (this.isCriticalError(error) &amp;&amp; staticData.dbConnection) {\n        try {\n          await staticData.dbConnection.close();\n          delete staticData.dbConnection;\n          this.logger.info('Database connection closed due to critical error');\n        } catch (closeError) {\n          this.logger.error('Failed to close database connection', { \n            error: closeError.message \n          });\n        }\n      }\n    },\n  ],\n};\n\nprivate isCriticalError(error: Error): boolean {\n  return (\n    error.message.includes('ECONNREFUSED') ||\n    error.message.includes('ETIMEDOUT') ||\n    error.message.includes('Authentication failed')\n  );\n}\n</code></pre>"},{"location":"public-api/execution-contexts/IHookFunctions/#performance-monitoring-hook","title":"Performance Monitoring Hook","text":"<pre><code>hooks = {\n  beforeExecute: [\n    async function(this: IHookFunctions): Promise&lt;void&gt; {\n      const staticData = this.getWorkflowStaticData('global');\n\n      // Initialize performance metrics\n      staticData.performanceMetrics = {\n        startTime: Date.now(),\n        memoryUsage: process.memoryUsage(),\n        nodeExecutionTimes: {},\n      };\n\n      this.logger.debug('Performance monitoring started');\n    },\n  ],\n\n  afterExecute: [\n    async function(this: IHookFunctions, data: IRunExecutionData): Promise&lt;void&gt; {\n      const staticData = this.getWorkflowStaticData('global');\n      const metrics = staticData.performanceMetrics as any;\n\n      if (metrics) {\n        const endTime = Date.now();\n        const executionTime = endTime - metrics.startTime;\n        const endMemoryUsage = process.memoryUsage();\n\n        // Calculate memory delta\n        const memoryDelta = {\n          rss: endMemoryUsage.rss - metrics.memoryUsage.rss,\n          heapUsed: endMemoryUsage.heapUsed - metrics.memoryUsage.heapUsed,\n          heapTotal: endMemoryUsage.heapTotal - metrics.memoryUsage.heapTotal,\n        };\n\n        // Log performance metrics\n        this.logger.info('Performance metrics', {\n          executionTime,\n          memoryDelta,\n          nodeCount: Object.keys(data.resultData.runData || {}).length,\n        });\n\n        // Store historical data\n        const history = staticData.performanceHistory as any[] || [];\n        history.push({\n          timestamp: new Date().toISOString(),\n          executionTime,\n          memoryDelta,\n          success: !data.resultData.error,\n        });\n\n        // Keep only last 100 executions\n        staticData.performanceHistory = history.slice(-100);\n      }\n    },\n  ],\n};\n</code></pre>"},{"location":"public-api/execution-contexts/IHookFunctions/#audit-logging-hook","title":"Audit Logging Hook","text":"<pre><code>hooks = {\n  beforeExecute: [\n    async function(this: IHookFunctions): Promise&lt;void&gt; {\n      const auditLog = {\n        executionId: this.getExecutionId(),\n        workflowId: this.getWorkflow().id,\n        workflowName: this.getWorkflow().name,\n        startTime: new Date().toISOString(),\n        mode: this.getMode(),\n        activationMode: this.getActivationMode(),\n        user: this.getExecutionData()?.userId || 'system',\n      };\n\n      // Store audit log\n      await this.storeAuditLog('execution_started', auditLog);\n    },\n  ],\n\n  afterExecute: [\n    async function(this: IHookFunctions, data: IRunExecutionData): Promise&lt;void&gt; {\n      const auditLog = {\n        executionId: this.getExecutionId(),\n        endTime: new Date().toISOString(),\n        success: !data.resultData.error,\n        nodesExecuted: Object.keys(data.resultData.runData || {}).length,\n        itemsProcessed: this.calculateItemsProcessed(data),\n      };\n\n      await this.storeAuditLog('execution_completed', auditLog);\n    },\n  ],\n\n  onError: [\n    async function(this: IHookFunctions, error: Error): Promise&lt;void&gt; {\n      const auditLog = {\n        executionId: this.getExecutionId(),\n        errorTime: new Date().toISOString(),\n        errorMessage: error.message,\n        errorType: error.constructor.name,\n        stack: error.stack,\n      };\n\n      await this.storeAuditLog('execution_failed', auditLog);\n    },\n  ],\n};\n\nprivate async storeAuditLog(event: string, data: any): Promise&lt;void&gt; {\n  try {\n    const staticData = this.getWorkflowStaticData('global');\n    const auditLogs = staticData.auditLogs as any[] || [];\n\n    auditLogs.push({\n      event,\n      timestamp: new Date().toISOString(),\n      ...data,\n    });\n\n    // Keep only last 1000 audit logs\n    staticData.auditLogs = auditLogs.slice(-1000);\n\n    // Also send to external audit system\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: 'https://audit.example.com/logs',\n      body: { event, ...data },\n      headers: { 'Content-Type': 'application/json' },\n    });\n  } catch (error) {\n    this.logger.warning('Failed to store audit log', { error: error.message });\n  }\n}\n\nprivate calculateItemsProcessed(data: IRunExecutionData): number {\n  let totalItems = 0;\n\n  if (data.resultData.runData) {\n    for (const nodeData of Object.values(data.resultData.runData)) {\n      for (const runData of nodeData) {\n        if (runData.data?.main?.[0]) {\n          totalItems += runData.data.main[0].length;\n        }\n      }\n    }\n  }\n\n  return totalItems;\n}\n</code></pre>"},{"location":"public-api/execution-contexts/IHookFunctions/#rate-limiting-hook","title":"Rate Limiting Hook","text":"<pre><code>hooks = {\n  beforeExecute: [\n    async function(this: IHookFunctions): Promise&lt;void&gt; {\n      const staticData = this.getWorkflowStaticData('global');\n      const maxExecutionsPerHour = this.getNodeParameter('maxExecutionsPerHour', 0) as number;\n\n      if (maxExecutionsPerHour &gt; 0) {\n        const now = Date.now();\n        const oneHourAgo = now - (60 * 60 * 1000);\n\n        // Clean old execution timestamps\n        const executions = (staticData.recentExecutions as number[]) || [];\n        const recentExecutions = executions.filter(time =&gt; time &gt; oneHourAgo);\n\n        // Check rate limit\n        if (recentExecutions.length &gt;= maxExecutionsPerHour) {\n          throw new NodeOperationError(\n            this.getNode(),\n            `Rate limit exceeded: ${maxExecutionsPerHour} executions per hour`\n          );\n        }\n\n        // Add current execution\n        recentExecutions.push(now);\n        staticData.recentExecutions = recentExecutions;\n\n        this.logger.debug('Rate limit check passed', {\n          currentExecutions: recentExecutions.length,\n          maxExecutions: maxExecutionsPerHour,\n        });\n      }\n    },\n  ],\n};\n</code></pre>"},{"location":"public-api/execution-contexts/IHookFunctions/#circuit-breaker-hook","title":"Circuit Breaker Hook","text":"<pre><code>hooks = {\n  beforeExecute: [\n    async function(this: IHookFunctions): Promise&lt;void&gt; {\n      const staticData = this.getWorkflowStaticData('global');\n      const circuitBreaker = staticData.circuitBreaker as any || {\n        state: 'closed',\n        failures: 0,\n        lastFailureTime: 0,\n        maxFailures: 5,\n        timeout: 60000, // 1 minute\n      };\n\n      // Check circuit breaker state\n      if (circuitBreaker.state === 'open') {\n        const timeSinceLastFailure = Date.now() - circuitBreaker.lastFailureTime;\n\n        if (timeSinceLastFailure &gt; circuitBreaker.timeout) {\n          // Move to half-open state\n          circuitBreaker.state = 'half-open';\n          this.logger.info('Circuit breaker moved to half-open state');\n        } else {\n          throw new NodeOperationError(\n            this.getNode(),\n            'Circuit breaker is open - workflow execution blocked'\n          );\n        }\n      }\n\n      staticData.circuitBreaker = circuitBreaker;\n    },\n  ],\n\n  afterExecute: [\n    async function(this: IHookFunctions): Promise&lt;void&gt; {\n      const staticData = this.getWorkflowStaticData('global');\n      const circuitBreaker = staticData.circuitBreaker as any;\n\n      if (circuitBreaker) {\n        // Reset on successful execution\n        circuitBreaker.failures = 0;\n        circuitBreaker.state = 'closed';\n        staticData.circuitBreaker = circuitBreaker;\n\n        this.logger.debug('Circuit breaker reset to closed state');\n      }\n    },\n  ],\n\n  onError: [\n    async function(this: IHookFunctions, error: Error): Promise&lt;void&gt; {\n      const staticData = this.getWorkflowStaticData('global');\n      const circuitBreaker = staticData.circuitBreaker as any;\n\n      if (circuitBreaker) {\n        circuitBreaker.failures++;\n        circuitBreaker.lastFailureTime = Date.now();\n\n        if (circuitBreaker.failures &gt;= circuitBreaker.maxFailures) {\n          circuitBreaker.state = 'open';\n          this.logger.warning('Circuit breaker opened due to repeated failures', {\n            failures: circuitBreaker.failures,\n            maxFailures: circuitBreaker.maxFailures,\n          });\n        }\n\n        staticData.circuitBreaker = circuitBreaker;\n      }\n    },\n  ],\n};\n</code></pre>"},{"location":"public-api/execution-contexts/IHookFunctions/#best-practices","title":"Best Practices","text":""},{"location":"public-api/execution-contexts/IHookFunctions/#1-keep-hooks-lightweight","title":"1. Keep Hooks Lightweight","text":"<pre><code>// \u2705 Good - lightweight and focused\nhooks = {\n  beforeExecute: [\n    async function(this: IHookFunctions): Promise&lt;void&gt; {\n      const staticData = this.getWorkflowStaticData('global');\n      staticData.startTime = Date.now();\n    },\n  ],\n};\n\n// \u274c Bad - heavy operations that slow down execution\nhooks = {\n  beforeExecute: [\n    async function(this: IHookFunctions): Promise&lt;void&gt; {\n      // Don't do heavy operations in hooks\n      await this.processLargeDataset();\n      await this.syncWithExternalSystem();\n    },\n  ],\n};\n</code></pre>"},{"location":"public-api/execution-contexts/IHookFunctions/#2-handle-hook-errors-gracefully","title":"2. Handle Hook Errors Gracefully","text":"<pre><code>hooks = {\n  afterExecute: [\n    async function(this: IHookFunctions): Promise&lt;void&gt; {\n      try {\n        await this.sendNotification();\n      } catch (error) {\n        // Don't let hook errors break the workflow\n        this.logger.warning('Hook notification failed', { error: error.message });\n      }\n    },\n  ],\n};\n</code></pre>"},{"location":"public-api/execution-contexts/IHookFunctions/#3-use-static-data-efficiently","title":"3. Use Static Data Efficiently","text":"<pre><code>hooks = {\n  beforeExecute: [\n    async function(this: IHookFunctions): Promise&lt;void&gt; {\n      const staticData = this.getWorkflowStaticData('global');\n\n      // Initialize only if needed\n      if (!staticData.initialized) {\n        staticData.cache = new Map();\n        staticData.metrics = { executions: 0, errors: 0 };\n        staticData.initialized = true;\n      }\n\n      // Clean up old data periodically\n      if (staticData.metrics.executions % 100 === 0) {\n        this.cleanupOldData(staticData);\n      }\n    },\n  ],\n};\n</code></pre>"},{"location":"public-api/execution-contexts/IHookFunctions/#see-also","title":"See Also","text":"<ul> <li>IExecuteFunctions - Main execution context</li> <li>getWorkflowStaticData - Managing persistent state</li> <li>Error Handling - Robust error management</li> <li>Custom Validation - Input validation patterns</li> </ul>"},{"location":"public-api/execution-contexts/ILoadOptionsFunctions/","title":"ILoadOptionsFunctions","text":"<p>The execution context for loading dynamic options in node parameters. This interface is used when you need to populate dropdown lists, multi-select options, or other dynamic UI elements based on external data sources or user configuration.</p>"},{"location":"public-api/execution-contexts/ILoadOptionsFunctions/#when-to-use","title":"When to Use","text":"<p>Use <code>ILoadOptionsFunctions</code> when: - Populating dropdown options from API responses - Loading dynamic lists based on user credentials - Fetching available resources from external services - Creating dependent dropdowns where one selection affects another</p>"},{"location":"public-api/execution-contexts/ILoadOptionsFunctions/#interface-definition","title":"Interface Definition","text":"<pre><code>interface ILoadOptionsFunctions {\n  getCredentials(type: string): Promise&lt;ICredentialDataDecryptedObject&gt;;\n  getCurrentNodeParameter(parameterName: string): NodeParameterValueType | object | undefined;\n  getCurrentNodeParameters(): INodeParameters | undefined;\n  getNode(): INode;\n  getNodeParameter(parameterName: string, fallbackValue?: any): NodeParameterValueType | object;\n  getTimezone(): string;\n  getRestApiUrl(): string;\n  helpers: {\n    httpRequest(requestOptions: IHttpRequestOptions): Promise&lt;any&gt;;\n    httpRequestWithAuthentication(\n      credentialsType: string,\n      requestOptions: IHttpRequestOptions\n    ): Promise&lt;any&gt;;\n  };\n}\n</code></pre>"},{"location":"public-api/execution-contexts/ILoadOptionsFunctions/#core-methods","title":"Core Methods","text":""},{"location":"public-api/execution-contexts/ILoadOptionsFunctions/#getcurrentnodeparameter","title":"getCurrentNodeParameter()","text":"<p>Gets the current value of a parameter while the user is configuring the node.</p> <pre><code>getCurrentNodeParameter(parameterName: string): NodeParameterValueType | object | undefined\n</code></pre> <p>Parameters: - <code>parameterName</code> - Name of the parameter to retrieve</p> <p>Returns: Current parameter value or <code>undefined</code> if not set</p>"},{"location":"public-api/execution-contexts/ILoadOptionsFunctions/#getcredentials","title":"getCredentials()","text":"<p>Retrieves decrypted credentials for authentication.</p> <pre><code>getCredentials(type: string): Promise&lt;ICredentialDataDecryptedObject&gt;\n</code></pre> <p>Parameters: - <code>type</code> - The credential type name</p> <p>Returns: Promise resolving to decrypted credential data</p>"},{"location":"public-api/execution-contexts/ILoadOptionsFunctions/#implementation-example","title":"Implementation Example","text":"<pre><code>import {\n  ILoadOptionsFunctions,\n  INodeListSearchItems,\n  INodePropertyOptions,\n} from 'n8n-workflow';\n\nexport class DynamicOptionsNode implements INodeType {\n  description: INodeTypeDescription = {\n    displayName: 'Dynamic Options',\n    name: 'dynamicOptions',\n    group: ['transform'],\n    version: 1,\n    description: 'Node with dynamic options',\n    defaults: {\n      name: 'Dynamic Options',\n    },\n    inputs: ['main'],\n    outputs: ['main'],\n    credentials: [\n      {\n        name: 'apiCredentials',\n        required: true,\n      },\n    ],\n    properties: [\n      {\n        displayName: 'Project',\n        name: 'project',\n        type: 'options',\n        typeOptions: {\n          loadOptionsMethod: 'getProjects',\n        },\n        default: '',\n        description: 'Select a project',\n      },\n      {\n        displayName: 'Task',\n        name: 'task',\n        type: 'options',\n        typeOptions: {\n          loadOptionsMethod: 'getTasks',\n          loadOptionsDependsOn: ['project'],\n        },\n        default: '',\n        description: 'Select a task',\n      },\n      {\n        displayName: 'User',\n        name: 'user',\n        type: 'resourceLocator',\n        default: { mode: 'list', value: '' },\n        modes: [\n          {\n            displayName: 'From List',\n            name: 'list',\n            type: 'list',\n            typeOptions: {\n              searchListMethod: 'searchUsers',\n              searchable: true,\n            },\n          },\n          {\n            displayName: 'By ID',\n            name: 'id',\n            type: 'string',\n            validation: [\n              {\n                type: 'regex',\n                properties: {\n                  regex: '^[0-9]+$',\n                  errorMessage: 'User ID must be a number',\n                },\n              },\n            ],\n          },\n        ],\n      },\n    ],\n  };\n\n  methods = {\n    loadOptions: {\n      async getProjects(this: ILoadOptionsFunctions): Promise&lt;INodePropertyOptions[]&gt; {\n        try {\n          const credentials = await this.getCredentials('apiCredentials');\n\n          const response = await this.helpers.httpRequestWithAuthentication(\n            'apiCredentials',\n            {\n              method: 'GET',\n              url: 'https://api.example.com/projects',\n              headers: {\n                'Accept': 'application/json',\n              },\n            }\n          );\n\n          return response.projects.map((project: any) =&gt; ({\n            name: project.name,\n            value: project.id,\n            description: project.description,\n          }));\n        } catch (error) {\n          throw new Error(`Failed to load projects: ${error.message}`);\n        }\n      },\n\n      async getTasks(this: ILoadOptionsFunctions): Promise&lt;INodePropertyOptions[]&gt; {\n        const projectId = this.getCurrentNodeParameter('project');\n\n        if (!projectId) {\n          return [];\n        }\n\n        try {\n          const response = await this.helpers.httpRequestWithAuthentication(\n            'apiCredentials',\n            {\n              method: 'GET',\n              url: `https://api.example.com/projects/${projectId}/tasks`,\n              headers: {\n                'Accept': 'application/json',\n              },\n            }\n          );\n\n          return response.tasks.map((task: any) =&gt; ({\n            name: task.title,\n            value: task.id,\n            description: `Status: ${task.status}`,\n          }));\n        } catch (error) {\n          throw new Error(`Failed to load tasks: ${error.message}`);\n        }\n      },\n    },\n\n    listSearch: {\n      async searchUsers(\n        this: ILoadOptionsFunctions,\n        filter?: string\n      ): Promise&lt;INodeListSearchItems&gt; {\n        try {\n          const qs: any = {};\n          if (filter) {\n            qs.search = filter;\n          }\n\n          const response = await this.helpers.httpRequestWithAuthentication(\n            'apiCredentials',\n            {\n              method: 'GET',\n              url: 'https://api.example.com/users',\n              qs,\n              headers: {\n                'Accept': 'application/json',\n              },\n            }\n          );\n\n          return {\n            results: response.users.map((user: any) =&gt; ({\n              name: `${user.firstName} ${user.lastName}`,\n              value: user.id,\n              url: user.profileUrl,\n            })),\n          };\n        } catch (error) {\n          throw new Error(`Failed to search users: ${error.message}`);\n        }\n      },\n    },\n  };\n}\n</code></pre>"},{"location":"public-api/execution-contexts/ILoadOptionsFunctions/#common-patterns","title":"Common Patterns","text":""},{"location":"public-api/execution-contexts/ILoadOptionsFunctions/#dependent-dropdowns","title":"Dependent Dropdowns","text":"<pre><code>// First dropdown - independent\nasync getCategories(this: ILoadOptionsFunctions): Promise&lt;INodePropertyOptions[]&gt; {\n  const response = await this.helpers.httpRequest({\n    method: 'GET',\n    url: 'https://api.example.com/categories',\n  });\n\n  return response.map((category: any) =&gt; ({\n    name: category.name,\n    value: category.id,\n  }));\n}\n\n// Second dropdown - depends on first\nasync getSubcategories(this: ILoadOptionsFunctions): Promise&lt;INodePropertyOptions[]&gt; {\n  const categoryId = this.getCurrentNodeParameter('category');\n\n  if (!categoryId) {\n    return [];\n  }\n\n  const response = await this.helpers.httpRequest({\n    method: 'GET',\n    url: `https://api.example.com/categories/${categoryId}/subcategories`,\n  });\n\n  return response.map((subcategory: any) =&gt; ({\n    name: subcategory.name,\n    value: subcategory.id,\n  }));\n}\n</code></pre>"},{"location":"public-api/execution-contexts/ILoadOptionsFunctions/#credential-based-options","title":"Credential-Based Options","text":"<pre><code>async getDatabases(this: ILoadOptionsFunctions): Promise&lt;INodePropertyOptions[]&gt; {\n  try {\n    const credentials = await this.getCredentials('databaseCredentials');\n\n    // Validate credentials are present\n    if (!credentials.host || !credentials.username) {\n      throw new Error('Database credentials are incomplete');\n    }\n\n    const response = await this.helpers.httpRequestWithAuthentication(\n      'databaseCredentials',\n      {\n        method: 'GET',\n        url: `https://${credentials.host}/api/databases`,\n        headers: {\n          'Accept': 'application/json',\n        },\n      }\n    );\n\n    return response.databases.map((db: any) =&gt; ({\n      name: db.displayName || db.name,\n      value: db.name,\n      description: `Type: ${db.type}, Size: ${db.size}`,\n    }));\n  } catch (error) {\n    // Return empty array instead of throwing to prevent UI errors\n    console.error('Failed to load databases:', error.message);\n    return [];\n  }\n}\n</code></pre>"},{"location":"public-api/execution-contexts/ILoadOptionsFunctions/#searchable-resource-lists","title":"Searchable Resource Lists","text":"<pre><code>async searchRepositories(\n  this: ILoadOptionsFunctions,\n  filter?: string\n): Promise&lt;INodeListSearchItems&gt; {\n  const credentials = await this.getCredentials('githubCredentials');\n\n  const qs: any = {\n    per_page: 50,\n    sort: 'updated',\n    order: 'desc',\n  };\n\n  if (filter) {\n    qs.q = `${filter} user:${credentials.username}`;\n  } else {\n    qs.q = `user:${credentials.username}`;\n  }\n\n  try {\n    const response = await this.helpers.httpRequestWithAuthentication(\n      'githubCredentials',\n      {\n        method: 'GET',\n        url: 'https://api.github.com/search/repositories',\n        qs,\n        headers: {\n          'Accept': 'application/vnd.github.v3+json',\n          'User-Agent': 'n8n',\n        },\n      }\n    );\n\n    return {\n      results: response.items.map((repo: any) =&gt; ({\n        name: repo.full_name,\n        value: repo.name,\n        url: repo.html_url,\n      })),\n    };\n  } catch (error) {\n    throw new Error(`Failed to search repositories: ${error.message}`);\n  }\n}\n</code></pre>"},{"location":"public-api/execution-contexts/ILoadOptionsFunctions/#cached-options-loading","title":"Cached Options Loading","text":"<pre><code>// Cache for expensive API calls\nconst optionsCache = new Map&lt;string, { data: INodePropertyOptions[]; timestamp: number }&gt;();\nconst CACHE_DURATION = 5 * 60 * 1000; // 5 minutes\n\nasync getRegions(this: ILoadOptionsFunctions): Promise&lt;INodePropertyOptions[]&gt; {\n  const cacheKey = 'regions';\n  const cached = optionsCache.get(cacheKey);\n\n  // Return cached data if still valid\n  if (cached &amp;&amp; Date.now() - cached.timestamp &lt; CACHE_DURATION) {\n    return cached.data;\n  }\n\n  try {\n    const response = await this.helpers.httpRequestWithAuthentication(\n      'awsCredentials',\n      {\n        method: 'GET',\n        url: 'https://api.aws.amazon.com/regions',\n      }\n    );\n\n    const options = response.regions.map((region: any) =&gt; ({\n      name: `${region.name} (${region.code})`,\n      value: region.code,\n    }));\n\n    // Cache the results\n    optionsCache.set(cacheKey, {\n      data: options,\n      timestamp: Date.now(),\n    });\n\n    return options;\n  } catch (error) {\n    // Return cached data if available, even if expired\n    if (cached) {\n      return cached.data;\n    }\n    throw new Error(`Failed to load regions: ${error.message}`);\n  }\n}\n</code></pre>"},{"location":"public-api/execution-contexts/ILoadOptionsFunctions/#error-handling","title":"Error Handling","text":""},{"location":"public-api/execution-contexts/ILoadOptionsFunctions/#graceful-degradation","title":"Graceful Degradation","text":"<pre><code>async getOptions(this: ILoadOptionsFunctions): Promise&lt;INodePropertyOptions[]&gt; {\n  try {\n    // Try to load from primary source\n    return await this.loadFromPrimarySource();\n  } catch (primaryError) {\n    try {\n      // Fallback to secondary source\n      return await this.loadFromSecondarySource();\n    } catch (secondaryError) {\n      // Return static fallback options\n      return [\n        { name: 'Default Option 1', value: 'default1' },\n        { name: 'Default Option 2', value: 'default2' },\n      ];\n    }\n  }\n}\n</code></pre>"},{"location":"public-api/execution-contexts/ILoadOptionsFunctions/#user-friendly-error-messages","title":"User-Friendly Error Messages","text":"<pre><code>async getProjects(this: ILoadOptionsFunctions): Promise&lt;INodePropertyOptions[]&gt; {\n  try {\n    const credentials = await this.getCredentials('apiCredentials');\n\n    if (!credentials.apiKey) {\n      throw new Error('API key is required. Please configure your credentials.');\n    }\n\n    const response = await this.helpers.httpRequestWithAuthentication(\n      'apiCredentials',\n      {\n        method: 'GET',\n        url: 'https://api.example.com/projects',\n        timeout: 10000, // 10 second timeout\n      }\n    );\n\n    if (!response.projects || !Array.isArray(response.projects)) {\n      throw new Error('Invalid response format from API');\n    }\n\n    return response.projects.map((project: any) =&gt; ({\n      name: project.name || 'Unnamed Project',\n      value: project.id,\n    }));\n  } catch (error) {\n    if (error.code === 'ENOTFOUND') {\n      throw new Error('Unable to connect to API. Please check your network connection.');\n    }\n    if (error.response?.status === 401) {\n      throw new Error('Authentication failed. Please check your API credentials.');\n    }\n    if (error.response?.status === 403) {\n      throw new Error('Access denied. Please check your API permissions.');\n    }\n    throw new Error(`Failed to load projects: ${error.message}`);\n  }\n}\n</code></pre>"},{"location":"public-api/execution-contexts/ILoadOptionsFunctions/#performance-optimization","title":"Performance Optimization","text":""},{"location":"public-api/execution-contexts/ILoadOptionsFunctions/#debounced-search","title":"Debounced Search","text":"<pre><code>// Implement debouncing for search operations\nlet searchTimeout: NodeJS.Timeout;\n\nasync searchItems(\n  this: ILoadOptionsFunctions,\n  filter?: string\n): Promise&lt;INodeListSearchItems&gt; {\n  return new Promise((resolve, reject) =&gt; {\n    // Clear previous timeout\n    if (searchTimeout) {\n      clearTimeout(searchTimeout);\n    }\n\n    // Debounce search requests\n    searchTimeout = setTimeout(async () =&gt; {\n      try {\n        const response = await this.helpers.httpRequest({\n          method: 'GET',\n          url: 'https://api.example.com/search',\n          qs: { q: filter, limit: 50 },\n        });\n\n        resolve({\n          results: response.items.map((item: any) =&gt; ({\n            name: item.name,\n            value: item.id,\n          })),\n        });\n      } catch (error) {\n        reject(error);\n      }\n    }, 300); // 300ms debounce\n  });\n}\n</code></pre>"},{"location":"public-api/execution-contexts/ILoadOptionsFunctions/#pagination-support","title":"Pagination Support","text":"<pre><code>async searchLargeDataset(\n  this: ILoadOptionsFunctions,\n  filter?: string,\n  paginationToken?: string\n): Promise&lt;INodeListSearchItems&gt; {\n  const qs: any = {\n    limit: 100,\n    search: filter || '',\n  };\n\n  if (paginationToken) {\n    qs.cursor = paginationToken;\n  }\n\n  const response = await this.helpers.httpRequest({\n    method: 'GET',\n    url: 'https://api.example.com/items',\n    qs,\n  });\n\n  return {\n    results: response.items.map((item: any) =&gt; ({\n      name: item.name,\n      value: item.id,\n    })),\n    paginationToken: response.nextCursor,\n  };\n}\n</code></pre>"},{"location":"public-api/execution-contexts/ILoadOptionsFunctions/#best-practices","title":"Best Practices","text":""},{"location":"public-api/execution-contexts/ILoadOptionsFunctions/#1-always-handle-missing-dependencies","title":"1. Always Handle Missing Dependencies","text":"<pre><code>async getDependentOptions(this: ILoadOptionsFunctions): Promise&lt;INodePropertyOptions[]&gt; {\n  const parentValue = this.getCurrentNodeParameter('parentField');\n\n  // Return empty array if dependency is not set\n  if (!parentValue) {\n    return [];\n  }\n\n  // Proceed with loading dependent options\n  return await this.loadDependentOptions(parentValue);\n}\n</code></pre>"},{"location":"public-api/execution-contexts/ILoadOptionsFunctions/#2-provide-meaningful-option-names","title":"2. Provide Meaningful Option Names","text":"<pre><code>// \u2705 Good - descriptive names\nreturn response.users.map((user: any) =&gt; ({\n  name: `${user.firstName} ${user.lastName} (${user.email})`,\n  value: user.id,\n  description: `Role: ${user.role}, Department: ${user.department}`,\n}));\n\n// \u274c Bad - unclear names\nreturn response.users.map((user: any) =&gt; ({\n  name: user.id,\n  value: user.id,\n}));\n</code></pre>"},{"location":"public-api/execution-contexts/ILoadOptionsFunctions/#3-use-type-safety","title":"3. Use Type Safety","text":"<pre><code>interface ApiProject {\n  id: string;\n  name: string;\n  description?: string;\n  status: 'active' | 'inactive';\n}\n\nasync getProjects(this: ILoadOptionsFunctions): Promise&lt;INodePropertyOptions[]&gt; {\n  const response = await this.helpers.httpRequest({\n    method: 'GET',\n    url: 'https://api.example.com/projects',\n  });\n\n  const projects = response.projects as ApiProject[];\n\n  return projects\n    .filter(project =&gt; project.status === 'active')\n    .map(project =&gt; ({\n      name: project.name,\n      value: project.id,\n      description: project.description,\n    }));\n}\n</code></pre>"},{"location":"public-api/execution-contexts/ILoadOptionsFunctions/#see-also","title":"See Also","text":"<ul> <li>IExecuteFunctions - Main execution context</li> <li>getCurrentNodeParameter - Getting current parameter values</li> <li>HTTP Helpers - Making HTTP requests</li> <li>Dynamic Options - UI patterns for dynamic options</li> </ul>"},{"location":"public-api/execution-contexts/IPollFunctions/","title":"IPollFunctions","text":"<p>The execution context for polling trigger nodes that periodically check for new data. This interface is used when your trigger node needs to regularly poll an external service for changes or new items.</p>"},{"location":"public-api/execution-contexts/IPollFunctions/#when-to-use","title":"When to Use","text":"<p>Use <code>IPollFunctions</code> when: - Creating trigger nodes that poll APIs for new data - Implementing scheduled data fetching - Building nodes that check for file system changes - Creating nodes that monitor external resources periodically</p>"},{"location":"public-api/execution-contexts/IPollFunctions/#interface-definition","title":"Interface Definition","text":"<pre><code>interface IPollFunctions extends IExecuteFunctions {\n  getMode(): WorkflowExecuteMode;\n  getActivationMode(): WorkflowActivateMode;\n  __emit(data: INodeExecutionData[][]): void;\n  __emitError(error: Error, responseData?: IDataObject): void;\n  helpers: IPollFunctionsHelpers;\n}\n</code></pre>"},{"location":"public-api/execution-contexts/IPollFunctions/#core-methods","title":"Core Methods","text":""},{"location":"public-api/execution-contexts/IPollFunctions/#__emit","title":"__emit()","text":"<p>Emits data when new items are found during polling.</p> <pre><code>__emit(data: INodeExecutionData[][]): void\n</code></pre> <p>Parameters: - <code>data</code> - Array of execution data arrays to emit</p>"},{"location":"public-api/execution-contexts/IPollFunctions/#__emiterror","title":"__emitError()","text":"<p>Emits an error when polling fails.</p> <pre><code>__emitError(error: Error, responseData?: IDataObject): void\n</code></pre> <p>Parameters: - <code>error</code> - The error that occurred - <code>responseData</code> - Optional additional error context</p>"},{"location":"public-api/execution-contexts/IPollFunctions/#getmode","title":"getMode()","text":"<p>Returns the current workflow execution mode.</p> <pre><code>getMode(): WorkflowExecuteMode\n</code></pre> <p>Returns: The execution mode ('poll', 'trigger', 'manual', etc.)</p>"},{"location":"public-api/execution-contexts/IPollFunctions/#getactivationmode","title":"getActivationMode()","text":"<p>Returns how the workflow was activated.</p> <pre><code>getActivationMode(): WorkflowActivateMode\n</code></pre> <p>Returns: The activation mode ('init', 'create', 'update', etc.)</p>"},{"location":"public-api/execution-contexts/IPollFunctions/#implementation-example","title":"Implementation Example","text":"<pre><code>import {\n  IPollFunctions,\n  INodeExecutionData,\n  INodeType,\n  INodeTypeDescription,\n  NodeOperationError,\n} from 'n8n-workflow';\n\nexport class ApiPollerTrigger implements INodeType {\n  description: INodeTypeDescription = {\n    displayName: 'API Poller',\n    name: 'apiPoller',\n    icon: 'fa:clock',\n    group: ['trigger'],\n    version: 1,\n    description: 'Polls an API for new data',\n    defaults: {\n      name: 'API Poller',\n    },\n    inputs: [],\n    outputs: ['main'],\n    credentials: [\n      {\n        name: 'apiCredentials',\n        required: true,\n      },\n    ],\n    polling: true,\n    properties: [\n      {\n        displayName: 'Endpoint',\n        name: 'endpoint',\n        type: 'string',\n        default: '',\n        required: true,\n        description: 'API endpoint to poll',\n      },\n      {\n        displayName: 'Poll Interval',\n        name: 'pollInterval',\n        type: 'number',\n        default: 60,\n        description: 'How often to poll in seconds',\n      },\n      {\n        displayName: 'Date Field',\n        name: 'dateField',\n        type: 'string',\n        default: 'created_at',\n        description: 'Field to use for tracking new items',\n      },\n    ],\n  };\n\n  async poll(this: IPollFunctions): Promise&lt;INodeExecutionData[][] | null&gt; {\n    const endpoint = this.getNodeParameter('endpoint', 0) as string;\n    const dateField = this.getNodeParameter('dateField', 0) as string;\n\n    try {\n      // Get the last poll time from workflow static data\n      const workflowStaticData = this.getWorkflowStaticData('node');\n      const lastPollTime = workflowStaticData.lastPollTime as string;\n\n      // Build query parameters\n      const qs: any = {};\n      if (lastPollTime) {\n        qs.since = lastPollTime;\n      }\n\n      // Make the API request\n      const response = await this.helpers.httpRequestWithAuthentication(\n        'apiCredentials',\n        {\n          method: 'GET',\n          url: endpoint,\n          qs,\n          headers: {\n            'Accept': 'application/json',\n          },\n        }\n      );\n\n      // Process the response\n      const items = response.data || response.items || response;\n\n      if (!Array.isArray(items) || items.length === 0) {\n        return null; // No new data\n      }\n\n      // Filter for new items\n      const newItems = this.filterNewItems(items, lastPollTime, dateField);\n\n      if (newItems.length === 0) {\n        return null; // No new items\n      }\n\n      // Update the last poll time\n      const latestItem = newItems[0];\n      const latestTimestamp = latestItem[dateField];\n      if (latestTimestamp) {\n        workflowStaticData.lastPollTime = latestTimestamp;\n      }\n\n      // Convert to execution data\n      const executionData: INodeExecutionData[] = newItems.map(item =&gt; ({\n        json: item,\n      }));\n\n      return [executionData];\n    } catch (error) {\n      if (this.getMode() === 'manual') {\n        // In manual mode, throw the error to show in UI\n        throw new NodeOperationError(\n          this.getNode(),\n          `Failed to poll API: ${error.message}`\n        );\n      } else {\n        // In automatic mode, emit error but don't stop polling\n        this.__emitError(error, { endpoint });\n        return null;\n      }\n    }\n  }\n\n  private filterNewItems(items: any[], lastPollTime: string | undefined, dateField: string): any[] {\n    if (!lastPollTime) {\n      // First poll - return all items\n      return items;\n    }\n\n    const lastPollDate = new Date(lastPollTime);\n\n    return items.filter(item =&gt; {\n      const itemDate = new Date(item[dateField]);\n      return itemDate &gt; lastPollDate;\n    });\n  }\n}\n</code></pre>"},{"location":"public-api/execution-contexts/IPollFunctions/#common-patterns","title":"Common Patterns","text":""},{"location":"public-api/execution-contexts/IPollFunctions/#database-polling","title":"Database Polling","text":"<pre><code>async poll(this: IPollFunctions): Promise&lt;INodeExecutionData[][] | null&gt; {\n  const tableName = this.getNodeParameter('tableName', 0) as string;\n  const workflowStaticData = this.getWorkflowStaticData('node');\n\n  try {\n    // Get last processed ID\n    const lastId = workflowStaticData.lastId as number || 0;\n\n    // Query for new records\n    const query = `\n      SELECT * FROM ${tableName} \n      WHERE id &gt; ? \n      ORDER BY id ASC \n      LIMIT 100\n    `;\n\n    const records = await this.helpers.dbQuery(query, [lastId]);\n\n    if (records.length === 0) {\n      return null;\n    }\n\n    // Update last processed ID\n    const lastRecord = records[records.length - 1];\n    workflowStaticData.lastId = lastRecord.id;\n\n    // Convert to execution data\n    const executionData: INodeExecutionData[] = records.map(record =&gt; ({\n      json: record,\n    }));\n\n    return [executionData];\n  } catch (error) {\n    this.__emitError(error, { table: tableName });\n    return null;\n  }\n}\n</code></pre>"},{"location":"public-api/execution-contexts/IPollFunctions/#file-system-polling","title":"File System Polling","text":"<pre><code>async poll(this: IPollFunctions): Promise&lt;INodeExecutionData[][] | null&gt; {\n  const watchPath = this.getNodeParameter('watchPath', 0) as string;\n  const workflowStaticData = this.getWorkflowStaticData('node');\n\n  try {\n    // Get list of files\n    const files = await this.helpers.listFiles(watchPath);\n\n    // Get previously seen files\n    const seenFiles = new Set(workflowStaticData.seenFiles as string[] || []);\n\n    // Find new files\n    const newFiles = files.filter(file =&gt; !seenFiles.has(file.path));\n\n    if (newFiles.length === 0) {\n      return null;\n    }\n\n    // Update seen files\n    workflowStaticData.seenFiles = files.map(f =&gt; f.path);\n\n    // Process new files\n    const executionData: INodeExecutionData[] = [];\n\n    for (const file of newFiles) {\n      const fileData = await this.helpers.readFile(file.path);\n\n      executionData.push({\n        json: {\n          fileName: file.name,\n          filePath: file.path,\n          size: file.size,\n          modified: file.modified,\n        },\n        binary: {\n          data: await this.helpers.prepareBinaryData(\n            fileData,\n            file.name\n          ),\n        },\n      });\n    }\n\n    return [executionData];\n  } catch (error) {\n    this.__emitError(error, { watchPath });\n    return null;\n  }\n}\n</code></pre>"},{"location":"public-api/execution-contexts/IPollFunctions/#rss-feed-polling","title":"RSS Feed Polling","text":"<pre><code>async poll(this: IPollFunctions): Promise&lt;INodeExecutionData[][] | null&gt; {\n  const feedUrl = this.getNodeParameter('feedUrl', 0) as string;\n  const workflowStaticData = this.getWorkflowStaticData('node');\n\n  try {\n    // Fetch RSS feed\n    const response = await this.helpers.httpRequest({\n      method: 'GET',\n      url: feedUrl,\n      headers: {\n        'Accept': 'application/rss+xml, application/xml, text/xml',\n      },\n    });\n\n    // Parse RSS feed\n    const feed = await this.helpers.parseXml(response);\n    const items = feed.rss.channel.item || [];\n\n    // Get last seen GUID\n    const lastGuid = workflowStaticData.lastGuid as string;\n\n    // Find new items\n    const newItems = [];\n    for (const item of items) {\n      if (item.guid === lastGuid) {\n        break; // Found last seen item, stop here\n      }\n      newItems.push(item);\n    }\n\n    if (newItems.length === 0) {\n      return null;\n    }\n\n    // Update last seen GUID\n    if (newItems.length &gt; 0) {\n      workflowStaticData.lastGuid = newItems[0].guid;\n    }\n\n    // Convert to execution data\n    const executionData: INodeExecutionData[] = newItems.map(item =&gt; ({\n      json: {\n        title: item.title,\n        description: item.description,\n        link: item.link,\n        pubDate: item.pubDate,\n        guid: item.guid,\n      },\n    }));\n\n    return [executionData];\n  } catch (error) {\n    this.__emitError(error, { feedUrl });\n    return null;\n  }\n}\n</code></pre>"},{"location":"public-api/execution-contexts/IPollFunctions/#webhook-status-polling","title":"Webhook Status Polling","text":"<pre><code>async poll(this: IPollFunctions): Promise&lt;INodeExecutionData[][] | null&gt; {\n  const webhookUrl = this.getNodeParameter('webhookUrl', 0) as string;\n  const workflowStaticData = this.getWorkflowStaticData('node');\n\n  try {\n    // Check webhook deliveries\n    const response = await this.helpers.httpRequestWithAuthentication(\n      'webhookCredentials',\n      {\n        method: 'GET',\n        url: `${webhookUrl}/deliveries`,\n        qs: {\n          per_page: 50,\n          since: workflowStaticData.lastDeliveryId || '',\n        },\n      }\n    );\n\n    const deliveries = response.deliveries || [];\n\n    if (deliveries.length === 0) {\n      return null;\n    }\n\n    // Filter for failed deliveries\n    const failedDeliveries = deliveries.filter(\n      (delivery: any) =&gt; delivery.status !== 'success'\n    );\n\n    if (failedDeliveries.length === 0) {\n      // Update last delivery ID even if no failures\n      workflowStaticData.lastDeliveryId = deliveries[0].id;\n      return null;\n    }\n\n    // Update last delivery ID\n    workflowStaticData.lastDeliveryId = deliveries[0].id;\n\n    // Convert to execution data\n    const executionData: INodeExecutionData[] = failedDeliveries.map(delivery =&gt; ({\n      json: {\n        id: delivery.id,\n        status: delivery.status,\n        error: delivery.error,\n        timestamp: delivery.timestamp,\n        payload: delivery.payload,\n      },\n    }));\n\n    return [executionData];\n  } catch (error) {\n    this.__emitError(error, { webhookUrl });\n    return null;\n  }\n}\n</code></pre>"},{"location":"public-api/execution-contexts/IPollFunctions/#state-management","title":"State Management","text":""},{"location":"public-api/execution-contexts/IPollFunctions/#using-workflow-static-data","title":"Using Workflow Static Data","text":"<pre><code>async poll(this: IPollFunctions): Promise&lt;INodeExecutionData[][] | null&gt; {\n  // Get persistent state\n  const workflowStaticData = this.getWorkflowStaticData('node');\n\n  // Initialize state if needed\n  if (!workflowStaticData.initialized) {\n    workflowStaticData.initialized = true;\n    workflowStaticData.lastPollTime = new Date().toISOString();\n    workflowStaticData.processedItems = [];\n  }\n\n  // Use state in polling logic\n  const lastPollTime = workflowStaticData.lastPollTime as string;\n  const processedItems = workflowStaticData.processedItems as string[];\n\n  // ... polling logic ...\n\n  // Update state\n  workflowStaticData.lastPollTime = new Date().toISOString();\n  workflowStaticData.processedItems = [...processedItems, ...newItemIds];\n\n  return [executionData];\n}\n</code></pre>"},{"location":"public-api/execution-contexts/IPollFunctions/#handling-state-corruption","title":"Handling State Corruption","text":"<pre><code>async poll(this: IPollFunctions): Promise&lt;INodeExecutionData[][] | null&gt; {\n  const workflowStaticData = this.getWorkflowStaticData('node');\n\n  try {\n    // Validate state\n    if (!this.isValidState(workflowStaticData)) {\n      // Reset corrupted state\n      this.resetState(workflowStaticData);\n    }\n\n    // ... polling logic ...\n  } catch (error) {\n    // Reset state on critical errors\n    if (this.isCriticalError(error)) {\n      this.resetState(workflowStaticData);\n    }\n\n    this.__emitError(error);\n    return null;\n  }\n}\n\nprivate isValidState(state: any): boolean {\n  return (\n    state &amp;&amp;\n    typeof state.lastPollTime === 'string' &amp;&amp;\n    Array.isArray(state.processedItems)\n  );\n}\n\nprivate resetState(state: any): void {\n  state.lastPollTime = new Date().toISOString();\n  state.processedItems = [];\n  state.initialized = true;\n}\n\nprivate isCriticalError(error: any): boolean {\n  return (\n    error.code === 'ENOTFOUND' ||\n    error.response?.status === 401 ||\n    error.response?.status === 403\n  );\n}\n</code></pre>"},{"location":"public-api/execution-contexts/IPollFunctions/#error-handling","title":"Error Handling","text":""},{"location":"public-api/execution-contexts/IPollFunctions/#graceful-error-recovery","title":"Graceful Error Recovery","text":"<pre><code>async poll(this: IPollFunctions): Promise&lt;INodeExecutionData[][] | null&gt; {\n  const maxRetries = 3;\n  const workflowStaticData = this.getWorkflowStaticData('node');\n\n  for (let attempt = 1; attempt &lt;= maxRetries; attempt++) {\n    try {\n      // Polling logic\n      const result = await this.performPoll();\n\n      // Reset error count on success\n      workflowStaticData.errorCount = 0;\n\n      return result;\n    } catch (error) {\n      const errorCount = (workflowStaticData.errorCount as number) || 0;\n      workflowStaticData.errorCount = errorCount + 1;\n\n      if (attempt === maxRetries) {\n        // Max retries reached\n        this.__emitError(error, {\n          attempt,\n          totalErrors: workflowStaticData.errorCount,\n        });\n\n        // Exponential backoff for next poll\n        workflowStaticData.backoffUntil = Date.now() + (Math.pow(2, errorCount) * 1000);\n\n        return null;\n      }\n\n      // Wait before retry\n      await this.helpers.sleep(1000 * attempt);\n    }\n  }\n\n  return null;\n}\n</code></pre>"},{"location":"public-api/execution-contexts/IPollFunctions/#rate-limiting-handling","title":"Rate Limiting Handling","text":"<pre><code>async poll(this: IPollFunctions): Promise&lt;INodeExecutionData[][] | null&gt; {\n  const workflowStaticData = this.getWorkflowStaticData('node');\n\n  // Check if we're in backoff period\n  const backoffUntil = workflowStaticData.backoffUntil as number;\n  if (backoffUntil &amp;&amp; Date.now() &lt; backoffUntil) {\n    return null; // Skip this poll\n  }\n\n  try {\n    const response = await this.helpers.httpRequest({\n      method: 'GET',\n      url: 'https://api.example.com/data',\n    });\n\n    // Reset backoff on success\n    delete workflowStaticData.backoffUntil;\n\n    return this.processResponse(response);\n  } catch (error) {\n    if (error.response?.status === 429) {\n      // Rate limited\n      const retryAfter = error.response.headers['retry-after'];\n      const backoffTime = retryAfter ? parseInt(retryAfter) * 1000 : 60000;\n\n      workflowStaticData.backoffUntil = Date.now() + backoffTime;\n\n      this.__emitError(\n        new Error(`Rate limited. Will retry after ${backoffTime / 1000} seconds`),\n        { retryAfter: backoffTime }\n      );\n    } else {\n      this.__emitError(error);\n    }\n\n    return null;\n  }\n}\n</code></pre>"},{"location":"public-api/execution-contexts/IPollFunctions/#performance-optimization","title":"Performance Optimization","text":""},{"location":"public-api/execution-contexts/IPollFunctions/#efficient-data-processing","title":"Efficient Data Processing","text":"<pre><code>async poll(this: IPollFunctions): Promise&lt;INodeExecutionData[][] | null&gt; {\n  const batchSize = this.getNodeParameter('batchSize', 0, 100) as number;\n\n  try {\n    // Fetch data in batches\n    const allItems = await this.fetchAllNewItems();\n\n    if (allItems.length === 0) {\n      return null;\n    }\n\n    // Process in batches to avoid memory issues\n    const batches: INodeExecutionData[][] = [];\n\n    for (let i = 0; i &lt; allItems.length; i += batchSize) {\n      const batch = allItems.slice(i, i + batchSize);\n      const executionData = batch.map(item =&gt; ({ json: item }));\n      batches.push(executionData);\n    }\n\n    // Emit each batch separately\n    for (const batch of batches) {\n      this.__emit([batch]);\n    }\n\n    return null; // Already emitted\n  } catch (error) {\n    this.__emitError(error);\n    return null;\n  }\n}\n</code></pre>"},{"location":"public-api/execution-contexts/IPollFunctions/#memory-management","title":"Memory Management","text":"<pre><code>async poll(this: IPollFunctions): Promise&lt;INodeExecutionData[][] | null&gt; {\n  const workflowStaticData = this.getWorkflowStaticData('node');\n\n  try {\n    // Limit state size to prevent memory leaks\n    const processedItems = workflowStaticData.processedItems as string[] || [];\n\n    // Keep only last 1000 processed items\n    if (processedItems.length &gt; 1000) {\n      workflowStaticData.processedItems = processedItems.slice(-1000);\n    }\n\n    // Stream large responses\n    const response = await this.helpers.httpRequestStream({\n      method: 'GET',\n      url: 'https://api.example.com/large-dataset',\n    });\n\n    const items = await this.processStreamResponse(response);\n\n    return [items];\n  } catch (error) {\n    this.__emitError(error);\n    return null;\n  }\n}\n</code></pre>"},{"location":"public-api/execution-contexts/IPollFunctions/#best-practices","title":"Best Practices","text":""},{"location":"public-api/execution-contexts/IPollFunctions/#1-always-handle-first-poll","title":"1. Always Handle First Poll","text":"<pre><code>async poll(this: IPollFunctions): Promise&lt;INodeExecutionData[][] | null&gt; {\n  const workflowStaticData = this.getWorkflowStaticData('node');\n  const isFirstPoll = !workflowStaticData.lastPollTime;\n\n  if (isFirstPoll) {\n    // On first poll, just set the timestamp and return\n    workflowStaticData.lastPollTime = new Date().toISOString();\n    return null;\n  }\n\n  // Normal polling logic\n  return await this.performNormalPoll();\n}\n</code></pre>"},{"location":"public-api/execution-contexts/IPollFunctions/#2-use-proper-deduplication","title":"2. Use Proper Deduplication","text":"<pre><code>private isDuplicate(item: any, processedItems: string[]): boolean {\n  const itemId = item.id || item.guid || JSON.stringify(item);\n  return processedItems.includes(itemId);\n}\n\nasync poll(this: IPollFunctions): Promise&lt;INodeExecutionData[][] | null&gt; {\n  const workflowStaticData = this.getWorkflowStaticData('node');\n  const processedItems = workflowStaticData.processedItems as string[] || [];\n\n  const newItems = items.filter(item =&gt; !this.isDuplicate(item, processedItems));\n\n  if (newItems.length &gt; 0) {\n    // Update processed items\n    const newItemIds = newItems.map(item =&gt; item.id || item.guid || JSON.stringify(item));\n    workflowStaticData.processedItems = [...processedItems, ...newItemIds];\n  }\n\n  return newItems.length &gt; 0 ? [newItems.map(item =&gt; ({ json: item }))] : null;\n}\n</code></pre>"},{"location":"public-api/execution-contexts/IPollFunctions/#3-implement-proper-logging","title":"3. Implement Proper Logging","text":"<pre><code>async poll(this: IPollFunctions): Promise&lt;INodeExecutionData[][] | null&gt; {\n  const startTime = Date.now();\n\n  try {\n    const result = await this.performPoll();\n\n    // Log successful poll\n    console.log(`Poll completed in ${Date.now() - startTime}ms, found ${result?.[0]?.length || 0} items`);\n\n    return result;\n  } catch (error) {\n    // Log error with context\n    console.error(`Poll failed after ${Date.now() - startTime}ms:`, {\n      error: error.message,\n      node: this.getNode().name,\n      workflow: this.getWorkflow().name,\n    });\n\n    this.__emitError(error);\n    return null;\n  }\n}\n</code></pre>"},{"location":"public-api/execution-contexts/IPollFunctions/#see-also","title":"See Also","text":"<ul> <li>IExecuteFunctions - Main execution context</li> <li>ITriggerFunctions - Event-based triggers</li> <li>getWorkflowStaticData - Managing persistent state</li> <li>HTTP Helpers - Making HTTP requests</li> </ul>"},{"location":"public-api/execution-contexts/ITriggerFunctions/","title":"ITriggerFunctions","text":"<p>The execution context for event-driven trigger nodes that respond to external events in real-time. This interface is used when your trigger node needs to listen for webhooks, WebSocket connections, or other real-time event sources.</p>"},{"location":"public-api/execution-contexts/ITriggerFunctions/#when-to-use","title":"When to Use","text":"<p>Use <code>ITriggerFunctions</code> when: - Creating webhook receivers - Building WebSocket listeners - Implementing real-time event handlers - Creating nodes that respond to external notifications</p>"},{"location":"public-api/execution-contexts/ITriggerFunctions/#interface-definition","title":"Interface Definition","text":"<pre><code>interface ITriggerFunctions extends IExecuteFunctions {\n  emit(data: INodeExecutionData[][]): void;\n  emitError(error: Error, responseData?: IDataObject): void;\n  getMode(): WorkflowExecuteMode;\n  getActivationMode(): WorkflowActivateMode;\n  helpers: ITriggerFunctionsHelpers;\n}\n</code></pre>"},{"location":"public-api/execution-contexts/ITriggerFunctions/#core-methods","title":"Core Methods","text":""},{"location":"public-api/execution-contexts/ITriggerFunctions/#emit","title":"emit()","text":"<p>Emits data when an event is received.</p> <pre><code>emit(data: INodeExecutionData[][]): void\n</code></pre> <p>Parameters: - <code>data</code> - Array of execution data arrays to emit</p>"},{"location":"public-api/execution-contexts/ITriggerFunctions/#emiterror","title":"emitError()","text":"<p>Emits an error when event processing fails.</p> <pre><code>emitError(error: Error, responseData?: IDataObject): void\n</code></pre> <p>Parameters: - <code>error</code> - The error that occurred - <code>responseData</code> - Optional additional error context</p>"},{"location":"public-api/execution-contexts/ITriggerFunctions/#getmode","title":"getMode()","text":"<p>Returns the current workflow execution mode.</p> <pre><code>getMode(): WorkflowExecuteMode\n</code></pre> <p>Returns: The execution mode ('trigger', 'manual', etc.)</p>"},{"location":"public-api/execution-contexts/ITriggerFunctions/#getactivationmode","title":"getActivationMode()","text":"<p>Returns how the workflow was activated.</p> <pre><code>getActivationMode(): WorkflowActivateMode\n</code></pre> <p>Returns: The activation mode ('init', 'create', 'update', etc.)</p>"},{"location":"public-api/execution-contexts/ITriggerFunctions/#implementation-example","title":"Implementation Example","text":"<pre><code>import {\n  ITriggerFunctions,\n  INodeExecutionData,\n  INodeType,\n  INodeTypeDescription,\n  ITriggerResponse,\n  NodeOperationError,\n} from 'n8n-workflow';\nimport { createServer, IncomingMessage, ServerResponse } from 'http';\n\nexport class WebhookTrigger implements INodeType {\n  description: INodeTypeDescription = {\n    displayName: 'Webhook Trigger',\n    name: 'webhookTrigger',\n    icon: 'fa:satellite-dish',\n    group: ['trigger'],\n    version: 1,\n    description: 'Receives webhook events',\n    defaults: {\n      name: 'Webhook Trigger',\n    },\n    inputs: [],\n    outputs: ['main'],\n    properties: [\n      {\n        displayName: 'Path',\n        name: 'path',\n        type: 'string',\n        default: '/webhook',\n        required: true,\n        description: 'Webhook endpoint path',\n      },\n      {\n        displayName: 'HTTP Method',\n        name: 'httpMethod',\n        type: 'options',\n        options: [\n          { name: 'GET', value: 'GET' },\n          { name: 'POST', value: 'POST' },\n          { name: 'PUT', value: 'PUT' },\n          { name: 'DELETE', value: 'DELETE' },\n        ],\n        default: 'POST',\n        description: 'HTTP method to listen for',\n      },\n      {\n        displayName: 'Response Code',\n        name: 'responseCode',\n        type: 'number',\n        default: 200,\n        description: 'HTTP response code to return',\n      },\n      {\n        displayName: 'Response Data',\n        name: 'responseData',\n        type: 'string',\n        default: 'OK',\n        description: 'Response body to return',\n      },\n    ],\n  };\n\n  async trigger(this: ITriggerFunctions): Promise&lt;ITriggerResponse&gt; {\n    const path = this.getNodeParameter('path', 0) as string;\n    const httpMethod = this.getNodeParameter('httpMethod', 0) as string;\n    const responseCode = this.getNodeParameter('responseCode', 0) as number;\n    const responseData = this.getNodeParameter('responseData', 0) as string;\n\n    let server: any;\n\n    const startServer = () =&gt; {\n      return new Promise&lt;void&gt;((resolve, reject) =&gt; {\n        server = createServer((req: IncomingMessage, res: ServerResponse) =&gt; {\n          // Check if this is the correct path and method\n          if (req.url !== path || req.method !== httpMethod) {\n            res.writeHead(404);\n            res.end('Not Found');\n            return;\n          }\n\n          // Parse request body\n          let body = '';\n          req.on('data', chunk =&gt; {\n            body += chunk.toString();\n          });\n\n          req.on('end', () =&gt; {\n            try {\n              // Process the webhook data\n              const webhookData = this.processWebhookData(req, body);\n\n              // Emit the data\n              this.emit([webhookData]);\n\n              // Send response\n              res.writeHead(responseCode, { 'Content-Type': 'text/plain' });\n              res.end(responseData);\n            } catch (error) {\n              // Emit error\n              this.emitError(error, { path, method: httpMethod });\n\n              // Send error response\n              res.writeHead(500, { 'Content-Type': 'text/plain' });\n              res.end('Internal Server Error');\n            }\n          });\n        });\n\n        server.listen(0, () =&gt; {\n          const port = server.address()?.port;\n          console.log(`Webhook server listening on port ${port}`);\n          resolve();\n        });\n\n        server.on('error', reject);\n      });\n    };\n\n    const stopServer = () =&gt; {\n      return new Promise&lt;void&gt;((resolve) =&gt; {\n        if (server) {\n          server.close(() =&gt; {\n            console.log('Webhook server stopped');\n            resolve();\n          });\n        } else {\n          resolve();\n        }\n      });\n    };\n\n    // Start the server\n    await startServer();\n\n    return {\n      closeFunction: stopServer,\n      manualTriggerFunction: async () =&gt; {\n        // Manual trigger for testing\n        const testData: INodeExecutionData[] = [{\n          json: {\n            test: true,\n            timestamp: new Date().toISOString(),\n            message: 'Manual trigger test',\n          },\n        }];\n\n        return [testData];\n      },\n    };\n  }\n\n  private processWebhookData(req: IncomingMessage, body: string): INodeExecutionData[] {\n    let parsedBody: any;\n\n    try {\n      // Try to parse as JSON\n      parsedBody = JSON.parse(body);\n    } catch {\n      // If not JSON, use as string\n      parsedBody = body;\n    }\n\n    return [{\n      json: {\n        headers: req.headers,\n        method: req.method,\n        url: req.url,\n        body: parsedBody,\n        timestamp: new Date().toISOString(),\n      },\n    }];\n  }\n}\n</code></pre>"},{"location":"public-api/execution-contexts/ITriggerFunctions/#common-patterns","title":"Common Patterns","text":""},{"location":"public-api/execution-contexts/ITriggerFunctions/#websocket-trigger","title":"WebSocket Trigger","text":"<pre><code>import WebSocket from 'ws';\n\nasync trigger(this: ITriggerFunctions): Promise&lt;ITriggerResponse&gt; {\n  const wsUrl = this.getNodeParameter('wsUrl', 0) as string;\n  let ws: WebSocket;\n\n  const startWebSocket = () =&gt; {\n    return new Promise&lt;void&gt;((resolve, reject) =&gt; {\n      ws = new WebSocket(wsUrl);\n\n      ws.on('open', () =&gt; {\n        console.log('WebSocket connected');\n        resolve();\n      });\n\n      ws.on('message', (data: WebSocket.Data) =&gt; {\n        try {\n          const message = JSON.parse(data.toString());\n\n          const executionData: INodeExecutionData[] = [{\n            json: {\n              ...message,\n              timestamp: new Date().toISOString(),\n            },\n          }];\n\n          this.emit([executionData]);\n        } catch (error) {\n          this.emitError(error, { wsUrl });\n        }\n      });\n\n      ws.on('error', (error) =&gt; {\n        this.emitError(error, { wsUrl });\n        reject(error);\n      });\n\n      ws.on('close', () =&gt; {\n        console.log('WebSocket disconnected');\n      });\n    });\n  };\n\n  const stopWebSocket = () =&gt; {\n    return new Promise&lt;void&gt;((resolve) =&gt; {\n      if (ws &amp;&amp; ws.readyState === WebSocket.OPEN) {\n        ws.close();\n      }\n      resolve();\n    });\n  };\n\n  await startWebSocket();\n\n  return {\n    closeFunction: stopWebSocket,\n  };\n}\n</code></pre>"},{"location":"public-api/execution-contexts/ITriggerFunctions/#file-watcher-trigger","title":"File Watcher Trigger","text":"<pre><code>import { watch, FSWatcher } from 'chokidar';\n\nasync trigger(this: ITriggerFunctions): Promise&lt;ITriggerResponse&gt; {\n  const watchPath = this.getNodeParameter('watchPath', 0) as string;\n  const events = this.getNodeParameter('events', 0) as string[];\n\n  let watcher: FSWatcher;\n\n  const startWatcher = () =&gt; {\n    return new Promise&lt;void&gt;((resolve) =&gt; {\n      watcher = watch(watchPath, {\n        persistent: true,\n        ignoreInitial: true,\n      });\n\n      // Handle different file events\n      if (events.includes('add')) {\n        watcher.on('add', (path) =&gt; {\n          this.emitFileEvent('add', path);\n        });\n      }\n\n      if (events.includes('change')) {\n        watcher.on('change', (path) =&gt; {\n          this.emitFileEvent('change', path);\n        });\n      }\n\n      if (events.includes('unlink')) {\n        watcher.on('unlink', (path) =&gt; {\n          this.emitFileEvent('unlink', path);\n        });\n      }\n\n      watcher.on('ready', () =&gt; {\n        console.log('File watcher ready');\n        resolve();\n      });\n\n      watcher.on('error', (error) =&gt; {\n        this.emitError(error, { watchPath });\n      });\n    });\n  };\n\n  const stopWatcher = () =&gt; {\n    return new Promise&lt;void&gt;((resolve) =&gt; {\n      if (watcher) {\n        watcher.close().then(() =&gt; {\n          console.log('File watcher stopped');\n          resolve();\n        });\n      } else {\n        resolve();\n      }\n    });\n  };\n\n  await startWatcher();\n\n  return {\n    closeFunction: stopWatcher,\n  };\n}\n\nprivate emitFileEvent(event: string, filePath: string): void {\n  const executionData: INodeExecutionData[] = [{\n    json: {\n      event,\n      path: filePath,\n      timestamp: new Date().toISOString(),\n    },\n  }];\n\n  this.emit([executionData]);\n}\n</code></pre>"},{"location":"public-api/execution-contexts/ITriggerFunctions/#server-sent-events-sse-trigger","title":"Server-Sent Events (SSE) Trigger","text":"<pre><code>import EventSource from 'eventsource';\n\nasync trigger(this: ITriggerFunctions): Promise&lt;ITriggerResponse&gt; {\n  const sseUrl = this.getNodeParameter('sseUrl', 0) as string;\n  const eventTypes = this.getNodeParameter('eventTypes', 0) as string[];\n\n  let eventSource: EventSource;\n\n  const startSSE = () =&gt; {\n    return new Promise&lt;void&gt;((resolve, reject) =&gt; {\n      eventSource = new EventSource(sseUrl);\n\n      eventSource.onopen = () =&gt; {\n        console.log('SSE connection opened');\n        resolve();\n      };\n\n      eventSource.onerror = (error) =&gt; {\n        this.emitError(new Error('SSE connection error'), { sseUrl });\n        reject(error);\n      };\n\n      // Listen for specific event types\n      eventTypes.forEach(eventType =&gt; {\n        eventSource.addEventListener(eventType, (event) =&gt; {\n          try {\n            const data = JSON.parse(event.data);\n\n            const executionData: INodeExecutionData[] = [{\n              json: {\n                eventType,\n                data,\n                id: event.lastEventId,\n                timestamp: new Date().toISOString(),\n              },\n            }];\n\n            this.emit([executionData]);\n          } catch (error) {\n            this.emitError(error, { eventType, sseUrl });\n          }\n        });\n      });\n\n      // Listen for generic messages\n      eventSource.onmessage = (event) =&gt; {\n        try {\n          const data = JSON.parse(event.data);\n\n          const executionData: INodeExecutionData[] = [{\n            json: {\n              eventType: 'message',\n              data,\n              id: event.lastEventId,\n              timestamp: new Date().toISOString(),\n            },\n          }];\n\n          this.emit([executionData]);\n        } catch (error) {\n          this.emitError(error, { sseUrl });\n        }\n      };\n    });\n  };\n\n  const stopSSE = () =&gt; {\n    return new Promise&lt;void&gt;((resolve) =&gt; {\n      if (eventSource) {\n        eventSource.close();\n        console.log('SSE connection closed');\n      }\n      resolve();\n    });\n  };\n\n  await startSSE();\n\n  return {\n    closeFunction: stopSSE,\n  };\n}\n</code></pre>"},{"location":"public-api/execution-contexts/ITriggerFunctions/#database-change-stream-trigger","title":"Database Change Stream Trigger","text":"<pre><code>async trigger(this: ITriggerFunctions): Promise&lt;ITriggerResponse&gt; {\n  const connectionString = this.getNodeParameter('connectionString', 0) as string;\n  const collection = this.getNodeParameter('collection', 0) as string;\n  const operations = this.getNodeParameter('operations', 0) as string[];\n\n  let changeStream: any;\n  let client: any;\n\n  const startChangeStream = async () =&gt; {\n    // Connect to database\n    client = await this.helpers.dbConnect(connectionString);\n    const db = client.db();\n    const coll = db.collection(collection);\n\n    // Create change stream\n    const pipeline = [\n      {\n        $match: {\n          operationType: { $in: operations }\n        }\n      }\n    ];\n\n    changeStream = coll.watch(pipeline);\n\n    changeStream.on('change', (change: any) =&gt; {\n      try {\n        const executionData: INodeExecutionData[] = [{\n          json: {\n            operationType: change.operationType,\n            documentKey: change.documentKey,\n            fullDocument: change.fullDocument,\n            updateDescription: change.updateDescription,\n            timestamp: new Date().toISOString(),\n          },\n        }];\n\n        this.emit([executionData]);\n      } catch (error) {\n        this.emitError(error, { collection });\n      }\n    });\n\n    changeStream.on('error', (error: Error) =&gt; {\n      this.emitError(error, { collection });\n    });\n  };\n\n  const stopChangeStream = async () =&gt; {\n    if (changeStream) {\n      await changeStream.close();\n      console.log('Change stream closed');\n    }\n\n    if (client) {\n      await client.close();\n      console.log('Database connection closed');\n    }\n  };\n\n  await startChangeStream();\n\n  return {\n    closeFunction: stopChangeStream,\n  };\n}\n</code></pre>"},{"location":"public-api/execution-contexts/ITriggerFunctions/#error-handling","title":"Error Handling","text":""},{"location":"public-api/execution-contexts/ITriggerFunctions/#graceful-error-recovery","title":"Graceful Error Recovery","text":"<pre><code>async trigger(this: ITriggerFunctions): Promise&lt;ITriggerResponse&gt; {\n  const maxRetries = 3;\n  let retryCount = 0;\n  let connection: any;\n\n  const startConnection = async (): Promise&lt;void&gt; =&gt; {\n    try {\n      connection = await this.establishConnection();\n      retryCount = 0; // Reset on successful connection\n\n      connection.on('data', (data: any) =&gt; {\n        try {\n          this.processData(data);\n        } catch (error) {\n          this.emitError(error, { data });\n        }\n      });\n\n      connection.on('error', async (error: Error) =&gt; {\n        this.emitError(error);\n\n        // Attempt reconnection\n        if (retryCount &lt; maxRetries) {\n          retryCount++;\n          const delay = Math.pow(2, retryCount) * 1000; // Exponential backoff\n\n          setTimeout(async () =&gt; {\n            try {\n              await startConnection();\n            } catch (reconnectError) {\n              this.emitError(reconnectError);\n            }\n          }, delay);\n        }\n      });\n\n      connection.on('close', () =&gt; {\n        console.log('Connection closed');\n      });\n    } catch (error) {\n      if (retryCount &lt; maxRetries) {\n        retryCount++;\n        const delay = Math.pow(2, retryCount) * 1000;\n\n        setTimeout(() =&gt; startConnection(), delay);\n      } else {\n        throw error;\n      }\n    }\n  };\n\n  const stopConnection = async () =&gt; {\n    if (connection) {\n      connection.close();\n    }\n  };\n\n  await startConnection();\n\n  return {\n    closeFunction: stopConnection,\n  };\n}\n</code></pre>"},{"location":"public-api/execution-contexts/ITriggerFunctions/#circuit-breaker-pattern","title":"Circuit Breaker Pattern","text":"<pre><code>class CircuitBreaker {\n  private failures = 0;\n  private lastFailureTime = 0;\n  private state: 'closed' | 'open' | 'half-open' = 'closed';\n\n  constructor(\n    private maxFailures = 5,\n    private timeout = 60000 // 1 minute\n  ) {}\n\n  async execute&lt;T&gt;(operation: () =&gt; Promise&lt;T&gt;): Promise&lt;T&gt; {\n    if (this.state === 'open') {\n      if (Date.now() - this.lastFailureTime &gt; this.timeout) {\n        this.state = 'half-open';\n      } else {\n        throw new Error('Circuit breaker is open');\n      }\n    }\n\n    try {\n      const result = await operation();\n      this.onSuccess();\n      return result;\n    } catch (error) {\n      this.onFailure();\n      throw error;\n    }\n  }\n\n  private onSuccess(): void {\n    this.failures = 0;\n    this.state = 'closed';\n  }\n\n  private onFailure(): void {\n    this.failures++;\n    this.lastFailureTime = Date.now();\n\n    if (this.failures &gt;= this.maxFailures) {\n      this.state = 'open';\n    }\n  }\n}\n\nasync trigger(this: ITriggerFunctions): Promise&lt;ITriggerResponse&gt; {\n  const circuitBreaker = new CircuitBreaker();\n\n  const processEvent = async (data: any) =&gt; {\n    try {\n      await circuitBreaker.execute(async () =&gt; {\n        // Process the event\n        const executionData = this.transformData(data);\n        this.emit([executionData]);\n      });\n    } catch (error) {\n      this.emitError(error, { circuitBreakerState: circuitBreaker.state });\n    }\n  };\n\n  // ... rest of trigger setup\n}\n</code></pre>"},{"location":"public-api/execution-contexts/ITriggerFunctions/#performance-optimization","title":"Performance Optimization","text":""},{"location":"public-api/execution-contexts/ITriggerFunctions/#batching-events","title":"Batching Events","text":"<pre><code>async trigger(this: ITriggerFunctions): Promise&lt;ITriggerResponse&gt; {\n  const batchSize = this.getNodeParameter('batchSize', 0, 10) as number;\n  const batchTimeout = this.getNodeParameter('batchTimeout', 0, 5000) as number;\n\n  let eventBatch: INodeExecutionData[] = [];\n  let batchTimer: NodeJS.Timeout;\n\n  const flushBatch = () =&gt; {\n    if (eventBatch.length &gt; 0) {\n      this.emit([eventBatch]);\n      eventBatch = [];\n    }\n\n    if (batchTimer) {\n      clearTimeout(batchTimer);\n    }\n  };\n\n  const addToBatch = (data: INodeExecutionData) =&gt; {\n    eventBatch.push(data);\n\n    // Flush if batch is full\n    if (eventBatch.length &gt;= batchSize) {\n      flushBatch();\n      return;\n    }\n\n    // Set timer for batch timeout\n    if (batchTimer) {\n      clearTimeout(batchTimer);\n    }\n\n    batchTimer = setTimeout(flushBatch, batchTimeout);\n  };\n\n  // ... event handling logic that calls addToBatch(data)\n\n  return {\n    closeFunction: async () =&gt; {\n      flushBatch(); // Flush remaining events\n      // ... cleanup logic\n    },\n  };\n}\n</code></pre>"},{"location":"public-api/execution-contexts/ITriggerFunctions/#memory-management","title":"Memory Management","text":"<pre><code>async trigger(this: ITriggerFunctions): Promise&lt;ITriggerResponse&gt; {\n  const maxQueueSize = 1000;\n  const eventQueue: INodeExecutionData[] = [];\n  let processing = false;\n\n  const processQueue = async () =&gt; {\n    if (processing || eventQueue.length === 0) {\n      return;\n    }\n\n    processing = true;\n\n    try {\n      // Process events in batches\n      const batchSize = Math.min(100, eventQueue.length);\n      const batch = eventQueue.splice(0, batchSize);\n\n      this.emit([batch]);\n    } catch (error) {\n      this.emitError(error);\n    } finally {\n      processing = false;\n\n      // Continue processing if more events are queued\n      if (eventQueue.length &gt; 0) {\n        setImmediate(processQueue);\n      }\n    }\n  };\n\n  const addEvent = (data: INodeExecutionData) =&gt; {\n    // Prevent memory overflow\n    if (eventQueue.length &gt;= maxQueueSize) {\n      // Drop oldest events\n      eventQueue.shift();\n    }\n\n    eventQueue.push(data);\n\n    // Start processing\n    setImmediate(processQueue);\n  };\n\n  // ... event handling logic that calls addEvent(data)\n}\n</code></pre>"},{"location":"public-api/execution-contexts/ITriggerFunctions/#best-practices","title":"Best Practices","text":""},{"location":"public-api/execution-contexts/ITriggerFunctions/#1-always-implement-cleanup","title":"1. Always Implement Cleanup","text":"<pre><code>async trigger(this: ITriggerFunctions): Promise&lt;ITriggerResponse&gt; {\n  const resources: any[] = [];\n\n  try {\n    // Setup resources\n    const server = await this.startServer();\n    const connection = await this.openConnection();\n\n    resources.push(server, connection);\n\n    // ... trigger logic\n\n    return {\n      closeFunction: async () =&gt; {\n        // Clean up all resources\n        for (const resource of resources) {\n          try {\n            if (resource.close) {\n              await resource.close();\n            } else if (resource.destroy) {\n              resource.destroy();\n            }\n          } catch (error) {\n            console.error('Error cleaning up resource:', error);\n          }\n        }\n      },\n    };\n  } catch (error) {\n    // Clean up on setup failure\n    for (const resource of resources) {\n      try {\n        if (resource.close) {\n          await resource.close();\n        }\n      } catch (cleanupError) {\n        console.error('Error during cleanup:', cleanupError);\n      }\n    }\n    throw error;\n  }\n}\n</code></pre>"},{"location":"public-api/execution-contexts/ITriggerFunctions/#2-handle-manual-triggers","title":"2. Handle Manual Triggers","text":"<pre><code>async trigger(this: ITriggerFunctions): Promise&lt;ITriggerResponse&gt; {\n  // ... setup logic\n\n  return {\n    closeFunction: stopTrigger,\n    manualTriggerFunction: async () =&gt; {\n      // Provide test data for manual execution\n      const testData: INodeExecutionData[] = [{\n        json: {\n          test: true,\n          timestamp: new Date().toISOString(),\n          message: 'Manual trigger executed',\n        },\n      }];\n\n      return [testData];\n    },\n  };\n}\n</code></pre>"},{"location":"public-api/execution-contexts/ITriggerFunctions/#3-use-type-safety","title":"3. Use Type Safety","text":"<pre><code>interface WebhookPayload {\n  id: string;\n  event: string;\n  data: Record&lt;string, any&gt;;\n  timestamp: string;\n}\n\nprivate processWebhookData(payload: unknown): INodeExecutionData[] {\n  // Validate payload structure\n  if (!this.isValidWebhookPayload(payload)) {\n    throw new Error('Invalid webhook payload structure');\n  }\n\n  const typedPayload = payload as WebhookPayload;\n\n  return [{\n    json: {\n      id: typedPayload.id,\n      event: typedPayload.event,\n      data: typedPayload.data,\n      receivedAt: new Date().toISOString(),\n      originalTimestamp: typedPayload.timestamp,\n    },\n  }];\n}\n\nprivate isValidWebhookPayload(payload: unknown): payload is WebhookPayload {\n  return (\n    typeof payload === 'object' &amp;&amp;\n    payload !== null &amp;&amp;\n    'id' in payload &amp;&amp;\n    'event' in payload &amp;&amp;\n    'data' in payload &amp;&amp;\n    'timestamp' in payload\n  );\n}\n</code></pre>"},{"location":"public-api/execution-contexts/ITriggerFunctions/#see-also","title":"See Also","text":"<ul> <li>IPollFunctions - Polling-based triggers</li> <li>IExecuteFunctions - Main execution context</li> <li>getWorkflowStaticData - Managing persistent state</li> <li>HTTP Helpers - Making HTTP requests</li> </ul>"},{"location":"public-api/execution-contexts/IWebhookFunctions/","title":"IWebhookFunctions","text":"<p>The execution context for webhook nodes that handle incoming HTTP requests. This interface is used when your node needs to receive and process webhook data from external services.</p>"},{"location":"public-api/execution-contexts/IWebhookFunctions/#when-to-use","title":"When to Use","text":"<p>Use <code>IWebhookFunctions</code> when: - Creating webhook receiver nodes - Building HTTP endpoint handlers - Processing incoming API callbacks - Handling form submissions or file uploads</p>"},{"location":"public-api/execution-contexts/IWebhookFunctions/#interface-definition","title":"Interface Definition","text":"<pre><code>interface IWebhookFunctions extends IExecuteFunctions {\n  getBodyData(): IDataObject;\n  getHeaderData(): IncomingHttpHeaders;\n  getNodeWebhookUrl(name: string): string | undefined;\n  getParamsData(): object;\n  getQueryData(): object;\n  getRequestObject(): express.Request;\n  getResponseObject(): express.Response;\n  getWebhookName(): string;\n  prepareOutputData(outputData: INodeExecutionData[]): Promise&lt;INodeExecutionData[]&gt;;\n  helpers: IWebhookFunctionsHelpers;\n}\n</code></pre>"},{"location":"public-api/execution-contexts/IWebhookFunctions/#core-methods","title":"Core Methods","text":""},{"location":"public-api/execution-contexts/IWebhookFunctions/#getbodydata","title":"getBodyData()","text":"<p>Retrieves the parsed request body data.</p> <pre><code>getBodyData(): IDataObject\n</code></pre> <p>Returns: Parsed body data as an object</p>"},{"location":"public-api/execution-contexts/IWebhookFunctions/#getheaderdata","title":"getHeaderData()","text":"<p>Gets all HTTP headers from the incoming request.</p> <pre><code>getHeaderData(): IncomingHttpHeaders\n</code></pre> <p>Returns: Object containing all request headers</p>"},{"location":"public-api/execution-contexts/IWebhookFunctions/#getquerydata","title":"getQueryData()","text":"<p>Retrieves query string parameters from the request URL.</p> <pre><code>getQueryData(): object\n</code></pre> <p>Returns: Object containing query parameters</p>"},{"location":"public-api/execution-contexts/IWebhookFunctions/#getparamsdata","title":"getParamsData()","text":"<p>Gets URL path parameters from the request.</p> <pre><code>getParamsData(): object\n</code></pre> <p>Returns: Object containing URL parameters</p>"},{"location":"public-api/execution-contexts/IWebhookFunctions/#getrequestobject","title":"getRequestObject()","text":"<p>Returns the raw Express.js request object for advanced use cases.</p> <pre><code>getRequestObject(): express.Request\n</code></pre> <p>Returns: Express request object</p>"},{"location":"public-api/execution-contexts/IWebhookFunctions/#getresponseobject","title":"getResponseObject()","text":"<p>Returns the Express.js response object for custom response handling.</p> <pre><code>getResponseObject(): express.Response\n</code></pre> <p>Returns: Express response object</p>"},{"location":"public-api/execution-contexts/IWebhookFunctions/#getwebhookname","title":"getWebhookName()","text":"<p>Gets the name of the webhook being processed.</p> <pre><code>getWebhookName(): string\n</code></pre> <p>Returns: The webhook name</p>"},{"location":"public-api/execution-contexts/IWebhookFunctions/#getnodewebhookurl","title":"getNodeWebhookUrl()","text":"<p>Gets the full URL for a specific webhook endpoint.</p> <pre><code>getNodeWebhookUrl(name: string): string | undefined\n</code></pre> <p>Parameters: - <code>name</code> - The webhook name</p> <p>Returns: Full webhook URL or undefined</p>"},{"location":"public-api/execution-contexts/IWebhookFunctions/#implementation-example","title":"Implementation Example","text":"<pre><code>import {\n  IWebhookFunctions,\n  INodeExecutionData,\n  INodeType,\n  INodeTypeDescription,\n  IWebhookResponseData,\n  NodeOperationError,\n} from 'n8n-workflow';\n\nexport class CustomWebhook implements INodeType {\n  description: INodeTypeDescription = {\n    displayName: 'Custom Webhook',\n    name: 'customWebhook',\n    icon: 'fa:satellite-dish',\n    group: ['trigger'],\n    version: 1,\n    description: 'Receives and processes webhook data',\n    defaults: {\n      name: 'Custom Webhook',\n    },\n    inputs: [],\n    outputs: ['main'],\n    webhooks: [\n      {\n        name: 'default',\n        httpMethod: 'POST',\n        responseMode: 'onReceived',\n        path: 'webhook',\n      },\n    ],\n    properties: [\n      {\n        displayName: 'Response Mode',\n        name: 'responseMode',\n        type: 'options',\n        options: [\n          {\n            name: 'On Received',\n            value: 'onReceived',\n            description: 'Respond immediately when webhook is received',\n          },\n          {\n            name: 'Last Node',\n            value: 'lastNode',\n            description: 'Respond with data from the last node',\n          },\n        ],\n        default: 'onReceived',\n      },\n      {\n        displayName: 'Response Code',\n        name: 'responseCode',\n        type: 'number',\n        default: 200,\n        description: 'HTTP status code to return',\n      },\n      {\n        displayName: 'Response Data',\n        name: 'responseData',\n        type: 'string',\n        default: 'success',\n        description: 'Response body to return',\n      },\n      {\n        displayName: 'Authentication',\n        name: 'authentication',\n        type: 'options',\n        options: [\n          { name: 'None', value: 'none' },\n          { name: 'Header Auth', value: 'headerAuth' },\n          { name: 'Query Auth', value: 'queryAuth' },\n        ],\n        default: 'none',\n      },\n      {\n        displayName: 'Auth Header Name',\n        name: 'authHeaderName',\n        type: 'string',\n        default: 'Authorization',\n        displayOptions: {\n          show: {\n            authentication: ['headerAuth'],\n          },\n        },\n      },\n      {\n        displayName: 'Auth Header Value',\n        name: 'authHeaderValue',\n        type: 'string',\n        default: '',\n        displayOptions: {\n          show: {\n            authentication: ['headerAuth'],\n          },\n        },\n      },\n    ],\n  };\n\n  async webhook(this: IWebhookFunctions): Promise&lt;IWebhookResponseData&gt; {\n    const authentication = this.getNodeParameter('authentication', 0) as string;\n    const responseCode = this.getNodeParameter('responseCode', 0) as number;\n    const responseData = this.getNodeParameter('responseData', 0) as string;\n\n    try {\n      // Authenticate the request\n      if (!this.authenticateRequest(authentication)) {\n        return {\n          webhookResponse: {\n            status: 401,\n            body: 'Unauthorized',\n          },\n        };\n      }\n\n      // Get request data\n      const body = this.getBodyData();\n      const headers = this.getHeaderData();\n      const query = this.getQueryData();\n      const params = this.getParamsData();\n\n      // Process the webhook data\n      const webhookData = this.processWebhookData(body, headers, query, params);\n\n      // Prepare execution data\n      const executionData: INodeExecutionData[] = [{\n        json: webhookData,\n      }];\n\n      return {\n        workflowData: [executionData],\n        webhookResponse: {\n          status: responseCode,\n          body: responseData,\n        },\n      };\n    } catch (error) {\n      throw new NodeOperationError(\n        this.getNode(),\n        `Webhook processing failed: ${error.message}`\n      );\n    }\n  }\n\n  private authenticateRequest(authType: string): boolean {\n    switch (authType) {\n      case 'none':\n        return true;\n\n      case 'headerAuth':\n        const expectedHeader = this.getNodeParameter('authHeaderName', 0) as string;\n        const expectedValue = this.getNodeParameter('authHeaderValue', 0) as string;\n        const headers = this.getHeaderData();\n\n        return headers[expectedHeader.toLowerCase()] === expectedValue;\n\n      case 'queryAuth':\n        const query = this.getQueryData() as any;\n        const token = this.getNodeParameter('authToken', 0) as string;\n\n        return query.token === token;\n\n      default:\n        return false;\n    }\n  }\n\n  private processWebhookData(\n    body: any,\n    headers: any,\n    query: any,\n    params: any\n  ): any {\n    return {\n      body,\n      headers,\n      query,\n      params,\n      timestamp: new Date().toISOString(),\n      webhookName: this.getWebhookName(),\n      webhookUrl: this.getNodeWebhookUrl('default'),\n    };\n  }\n}\n</code></pre>"},{"location":"public-api/execution-contexts/IWebhookFunctions/#common-patterns","title":"Common Patterns","text":""},{"location":"public-api/execution-contexts/IWebhookFunctions/#file-upload-webhook","title":"File Upload Webhook","text":"<pre><code>async webhook(this: IWebhookFunctions): Promise&lt;IWebhookResponseData&gt; {\n  const req = this.getRequestObject();\n  const res = this.getResponseObject();\n\n  try {\n    // Handle multipart form data\n    if (!req.is('multipart/form-data')) {\n      return {\n        webhookResponse: {\n          status: 400,\n          body: 'Expected multipart/form-data',\n        },\n      };\n    }\n\n    // Process uploaded files\n    const files = await this.processFileUploads(req);\n    const formData = this.getBodyData();\n\n    const executionData: INodeExecutionData[] = files.map((file, index) =&gt; ({\n      json: {\n        fileName: file.originalname,\n        mimeType: file.mimetype,\n        size: file.size,\n        formData,\n        uploadedAt: new Date().toISOString(),\n      },\n      binary: {\n        data: {\n          data: file.buffer.toString('base64'),\n          mimeType: file.mimetype,\n          fileName: file.originalname,\n        },\n      },\n    }));\n\n    return {\n      workflowData: [executionData],\n      webhookResponse: {\n        status: 200,\n        body: { message: 'Files uploaded successfully', count: files.length },\n      },\n    };\n  } catch (error) {\n    return {\n      webhookResponse: {\n        status: 500,\n        body: { error: error.message },\n      },\n    };\n  }\n}\n\nprivate async processFileUploads(req: any): Promise&lt;any[]&gt; {\n  return new Promise((resolve, reject) =&gt; {\n    const multer = require('multer');\n    const upload = multer({ storage: multer.memoryStorage() });\n\n    upload.array('files')(req, null, (error: any) =&gt; {\n      if (error) {\n        reject(error);\n      } else {\n        resolve(req.files || []);\n      }\n    });\n  });\n}\n</code></pre>"},{"location":"public-api/execution-contexts/IWebhookFunctions/#json-api-webhook","title":"JSON API Webhook","text":"<pre><code>async webhook(this: IWebhookFunctions): Promise&lt;IWebhookResponseData&gt; {\n  const headers = this.getHeaderData();\n  const body = this.getBodyData();\n\n  try {\n    // Validate content type\n    if (!headers['content-type']?.includes('application/json')) {\n      return {\n        webhookResponse: {\n          status: 400,\n          body: { error: 'Content-Type must be application/json' },\n        },\n      };\n    }\n\n    // Validate required fields\n    const validation = this.validatePayload(body);\n    if (!validation.valid) {\n      return {\n        webhookResponse: {\n          status: 400,\n          body: { error: 'Validation failed', details: validation.errors },\n        },\n      };\n    }\n\n    // Process the data\n    const processedData = this.transformPayload(body);\n\n    const executionData: INodeExecutionData[] = [{\n      json: {\n        ...processedData,\n        receivedAt: new Date().toISOString(),\n        source: headers['user-agent'] || 'unknown',\n      },\n    }];\n\n    return {\n      workflowData: [executionData],\n      webhookResponse: {\n        status: 200,\n        body: { \n          message: 'Webhook processed successfully',\n          id: processedData.id,\n        },\n      },\n    };\n  } catch (error) {\n    return {\n      webhookResponse: {\n        status: 500,\n        body: { error: 'Internal server error' },\n      },\n    };\n  }\n}\n\nprivate validatePayload(payload: any): { valid: boolean; errors?: string[] } {\n  const errors: string[] = [];\n\n  if (!payload.id) {\n    errors.push('Missing required field: id');\n  }\n\n  if (!payload.event) {\n    errors.push('Missing required field: event');\n  }\n\n  if (!payload.data) {\n    errors.push('Missing required field: data');\n  }\n\n  return {\n    valid: errors.length === 0,\n    errors: errors.length &gt; 0 ? errors : undefined,\n  };\n}\n\nprivate transformPayload(payload: any): any {\n  return {\n    id: payload.id,\n    event: payload.event,\n    data: payload.data,\n    metadata: {\n      version: payload.version || '1.0',\n      timestamp: payload.timestamp || new Date().toISOString(),\n    },\n  };\n}\n</code></pre>"},{"location":"public-api/execution-contexts/IWebhookFunctions/#github-webhook-handler","title":"GitHub Webhook Handler","text":"<pre><code>async webhook(this: IWebhookFunctions): Promise&lt;IWebhookResponseData&gt; {\n  const headers = this.getHeaderData();\n  const body = this.getBodyData();\n  const signature = headers['x-hub-signature-256'] as string;\n\n  try {\n    // Verify GitHub signature\n    if (!this.verifyGitHubSignature(body, signature)) {\n      return {\n        webhookResponse: {\n          status: 401,\n          body: 'Invalid signature',\n        },\n      };\n    }\n\n    const event = headers['x-github-event'] as string;\n    const delivery = headers['x-github-delivery'] as string;\n\n    // Process different GitHub events\n    const processedData = this.processGitHubEvent(event, body);\n\n    const executionData: INodeExecutionData[] = [{\n      json: {\n        event,\n        delivery,\n        ...processedData,\n        receivedAt: new Date().toISOString(),\n      },\n    }];\n\n    return {\n      workflowData: [executionData],\n      webhookResponse: {\n        status: 200,\n        body: 'OK',\n      },\n    };\n  } catch (error) {\n    return {\n      webhookResponse: {\n        status: 500,\n        body: 'Internal server error',\n      },\n    };\n  }\n}\n\nprivate verifyGitHubSignature(payload: any, signature: string): boolean {\n  const crypto = require('crypto');\n  const secret = this.getNodeParameter('webhookSecret', 0) as string;\n\n  const expectedSignature = 'sha256=' + crypto\n    .createHmac('sha256', secret)\n    .update(JSON.stringify(payload))\n    .digest('hex');\n\n  return crypto.timingSafeEqual(\n    Buffer.from(signature),\n    Buffer.from(expectedSignature)\n  );\n}\n\nprivate processGitHubEvent(event: string, payload: any): any {\n  switch (event) {\n    case 'push':\n      return {\n        repository: payload.repository.full_name,\n        branch: payload.ref.replace('refs/heads/', ''),\n        commits: payload.commits.length,\n        pusher: payload.pusher.name,\n      };\n\n    case 'pull_request':\n      return {\n        repository: payload.repository.full_name,\n        action: payload.action,\n        number: payload.number,\n        title: payload.pull_request.title,\n        author: payload.pull_request.user.login,\n      };\n\n    case 'issues':\n      return {\n        repository: payload.repository.full_name,\n        action: payload.action,\n        number: payload.issue.number,\n        title: payload.issue.title,\n        author: payload.issue.user.login,\n      };\n\n    default:\n      return {\n        repository: payload.repository?.full_name,\n        action: payload.action,\n        rawPayload: payload,\n      };\n  }\n}\n</code></pre>"},{"location":"public-api/execution-contexts/IWebhookFunctions/#slack-webhook-handler","title":"Slack Webhook Handler","text":"<pre><code>async webhook(this: IWebhookFunctions): Promise&lt;IWebhookResponseData&gt; {\n  const body = this.getBodyData();\n  const headers = this.getHeaderData();\n\n  try {\n    // Handle Slack URL verification\n    if (body.type === 'url_verification') {\n      return {\n        webhookResponse: {\n          status: 200,\n          body: { challenge: body.challenge },\n        },\n      };\n    }\n\n    // Verify Slack signature\n    if (!this.verifySlackSignature(body, headers)) {\n      return {\n        webhookResponse: {\n          status: 401,\n          body: 'Invalid signature',\n        },\n      };\n    }\n\n    // Process Slack event\n    const processedData = this.processSlackEvent(body);\n\n    const executionData: INodeExecutionData[] = [{\n      json: processedData,\n    }];\n\n    return {\n      workflowData: [executionData],\n      webhookResponse: {\n        status: 200,\n        body: 'OK',\n      },\n    };\n  } catch (error) {\n    return {\n      webhookResponse: {\n        status: 500,\n        body: 'Internal server error',\n      },\n    };\n  }\n}\n\nprivate verifySlackSignature(payload: any, headers: any): boolean {\n  const crypto = require('crypto');\n  const signingSecret = this.getNodeParameter('signingSecret', 0) as string;\n  const timestamp = headers['x-slack-request-timestamp'];\n  const signature = headers['x-slack-signature'];\n\n  // Check timestamp to prevent replay attacks\n  const time = Math.floor(new Date().getTime() / 1000);\n  if (Math.abs(time - timestamp) &gt; 300) {\n    return false;\n  }\n\n  const baseString = `v0:${timestamp}:${JSON.stringify(payload)}`;\n  const expectedSignature = 'v0=' + crypto\n    .createHmac('sha256', signingSecret)\n    .update(baseString)\n    .digest('hex');\n\n  return crypto.timingSafeEqual(\n    Buffer.from(signature),\n    Buffer.from(expectedSignature)\n  );\n}\n\nprivate processSlackEvent(payload: any): any {\n  const event = payload.event;\n\n  return {\n    type: payload.type,\n    team: payload.team_id,\n    event: {\n      type: event.type,\n      user: event.user,\n      channel: event.channel,\n      text: event.text,\n      timestamp: event.ts,\n    },\n    receivedAt: new Date().toISOString(),\n  };\n}\n</code></pre>"},{"location":"public-api/execution-contexts/IWebhookFunctions/#response-handling","title":"Response Handling","text":""},{"location":"public-api/execution-contexts/IWebhookFunctions/#custom-response-headers","title":"Custom Response Headers","text":"<pre><code>async webhook(this: IWebhookFunctions): Promise&lt;IWebhookResponseData&gt; {\n  const res = this.getResponseObject();\n\n  // Set custom headers\n  res.setHeader('X-Custom-Header', 'custom-value');\n  res.setHeader('Access-Control-Allow-Origin', '*');\n  res.setHeader('Cache-Control', 'no-cache');\n\n  // Process webhook data\n  const body = this.getBodyData();\n  const executionData: INodeExecutionData[] = [{ json: body }];\n\n  return {\n    workflowData: [executionData],\n    webhookResponse: {\n      status: 200,\n      headers: {\n        'Content-Type': 'application/json',\n        'X-Processed-At': new Date().toISOString(),\n      },\n      body: { success: true, processed: true },\n    },\n  };\n}\n</code></pre>"},{"location":"public-api/execution-contexts/IWebhookFunctions/#streaming-response","title":"Streaming Response","text":"<pre><code>async webhook(this: IWebhookFunctions): Promise&lt;IWebhookResponseData&gt; {\n  const res = this.getResponseObject();\n\n  // Set headers for streaming\n  res.setHeader('Content-Type', 'text/plain');\n  res.setHeader('Transfer-Encoding', 'chunked');\n\n  // Start streaming response\n  res.write('Processing started...\\n');\n\n  // Process data in chunks\n  const body = this.getBodyData();\n  const items = body.items || [];\n\n  for (let i = 0; i &lt; items.length; i++) {\n    // Process item\n    await this.processItem(items[i]);\n\n    // Send progress update\n    res.write(`Processed item ${i + 1}/${items.length}\\n`);\n  }\n\n  res.write('Processing completed!\\n');\n  res.end();\n\n  // Return execution data\n  const executionData: INodeExecutionData[] = [{\n    json: {\n      processed: items.length,\n      completedAt: new Date().toISOString(),\n    },\n  }];\n\n  return {\n    workflowData: [executionData],\n    noWebhookResponse: true, // Response already sent\n  };\n}\n</code></pre>"},{"location":"public-api/execution-contexts/IWebhookFunctions/#error-handling","title":"Error Handling","text":""},{"location":"public-api/execution-contexts/IWebhookFunctions/#graceful-error-responses","title":"Graceful Error Responses","text":"<pre><code>async webhook(this: IWebhookFunctions): Promise&lt;IWebhookResponseData&gt; {\n  try {\n    const body = this.getBodyData();\n\n    // Validate input\n    if (!body || Object.keys(body).length === 0) {\n      return {\n        webhookResponse: {\n          status: 400,\n          body: {\n            error: 'Bad Request',\n            message: 'Request body is required',\n            code: 'MISSING_BODY',\n          },\n        },\n      };\n    }\n\n    // Process data\n    const result = await this.processWebhookData(body);\n\n    return {\n      workflowData: [[{ json: result }]],\n      webhookResponse: {\n        status: 200,\n        body: { success: true, data: result },\n      },\n    };\n  } catch (error) {\n    // Log error for debugging\n    console.error('Webhook processing error:', error);\n\n    // Return appropriate error response\n    if (error.name === 'ValidationError') {\n      return {\n        webhookResponse: {\n          status: 400,\n          body: {\n            error: 'Validation Error',\n            message: error.message,\n            code: 'VALIDATION_FAILED',\n          },\n        },\n      };\n    }\n\n    if (error.name === 'AuthenticationError') {\n      return {\n        webhookResponse: {\n          status: 401,\n          body: {\n            error: 'Authentication Error',\n            message: 'Invalid credentials',\n            code: 'AUTH_FAILED',\n          },\n        },\n      };\n    }\n\n    // Generic error response\n    return {\n      webhookResponse: {\n        status: 500,\n        body: {\n          error: 'Internal Server Error',\n          message: 'An unexpected error occurred',\n          code: 'INTERNAL_ERROR',\n        },\n      },\n    };\n  }\n}\n</code></pre>"},{"location":"public-api/execution-contexts/IWebhookFunctions/#best-practices","title":"Best Practices","text":""},{"location":"public-api/execution-contexts/IWebhookFunctions/#1-always-validate-input","title":"1. Always Validate Input","text":"<pre><code>private validateWebhookData(data: any): { valid: boolean; errors: string[] } {\n  const errors: string[] = [];\n\n  // Check required fields\n  if (!data.id) errors.push('Missing required field: id');\n  if (!data.type) errors.push('Missing required field: type');\n\n  // Validate data types\n  if (data.timestamp &amp;&amp; !this.isValidTimestamp(data.timestamp)) {\n    errors.push('Invalid timestamp format');\n  }\n\n  // Validate business rules\n  if (data.amount &amp;&amp; data.amount &lt; 0) {\n    errors.push('Amount must be positive');\n  }\n\n  return {\n    valid: errors.length === 0,\n    errors,\n  };\n}\n</code></pre>"},{"location":"public-api/execution-contexts/IWebhookFunctions/#2-implement-proper-security","title":"2. Implement Proper Security","text":"<pre><code>private authenticateWebhook(): boolean {\n  const headers = this.getHeaderData();\n  const authHeader = headers.authorization;\n\n  if (!authHeader) {\n    return false;\n  }\n\n  const token = authHeader.replace('Bearer ', '');\n  const expectedToken = this.getNodeParameter('authToken', 0) as string;\n\n  return token === expectedToken;\n}\n</code></pre>"},{"location":"public-api/execution-contexts/IWebhookFunctions/#3-use-type-safety","title":"3. Use Type Safety","text":"<pre><code>interface WebhookPayload {\n  id: string;\n  type: 'create' | 'update' | 'delete';\n  data: Record&lt;string, any&gt;;\n  timestamp: string;\n}\n\nasync webhook(this: IWebhookFunctions): Promise&lt;IWebhookResponseData&gt; {\n  const body = this.getBodyData() as WebhookPayload;\n\n  // Type-safe processing\n  const executionData: INodeExecutionData[] = [{\n    json: {\n      id: body.id,\n      type: body.type,\n      data: body.data,\n      processedAt: new Date().toISOString(),\n    },\n  }];\n\n  return {\n    workflowData: [executionData],\n    webhookResponse: {\n      status: 200,\n      body: { success: true },\n    },\n  };\n}\n</code></pre>"},{"location":"public-api/execution-contexts/IWebhookFunctions/#see-also","title":"See Also","text":"<ul> <li>ITriggerFunctions - Event-driven triggers</li> <li>IExecuteFunctions - Main execution context</li> <li>HTTP Helpers - Making HTTP requests</li> <li>Binary Data - Handling file uploads</li> </ul>"},{"location":"public-api/helpers/","title":"Helper Functions Overview","text":"<p>Helper functions are utility methods available through the <code>helpers</code> object in all execution contexts. They provide common functionality for HTTP requests, binary data handling, file operations, and more.</p>"},{"location":"public-api/helpers/#categories","title":"Categories","text":""},{"location":"public-api/helpers/#http-helpers","title":"\ud83c\udf10 HTTP Helpers","text":"<p>Make HTTP requests with authentication and error handling: - httpRequest - Modern HTTP requests - httpRequestWithAuthentication - Authenticated requests - requestWithAuthenticationPaginated - Paginated API calls</p>"},{"location":"public-api/helpers/#binary-helpers","title":"\ud83d\udcc1 Binary Helpers","text":"<p>Work with files and binary data: - prepareBinaryData - Create binary data objects - getBinaryDataBuffer - Get binary data as Buffer - assertBinaryData - Safely access binary data - binaryToString - Convert binary to text</p>"},{"location":"public-api/helpers/#filesystem-helpers","title":"\ud83d\udcbe Filesystem Helpers","text":"<p>File system operations: - createReadStream - Create file read streams - writeContentToFile - Write data to files - createDirIfNotExists - Create directories</p>"},{"location":"public-api/helpers/#deduplication-helpers","title":"\ud83d\udd04 Deduplication Helpers","text":"<p>Prevent duplicate processing: - checkProcessedAndRecord - Check and record items - clearAllProcessedItems - Clear processed history</p>"},{"location":"public-api/helpers/#base-helpers","title":"\ud83d\udee0\ufe0f Base Helpers","text":"<p>Core utility functions: - returnJsonArray - Format return data - normalizeItems - Normalize item structure - constructExecutionMetaData - Add execution metadata</p>"},{"location":"public-api/helpers/#quick-examples","title":"Quick Examples","text":""},{"location":"public-api/helpers/#making-http-requests","title":"Making HTTP Requests","text":"<pre><code>// Simple GET request\nconst response = await this.helpers.httpRequest({\n  method: 'GET',\n  url: 'https://api.example.com/data',\n});\n\n// Authenticated request\nconst response = await this.helpers.httpRequestWithAuthentication(\n  'apiKeyAuth',\n  {\n    method: 'POST',\n    url: 'https://api.example.com/create',\n    body: { name: 'New Item' },\n  }\n);\n</code></pre>"},{"location":"public-api/helpers/#working-with-binary-data","title":"Working with Binary Data","text":"<pre><code>// Download and prepare binary data\nconst response = await this.helpers.httpRequest({\n  method: 'GET',\n  url: 'https://example.com/file.pdf',\n  encoding: 'arraybuffer',\n});\n\nconst binaryData = await this.helpers.prepareBinaryData(\n  Buffer.from(response),\n  'document.pdf',\n  'application/pdf'\n);\n\nreturn [{\n  json: { success: true },\n  binary: { data: binaryData },\n}];\n</code></pre>"},{"location":"public-api/helpers/#processing-files","title":"Processing Files","text":"<pre><code>// Get binary data from input\nconst buffer = await this.helpers.getBinaryDataBuffer(0, 'data');\n\n// Convert to text if it's a text file\nconst text = await this.helpers.binaryToString(buffer, 'utf8');\n\n// Process the text content\nconst lines = text.split('\\n');\nconst processedData = lines.map(line =&gt; ({ content: line.trim() }));\n\nreturn this.helpers.returnJsonArray(processedData);\n</code></pre>"},{"location":"public-api/helpers/#deduplication","title":"Deduplication","text":"<pre><code>// Check if item was already processed\nconst itemId = item.json.id as string;\nconst wasProcessed = await this.helpers.checkProcessedAndRecord(itemId);\n\nif (wasProcessed) {\n  // Skip this item\n  continue;\n}\n\n// Process the item...\n</code></pre>"},{"location":"public-api/helpers/#helper-context-availability","title":"Helper Context Availability","text":"<p>Different execution contexts have access to different helper methods:</p> <pre><code>graph TD\n    A[IExecuteFunctions] --&gt; B[All Helpers]\n    C[IExecuteSingleFunctions] --&gt; B\n    D[ILoadOptionsFunctions] --&gt; E[HTTP Helpers Only]\n    F[ITriggerFunctions] --&gt; B\n    G[IPollFunctions] --&gt; B\n    H[IWebhookFunctions] --&gt; I[HTTP + Binary Helpers]\n    J[IHookFunctions] --&gt; E\n</code></pre>"},{"location":"public-api/helpers/#full-helper-access","title":"Full Helper Access","text":"<ul> <li><code>IExecuteFunctions</code></li> <li><code>IExecuteSingleFunctions</code></li> <li><code>ITriggerFunctions</code></li> <li><code>IPollFunctions</code></li> </ul>"},{"location":"public-api/helpers/#limited-helper-access","title":"Limited Helper Access","text":"<ul> <li><code>ILoadOptionsFunctions</code> - HTTP helpers only</li> <li><code>IWebhookFunctions</code> - HTTP and binary helpers</li> <li><code>IHookFunctions</code> - HTTP helpers only</li> </ul>"},{"location":"public-api/helpers/#error-handling","title":"Error Handling","text":"<p>All helper functions can throw errors. Always wrap them in try-catch blocks:</p> <pre><code>try {\n  const response = await this.helpers.httpRequest(options);\n  // Process response\n} catch (error) {\n  if (this.continueOnFail()) {\n    return [{ json: { error: error.message } }];\n  }\n  throw new NodeOperationError(this.getNode(), error.message);\n}\n</code></pre>"},{"location":"public-api/helpers/#performance-tips","title":"Performance Tips","text":""},{"location":"public-api/helpers/#1-reuse-http-connections","title":"1. Reuse HTTP Connections","text":"<pre><code>// Good - reuse connection for multiple requests\nconst baseOptions = {\n  headers: { 'Authorization': 'Bearer token' },\n  timeout: 30000,\n};\n\nfor (const item of items) {\n  const response = await this.helpers.httpRequest({\n    ...baseOptions,\n    method: 'GET',\n    url: `https://api.example.com/items/${item.id}`,\n  });\n}\n</code></pre>"},{"location":"public-api/helpers/#2-stream-large-files","title":"2. Stream Large Files","text":"<pre><code>// Good - use streams for large files\nconst stream = this.helpers.createReadStream(filePath);\nconst binaryData = await this.helpers.prepareBinaryData(stream, filename);\n\n// Bad - load entire file into memory\nconst buffer = readFileSync(filePath);\nconst binaryData = await this.helpers.prepareBinaryData(buffer, filename);\n</code></pre>"},{"location":"public-api/helpers/#3-batch-operations","title":"3. Batch Operations","text":"<pre><code>// Good - batch multiple items\nconst batchSize = 100;\nfor (let i = 0; i &lt; items.length; i += batchSize) {\n  const batch = items.slice(i, i + batchSize);\n  await processBatch(batch);\n}\n</code></pre>"},{"location":"public-api/helpers/#best-practices","title":"Best Practices","text":""},{"location":"public-api/helpers/#1-type-safety","title":"1. Type Safety","text":"<pre><code>// Define interfaces for API responses\ninterface ApiResponse {\n  data: Array&lt;{ id: string; name: string }&gt;;\n  pagination: { page: number; total: number };\n}\n\nconst response = await this.helpers.httpRequest(options) as ApiResponse;\n</code></pre>"},{"location":"public-api/helpers/#2-proper-error-messages","title":"2. Proper Error Messages","text":"<pre><code>try {\n  const response = await this.helpers.httpRequest(options);\n} catch (error) {\n  throw new NodeOperationError(\n    this.getNode(),\n    `Failed to fetch data from API: ${error.message}`,\n    { itemIndex: i }\n  );\n}\n</code></pre>"},{"location":"public-api/helpers/#3-resource-cleanup","title":"3. Resource Cleanup","text":"<pre><code>// Always clean up resources\nlet stream: Readable | undefined;\ntry {\n  stream = this.helpers.createReadStream(filePath);\n  // Process stream\n} finally {\n  if (stream) {\n    stream.destroy();\n  }\n}\n</code></pre>"},{"location":"public-api/helpers/#see-also","title":"See Also","text":"<ul> <li>HTTP Helpers - Detailed HTTP request documentation</li> <li>Binary Helpers - Binary data handling</li> <li>IExecuteFunctions - Main execution context</li> <li>Error Handling - Robust error management</li> </ul>"},{"location":"public-api/helpers/base/","title":"Base Helpers","text":"<p>The base helpers provide fundamental utility functions that are available across all n8n node execution contexts. These are the core building blocks for data manipulation, validation, and common operations within nodes.</p>"},{"location":"public-api/helpers/base/#when-to-use","title":"When to Use","text":"<p>Use base helpers when your node needs to: - Perform common data transformations - Validate input data and parameters - Handle errors and logging - Work with dates, strings, and objects - Implement utility functions for data processing</p>"},{"location":"public-api/helpers/base/#available-functions","title":"Available Functions","text":""},{"location":"public-api/helpers/base/#returnjsonarray","title":"<code>returnJsonArray()</code>","text":"<p>Converts data to the standard n8n item format with JSON data.</p> <pre><code>import { IExecuteFunctions } from 'n8n-workflow'\n\nexport async function execute(this: IExecuteFunctions) {\n  const rawData = [\n    { name: 'John', age: 30 },\n    { name: 'Jane', age: 25 }\n  ]\n\n  // Convert to n8n item format\n  const items = this.helpers.returnJsonArray(rawData)\n\n  return [items]\n}\n</code></pre>"},{"location":"public-api/helpers/base/#normalizeitems","title":"<code>normalizeItems()</code>","text":"<p>Ensures all items have consistent structure and required properties.</p> <pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n\n  // Normalize items to ensure consistent structure\n  const normalizedItems = this.helpers.normalizeItems(items, {\n    ensureArray: true,\n    removeEmpty: true,\n    defaultValues: {\n      id: null,\n      status: 'active'\n    }\n  })\n\n  return [normalizedItems]\n}\n</code></pre>"},{"location":"public-api/helpers/base/#constructexecutionmetadata","title":"<code>constructExecutionMetaData()</code>","text":"<p>Creates metadata for tracking execution information.</p> <pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n  const processedItems = []\n\n  for (const item of items) {\n    const processedItem = {\n      json: {\n        ...item.json,\n        processedAt: new Date().toISOString()\n      }\n    }\n\n    // Add execution metadata\n    const itemWithMetadata = this.helpers.constructExecutionMetaData(\n      processedItem,\n      { itemData: { item: 0 } }\n    )\n\n    processedItems.push(itemWithMetadata)\n  }\n\n  return [processedItems]\n}\n</code></pre>"},{"location":"public-api/helpers/base/#data-validation","title":"Data Validation","text":""},{"location":"public-api/helpers/base/#validatedata","title":"<code>validateData()</code>","text":"<p>Validates input data against specified criteria.</p> <pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n\n  for (let i = 0; i &lt; items.length; i++) {\n    const item = items[i]\n\n    // Validate required fields\n    const validation = this.helpers.validateData(item.json, {\n      required: ['email', 'name'],\n      types: {\n        email: 'string',\n        name: 'string',\n        age: 'number'\n      },\n      patterns: {\n        email: /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/\n      }\n    })\n\n    if (!validation.isValid) {\n      throw new Error(`Item ${i}: ${validation.errors.join(', ')}`)\n    }\n  }\n\n  return [items]\n}\n</code></pre>"},{"location":"public-api/helpers/base/#assertbinarydata","title":"<code>assertBinaryData()</code>","text":"<p>Validates and retrieves binary data from items.</p> <pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n  const processedItems = []\n\n  for (let i = 0; i &lt; items.length; i++) {\n    // Assert binary data exists\n    const binaryData = this.helpers.assertBinaryData(i, 'attachment')\n\n    processedItems.push({\n      json: {\n        fileName: binaryData.fileName,\n        mimeType: binaryData.mimeType,\n        fileSize: binaryData.fileSize\n      }\n    })\n  }\n\n  return [processedItems]\n}\n</code></pre>"},{"location":"public-api/helpers/base/#string-and-data-utilities","title":"String and Data Utilities","text":""},{"location":"public-api/helpers/base/#slugify","title":"<code>slugify()</code>","text":"<p>Converts strings to URL-friendly slugs.</p> <pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n\n  const processedItems = items.map(item =&gt; ({\n    json: {\n      ...item.json,\n      slug: this.helpers.slugify(item.json.title),\n      urlPath: this.helpers.slugify(item.json.title, { \n        lower: true,\n        strict: true \n      })\n    }\n  }))\n\n  return [processedItems]\n}\n</code></pre>"},{"location":"public-api/helpers/base/#deepcopy","title":"<code>deepCopy()</code>","text":"<p>Creates deep copies of objects to avoid reference issues.</p> <pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n  const template = this.getNodeParameter('template', 0) as object\n\n  const processedItems = items.map(item =&gt; {\n    // Deep copy template to avoid mutations\n    const itemTemplate = this.helpers.deepCopy(template)\n\n    return {\n      json: {\n        ...itemTemplate,\n        ...item.json\n      }\n    }\n  })\n\n  return [processedItems]\n}\n</code></pre>"},{"location":"public-api/helpers/base/#flattenobject","title":"<code>flattenObject()</code>","text":"<p>Flattens nested objects into dot-notation keys.</p> <pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n\n  const flattenedItems = items.map(item =&gt; ({\n    json: this.helpers.flattenObject(item.json, {\n      delimiter: '.',\n      maxDepth: 5\n    })\n  }))\n\n  return [flattenedItems]\n}\n</code></pre>"},{"location":"public-api/helpers/base/#date-and-time-utilities","title":"Date and Time Utilities","text":""},{"location":"public-api/helpers/base/#formatdatetime","title":"<code>formatDateTime()</code>","text":"<p>Formats dates according to specified patterns.</p> <pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n  const format = this.getNodeParameter('dateFormat', 0, 'YYYY-MM-DD') as string\n\n  const formattedItems = items.map(item =&gt; ({\n    json: {\n      ...item.json,\n      formattedDate: this.helpers.formatDateTime(\n        item.json.createdAt,\n        format\n      ),\n      timestamp: this.helpers.formatDateTime(\n        new Date(),\n        'X' // Unix timestamp\n      )\n    }\n  }))\n\n  return [formattedItems]\n}\n</code></pre>"},{"location":"public-api/helpers/base/#parsedatetime","title":"<code>parseDateTime()</code>","text":"<p>Parses date strings into Date objects.</p> <pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n\n  const parsedItems = items.map(item =&gt; {\n    const parsedDate = this.helpers.parseDateTime(\n      item.json.dateString,\n      'DD/MM/YYYY'\n    )\n\n    return {\n      json: {\n        ...item.json,\n        parsedDate: parsedDate.toISOString(),\n        isValid: parsedDate instanceof Date &amp;&amp; !isNaN(parsedDate.getTime())\n      }\n    }\n  })\n\n  return [parsedItems]\n}\n</code></pre>"},{"location":"public-api/helpers/base/#error-handling-and-logging","title":"Error Handling and Logging","text":""},{"location":"public-api/helpers/base/#lognodeoutput","title":"<code>logNodeOutput()</code>","text":"<p>Logs node output for debugging purposes.</p> <pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n  const debugMode = this.getNodeParameter('debug', 0, false) as boolean\n\n  if (debugMode) {\n    this.helpers.logNodeOutput('Input items', items)\n  }\n\n  const processedItems = items.map(item =&gt; ({\n    json: {\n      ...item.json,\n      processed: true\n    }\n  }))\n\n  if (debugMode) {\n    this.helpers.logNodeOutput('Processed items', processedItems)\n  }\n\n  return [processedItems]\n}\n</code></pre>"},{"location":"public-api/helpers/base/#createerroritem","title":"<code>createErrorItem()</code>","text":"<p>Creates standardized error items for failed operations.</p> <pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n  const results = []\n\n  for (let i = 0; i &lt; items.length; i++) {\n    try {\n      // Process item\n      const result = await processItem(items[i])\n      results.push(result)\n    } catch (error) {\n      // Create error item\n      const errorItem = this.helpers.createErrorItem(\n        items[i],\n        error,\n        i\n      )\n      results.push(errorItem)\n    }\n  }\n\n  return [results]\n}\n</code></pre>"},{"location":"public-api/helpers/base/#common-patterns","title":"Common Patterns","text":""},{"location":"public-api/helpers/base/#batch-processing","title":"Batch Processing","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n  const batchSize = this.getNodeParameter('batchSize', 0, 100) as number\n\n  const allResults = []\n\n  // Process items in batches\n  for (let i = 0; i &lt; items.length; i += batchSize) {\n    const batch = items.slice(i, i + batchSize)\n\n    const batchResults = this.helpers.processBatch(batch, {\n      concurrency: 5,\n      retries: 3,\n      onProgress: (processed, total) =&gt; {\n        this.helpers.logNodeOutput(`Processed ${processed}/${total} items`)\n      }\n    })\n\n    allResults.push(...batchResults)\n  }\n\n  return [allResults]\n}\n</code></pre>"},{"location":"public-api/helpers/base/#data-transformation-pipeline","title":"Data Transformation Pipeline","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n\n  const transformedItems = this.helpers.transformData(items, [\n    // Step 1: Normalize data\n    (items) =&gt; this.helpers.normalizeItems(items),\n\n    // Step 2: Validate data\n    (items) =&gt; items.filter(item =&gt; \n      this.helpers.validateData(item.json, { required: ['id'] }).isValid\n    ),\n\n    // Step 3: Enrich data\n    (items) =&gt; items.map(item =&gt; ({\n      ...item,\n      json: {\n        ...item.json,\n        enrichedAt: new Date().toISOString()\n      }\n    })),\n\n    // Step 4: Format output\n    (items) =&gt; this.helpers.returnJsonArray(\n      items.map(item =&gt; item.json)\n    )\n  ])\n\n  return [transformedItems]\n}\n</code></pre>"},{"location":"public-api/helpers/base/#conditional-processing","title":"Conditional Processing","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n  const condition = this.getNodeParameter('condition', 0) as string\n\n  const processedItems = items.map(item =&gt; {\n    const shouldProcess = this.helpers.evaluateCondition(\n      condition,\n      item.json\n    )\n\n    if (shouldProcess) {\n      return {\n        json: {\n          ...item.json,\n          processed: true,\n          processedAt: new Date().toISOString()\n        }\n      }\n    }\n\n    return item\n  })\n\n  return [processedItems]\n}\n</code></pre>"},{"location":"public-api/helpers/base/#performance-optimization","title":"Performance Optimization","text":""},{"location":"public-api/helpers/base/#memory-management","title":"Memory Management","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n\n  // Process large datasets efficiently\n  const results = this.helpers.processLargeDataset(items, {\n    chunkSize: 1000,\n    memoryLimit: '500MB',\n    processor: async (chunk) =&gt; {\n      return chunk.map(item =&gt; ({\n        json: {\n          id: item.json.id,\n          processed: true\n        }\n      }))\n    }\n  })\n\n  return [results]\n}\n</code></pre>"},{"location":"public-api/helpers/base/#caching","title":"Caching","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n  const cacheKey = this.getNodeParameter('cacheKey', 0) as string\n\n  // Check cache first\n  const cached = this.helpers.getFromCache(cacheKey)\n  if (cached) {\n    return [cached]\n  }\n\n  // Process data\n  const processedItems = items.map(item =&gt; ({\n    json: {\n      ...item.json,\n      processed: true\n    }\n  }))\n\n  // Cache results\n  this.helpers.setCache(cacheKey, processedItems, {\n    ttl: 3600 // 1 hour\n  })\n\n  return [processedItems]\n}\n</code></pre>"},{"location":"public-api/helpers/base/#best-practices","title":"Best Practices","text":"<ol> <li>Always validate input data before processing</li> <li>Use appropriate data types for parameters and return values</li> <li>Handle errors gracefully with meaningful messages</li> <li>Log important operations for debugging</li> <li>Optimize for performance with large datasets</li> <li>Use caching for expensive operations</li> <li>Follow consistent naming conventions</li> </ol>"},{"location":"public-api/helpers/base/#error-handling","title":"Error Handling","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  try {\n    const items = this.getInputData()\n\n    // Validate input\n    if (!items || items.length === 0) {\n      throw new Error('No input data provided')\n    }\n\n    // Process items with error handling\n    const results = []\n    for (let i = 0; i &lt; items.length; i++) {\n      try {\n        const result = await this.helpers.processItem(items[i])\n        results.push(result)\n      } catch (itemError) {\n        this.helpers.logNodeOutput(`Error processing item ${i}`, itemError)\n\n        // Continue processing other items\n        results.push(this.helpers.createErrorItem(\n          items[i],\n          itemError,\n          i\n        ))\n      }\n    }\n\n    return [results]\n  } catch (error) {\n    throw new Error(`Node execution failed: ${error.message}`)\n  }\n}\n</code></pre>"},{"location":"public-api/helpers/base/#related-documentation","title":"Related Documentation","text":"<ul> <li>HTTP Helpers - For HTTP-specific operations</li> <li>Binary Data Helpers - For binary data handling</li> <li>Filesystem Helpers - For file operations</li> <li>IExecuteFunctions - Main execution context</li> <li>Error Handling - Advanced error handling patterns</li> </ul>"},{"location":"public-api/helpers/binary/","title":"Binary Helpers","text":"<p>Binary helpers provide methods for working with binary data, files, and attachments in n8n nodes.</p>"},{"location":"public-api/helpers/binary/#available-methods","title":"Available Methods","text":""},{"location":"public-api/helpers/binary/#preparebinarydatabinarydata-filepath-mimetype","title":"<code>prepareBinaryData(binaryData, filePath?, mimeType?)</code>","text":"<p>Prepares binary data for use in n8n workflows.</p> <pre><code>prepareBinaryData(\n  binaryData: Buffer | Readable,\n  filePath?: string,\n  mimeType?: string,\n): Promise&lt;IBinaryData&gt;\n</code></pre> <p>Parameters: - <code>binaryData</code> - Buffer or Readable stream containing the binary data - <code>filePath</code> - Optional filename (used for display and download) - <code>mimeType</code> - Optional MIME type (auto-detected if not provided)</p> <p>Returns: <code>IBinaryData</code> object that can be attached to node output</p> <p>Example: <pre><code>// From Buffer\nconst buffer = Buffer.from('Hello World', 'utf8');\nconst binaryData = await this.helpers.prepareBinaryData(\n  buffer,\n  'hello.txt',\n  'text/plain'\n);\n\n// From file download\nconst response = await this.helpers.httpRequest({\n  method: 'GET',\n  url: 'https://example.com/document.pdf',\n  encoding: 'arraybuffer',\n});\n\nconst binaryData = await this.helpers.prepareBinaryData(\n  Buffer.from(response),\n  'document.pdf',\n  'application/pdf'\n);\n\n// Return with binary data\nreturn [{\n  json: { success: true },\n  binary: { data: binaryData },\n}];\n</code></pre></p>"},{"location":"public-api/helpers/binary/#getbinarydatabufferitemindex-propertyname","title":"<code>getBinaryDataBuffer(itemIndex, propertyName)</code>","text":"<p>Gets binary data as a Buffer from a specific item and property.</p> <pre><code>getBinaryDataBuffer(itemIndex: number, propertyName: string): Promise&lt;Buffer&gt;\n</code></pre> <p>Parameters: - <code>itemIndex</code> - Index of the item containing the binary data - <code>propertyName</code> - Name of the binary property</p> <p>Example: <pre><code>// Get binary data from input\nconst buffer = await this.helpers.getBinaryDataBuffer(0, 'data');\n\n// Process the buffer\nconst processedBuffer = processImage(buffer);\n\n// Create new binary data\nconst newBinaryData = await this.helpers.prepareBinaryData(\n  processedBuffer,\n  'processed-image.jpg',\n  'image/jpeg'\n);\n</code></pre></p>"},{"location":"public-api/helpers/binary/#assertbinarydataitemindex-propertyname","title":"<code>assertBinaryData(itemIndex, propertyName)</code>","text":"<p>Asserts that binary data exists and returns it, throwing an error if not found.</p> <pre><code>assertBinaryData(itemIndex: number, propertyName: string): IBinaryData\n</code></pre> <p>Parameters: - <code>itemIndex</code> - Index of the item containing the binary data - <code>propertyName</code> - Name of the binary property</p> <p>Example: <pre><code>// Ensure binary data exists before processing\nconst binaryData = this.helpers.assertBinaryData(0, 'data');\n\nconsole.log(binaryData.fileName); // Original filename\nconsole.log(binaryData.mimeType); // MIME type\nconsole.log(binaryData.fileSize); // File size in bytes\n</code></pre></p>"},{"location":"public-api/helpers/binary/#setbinarydatabufferdata-binarydata","title":"<code>setBinaryDataBuffer(data, binaryData)</code>","text":"<p>Updates binary data with a new buffer.</p> <pre><code>setBinaryDataBuffer(data: IBinaryData, binaryData: Buffer): Promise&lt;IBinaryData&gt;\n</code></pre> <p>Parameters: - <code>data</code> - Existing IBinaryData object - <code>binaryData</code> - New buffer to set</p> <p>Example: <pre><code>const existingBinary = this.helpers.assertBinaryData(0, 'data');\nconst buffer = await this.helpers.getBinaryDataBuffer(0, 'data');\n\n// Process the buffer\nconst processedBuffer = await processFile(buffer);\n\n// Update the binary data\nconst updatedBinary = await this.helpers.setBinaryDataBuffer(\n  existingBinary,\n  processedBuffer\n);\n</code></pre></p>"},{"location":"public-api/helpers/binary/#binarytobufferbody","title":"<code>binaryToBuffer(body)</code>","text":"<p>Converts binary data to a Buffer.</p> <pre><code>binaryToBuffer(body: Buffer | Readable): Promise&lt;Buffer&gt;\n</code></pre> <p>Example: <pre><code>const stream = getReadableStream();\nconst buffer = await this.helpers.binaryToBuffer(stream);\n</code></pre></p>"},{"location":"public-api/helpers/binary/#binarytostringbody-encoding","title":"<code>binaryToString(body, encoding?)</code>","text":"<p>Converts binary data to a string.</p> <pre><code>binaryToString(body: Buffer | Readable, encoding?: BufferEncoding): Promise&lt;string&gt;\n</code></pre> <p>Parameters: - <code>body</code> - Buffer or Readable stream - <code>encoding</code> - Text encoding (default: 'utf8')</p> <p>Example: <pre><code>const buffer = await this.helpers.getBinaryDataBuffer(0, 'data');\nconst text = await this.helpers.binaryToString(buffer, 'utf8');\nconsole.log(text); // File contents as string\n</code></pre></p>"},{"location":"public-api/helpers/binary/#detectbinaryencodingbuffer","title":"<code>detectBinaryEncoding(buffer)</code>","text":"<p>Detects the text encoding of a buffer.</p> <pre><code>detectBinaryEncoding(buffer: Buffer): string\n</code></pre> <p>Example: <pre><code>const buffer = await this.helpers.getBinaryDataBuffer(0, 'data');\nconst encoding = this.helpers.detectBinaryEncoding(buffer);\nconsole.log(encoding); // 'utf8', 'ascii', 'utf16le', etc.\n\nconst text = await this.helpers.binaryToString(buffer, encoding as BufferEncoding);\n</code></pre></p>"},{"location":"public-api/helpers/binary/#binary-data-structure","title":"Binary Data Structure","text":""},{"location":"public-api/helpers/binary/#ibinarydata-interface","title":"<code>IBinaryData</code> Interface","text":"<pre><code>interface IBinaryData {\n  data: string;           // Base64 encoded data or file ID\n  mimeType: string;       // MIME type (e.g., 'image/jpeg')\n  fileName?: string;      // Original filename\n  directory?: string;     // Storage directory\n  fileExtension?: string; // File extension\n  fileSize?: string;      // File size in bytes (as string)\n  id?: string;           // Unique identifier\n}\n</code></pre>"},{"location":"public-api/helpers/binary/#common-use-cases","title":"Common Use Cases","text":""},{"location":"public-api/helpers/binary/#file-processing","title":"File Processing","text":"<pre><code>async function processFile(this: IExecuteFunctions, itemIndex: number) {\n  // Get the input binary data\n  const binaryData = this.helpers.assertBinaryData(itemIndex, 'data');\n  const buffer = await this.helpers.getBinaryDataBuffer(itemIndex, 'data');\n\n  // Process based on file type\n  if (binaryData.mimeType?.startsWith('image/')) {\n    return await processImage(buffer, binaryData.fileName);\n  } else if (binaryData.mimeType === 'application/pdf') {\n    return await processPDF(buffer, binaryData.fileName);\n  } else if (binaryData.mimeType?.startsWith('text/')) {\n    const text = await this.helpers.binaryToString(buffer);\n    return await processText(text, binaryData.fileName);\n  }\n\n  throw new NodeOperationError(\n    this.getNode(),\n    `Unsupported file type: ${binaryData.mimeType}`\n  );\n}\n</code></pre>"},{"location":"public-api/helpers/binary/#file-download","title":"File Download","text":"<pre><code>async function downloadFile(this: IExecuteFunctions, url: string, filename?: string) {\n  const response = await this.helpers.httpRequest({\n    method: 'GET',\n    url,\n    encoding: 'arraybuffer',\n    returnFullResponse: true,\n  });\n\n  // Extract filename from URL or Content-Disposition header\n  const finalFilename = filename || \n    extractFilenameFromHeader(response.headers['content-disposition']) ||\n    url.split('/').pop() ||\n    'downloaded-file';\n\n  // Get MIME type from response\n  const mimeType = response.headers['content-type'] || 'application/octet-stream';\n\n  const binaryData = await this.helpers.prepareBinaryData(\n    Buffer.from(response.body),\n    finalFilename,\n    mimeType\n  );\n\n  return {\n    json: {\n      filename: finalFilename,\n      size: response.body.length,\n      mimeType,\n    },\n    binary: { data: binaryData },\n  };\n}\n</code></pre>"},{"location":"public-api/helpers/binary/#file-upload","title":"File Upload","text":"<pre><code>async function uploadFile(this: IExecuteFunctions, itemIndex: number, uploadUrl: string) {\n  const binaryData = this.helpers.assertBinaryData(itemIndex, 'data');\n  const buffer = await this.helpers.getBinaryDataBuffer(itemIndex, 'data');\n\n  const formData = new FormData();\n  formData.append('file', buffer, {\n    filename: binaryData.fileName || 'upload',\n    contentType: binaryData.mimeType,\n  });\n\n  const response = await this.helpers.httpRequest({\n    method: 'POST',\n    url: uploadUrl,\n    body: formData,\n    headers: formData.getHeaders(),\n  });\n\n  return {\n    json: {\n      uploaded: true,\n      filename: binaryData.fileName,\n      response,\n    },\n  };\n}\n</code></pre>"},{"location":"public-api/helpers/binary/#text-file-processing","title":"Text File Processing","text":"<pre><code>async function processTextFile(this: IExecuteFunctions, itemIndex: number) {\n  const binaryData = this.helpers.assertBinaryData(itemIndex, 'data');\n  const buffer = await this.helpers.getBinaryDataBuffer(itemIndex, 'data');\n\n  // Detect encoding\n  const encoding = this.helpers.detectBinaryEncoding(buffer);\n\n  // Convert to string\n  const content = await this.helpers.binaryToString(buffer, encoding as BufferEncoding);\n\n  // Process content (e.g., parse CSV, JSON, etc.)\n  let processedData;\n  if (binaryData.fileName?.endsWith('.json')) {\n    processedData = JSON.parse(content);\n  } else if (binaryData.fileName?.endsWith('.csv')) {\n    processedData = parseCSV(content);\n  } else {\n    processedData = { content, lines: content.split('\\n').length };\n  }\n\n  return {\n    json: {\n      filename: binaryData.fileName,\n      encoding,\n      size: buffer.length,\n      ...processedData,\n    },\n  };\n}\n</code></pre>"},{"location":"public-api/helpers/binary/#image-processing","title":"Image Processing","text":"<pre><code>async function processImage(this: IExecuteFunctions, itemIndex: number) {\n  const binaryData = this.helpers.assertBinaryData(itemIndex, 'data');\n\n  if (!binaryData.mimeType?.startsWith('image/')) {\n    throw new NodeOperationError(\n      this.getNode(),\n      'Input must be an image file'\n    );\n  }\n\n  const buffer = await this.helpers.getBinaryDataBuffer(itemIndex, 'data');\n\n  // Process image (example: resize)\n  const processedBuffer = await resizeImage(buffer, 800, 600);\n\n  // Create new binary data\n  const newBinaryData = await this.helpers.prepareBinaryData(\n    processedBuffer,\n    `resized-${binaryData.fileName}`,\n    binaryData.mimeType\n  );\n\n  return {\n    json: {\n      originalSize: buffer.length,\n      newSize: processedBuffer.length,\n      filename: binaryData.fileName,\n    },\n    binary: { data: newBinaryData },\n  };\n}\n</code></pre>"},{"location":"public-api/helpers/binary/#multiple-binary-properties","title":"Multiple Binary Properties","text":"<pre><code>async function handleMultipleBinaries(this: IExecuteFunctions) {\n  const items = this.getInputData();\n  const returnData: INodeExecutionData[] = [];\n\n  for (let i = 0; i &lt; items.length; i++) {\n    const item = items[i];\n    const newBinary: IBinaryKeyData = {};\n\n    // Process each binary property\n    if (item.binary) {\n      for (const [key, binaryData] of Object.entries(item.binary)) {\n        const buffer = await this.helpers.getBinaryDataBuffer(i, key);\n\n        // Process the binary data\n        const processedBuffer = await processFile(buffer);\n\n        // Create new binary data\n        newBinary[`processed_${key}`] = await this.helpers.prepareBinaryData(\n          processedBuffer,\n          `processed-${binaryData.fileName}`,\n          binaryData.mimeType\n        );\n      }\n    }\n\n    returnData.push({\n      json: item.json,\n      binary: newBinary,\n      pairedItem: { item: i },\n    });\n  }\n\n  return [returnData];\n}\n</code></pre>"},{"location":"public-api/helpers/binary/#file-type-detection","title":"File Type Detection","text":""},{"location":"public-api/helpers/binary/#mime-type-utilities","title":"MIME Type Utilities","text":"<pre><code>function getMimeTypeFromExtension(filename: string): string {\n  const ext = filename.split('.').pop()?.toLowerCase();\n\n  const mimeTypes: Record&lt;string, string&gt; = {\n    'pdf': 'application/pdf',\n    'jpg': 'image/jpeg',\n    'jpeg': 'image/jpeg',\n    'png': 'image/png',\n    'gif': 'image/gif',\n    'txt': 'text/plain',\n    'csv': 'text/csv',\n    'json': 'application/json',\n    'xml': 'application/xml',\n    'zip': 'application/zip',\n    'doc': 'application/msword',\n    'docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n    'xls': 'application/vnd.ms-excel',\n    'xlsx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n  };\n\n  return mimeTypes[ext || ''] || 'application/octet-stream';\n}\n\nfunction getFileExtension(mimeType: string): string {\n  const extensions: Record&lt;string, string&gt; = {\n    'application/pdf': 'pdf',\n    'image/jpeg': 'jpg',\n    'image/png': 'png',\n    'image/gif': 'gif',\n    'text/plain': 'txt',\n    'text/csv': 'csv',\n    'application/json': 'json',\n    'application/xml': 'xml',\n    'application/zip': 'zip',\n  };\n\n  return extensions[mimeType] || 'bin';\n}\n</code></pre>"},{"location":"public-api/helpers/binary/#error-handling","title":"Error Handling","text":""},{"location":"public-api/helpers/binary/#safe-binary-access","title":"Safe Binary Access","text":"<pre><code>function safeBinaryAccess(this: IExecuteFunctions, itemIndex: number, propertyName: string) {\n  try {\n    return this.helpers.assertBinaryData(itemIndex, propertyName);\n  } catch (error) {\n    throw new NodeOperationError(\n      this.getNode(),\n      `No binary data found at property \"${propertyName}\" for item ${itemIndex}`,\n      { itemIndex }\n    );\n  }\n}\n</code></pre>"},{"location":"public-api/helpers/binary/#file-size-validation","title":"File Size Validation","text":"<pre><code>function validateFileSize(binaryData: IBinaryData, maxSizeMB: number = 10) {\n  const fileSizeBytes = parseInt(binaryData.fileSize || '0', 10);\n  const maxSizeBytes = maxSizeMB * 1024 * 1024;\n\n  if (fileSizeBytes &gt; maxSizeBytes) {\n    throw new NodeOperationError(\n      this.getNode(),\n      `File size (${Math.round(fileSizeBytes / 1024 / 1024)}MB) exceeds maximum allowed size (${maxSizeMB}MB)`\n    );\n  }\n}\n</code></pre>"},{"location":"public-api/helpers/binary/#best-practices","title":"Best Practices","text":""},{"location":"public-api/helpers/binary/#1-always-check-binary-data-exists","title":"1. Always Check Binary Data Exists","text":"<pre><code>// \u2705 Good - Check before accessing\nif (item.binary?.data) {\n  const binaryData = this.helpers.assertBinaryData(i, 'data');\n  // Process binary data\n}\n\n// \u274c Bad - Assume binary data exists\nconst binaryData = this.helpers.assertBinaryData(i, 'data'); // May throw\n</code></pre>"},{"location":"public-api/helpers/binary/#2-handle-large-files-efficiently","title":"2. Handle Large Files Efficiently","text":"<pre><code>// \u2705 Good - Stream processing for large files\nconst stream = createReadStream(filePath);\nconst binaryData = await this.helpers.prepareBinaryData(stream, filename);\n\n// \u274c Bad - Loading entire file into memory\nconst buffer = readFileSync(filePath);\nconst binaryData = await this.helpers.prepareBinaryData(buffer, filename);\n</code></pre>"},{"location":"public-api/helpers/binary/#3-preserve-original-metadata","title":"3. Preserve Original Metadata","text":"<pre><code>// \u2705 Good - Preserve original filename and MIME type\nconst originalBinary = this.helpers.assertBinaryData(i, 'data');\nconst processedBinary = await this.helpers.prepareBinaryData(\n  processedBuffer,\n  originalBinary.fileName,\n  originalBinary.mimeType\n);\n\n// \u274c Bad - Lose original metadata\nconst processedBinary = await this.helpers.prepareBinaryData(processedBuffer);\n</code></pre>"},{"location":"public-api/helpers/binary/#4-use-appropriate-property-names","title":"4. Use Appropriate Property Names","text":"<pre><code>// \u2705 Good - Descriptive property names\nreturn [{\n  json: item.json,\n  binary: {\n    original: originalBinary,\n    thumbnail: thumbnailBinary,\n    processed: processedBinary,\n  },\n}];\n\n// \u274c Bad - Generic property names\nreturn [{\n  json: item.json,\n  binary: {\n    data1: originalBinary,\n    data2: thumbnailBinary,\n    data3: processedBinary,\n  },\n}];\n</code></pre>"},{"location":"public-api/helpers/binary/#see-also","title":"See Also","text":"<ul> <li>IExecuteFunctions - Main execution context</li> <li>HTTP Helpers - Making HTTP requests</li> <li>Filesystem Helpers - File system operations</li> <li>Binary Data Advanced - Advanced binary data handling</li> </ul>"},{"location":"public-api/helpers/deduplication/","title":"Deduplication Helpers","text":"<p>The deduplication helpers provide utilities for identifying and removing duplicate data within n8n workflows. These functions help optimize data processing by eliminating redundant items based on various criteria.</p>"},{"location":"public-api/helpers/deduplication/#when-to-use","title":"When to Use","text":"<p>Use deduplication helpers when your node needs to: - Remove duplicate items from datasets - Identify unique records based on specific fields - Merge similar items with different data - Optimize data processing by reducing redundancy - Implement data quality controls</p>"},{"location":"public-api/helpers/deduplication/#available-functions","title":"Available Functions","text":""},{"location":"public-api/helpers/deduplication/#deduplicateitems","title":"<code>deduplicateItems()</code>","text":"<p>Removes duplicate items from an array based on specified criteria.</p> <pre><code>import { IExecuteFunctions } from 'n8n-workflow'\n\nexport async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n  const dedupeField = this.getNodeParameter('dedupeField', 0) as string\n\n  // Deduplicate based on a specific field\n  const uniqueItems = this.helpers.deduplicateItems(items, {\n    key: dedupeField,\n    strategy: 'first' // Keep first occurrence\n  })\n\n  return [uniqueItems]\n}\n</code></pre>"},{"location":"public-api/helpers/deduplication/#creatededuplicationkey","title":"<code>createDeduplicationKey()</code>","text":"<p>Creates a unique key for deduplication based on multiple fields.</p> <pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n  const keyFields = this.getNodeParameter('keyFields', 0) as string[]\n\n  const processedItems = items.map(item =&gt; {\n    const dedupeKey = this.helpers.createDeduplicationKey(\n      item.json,\n      keyFields\n    )\n\n    return {\n      ...item,\n      json: {\n        ...item.json,\n        _dedupeKey: dedupeKey\n      }\n    }\n  })\n\n  return [processedItems]\n}\n</code></pre>"},{"location":"public-api/helpers/deduplication/#findduplicates","title":"<code>findDuplicates()</code>","text":"<p>Identifies duplicate items without removing them.</p> <pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n  const keyField = this.getNodeParameter('keyField', 0) as string\n\n  const duplicates = this.helpers.findDuplicates(items, {\n    key: keyField,\n    includeOriginal: true\n  })\n\n  return [{\n    json: {\n      totalItems: items.length,\n      duplicateCount: duplicates.length,\n      duplicates: duplicates.map(item =&gt; item.json)\n    }\n  }]\n}\n</code></pre>"},{"location":"public-api/helpers/deduplication/#deduplication-strategies","title":"Deduplication Strategies","text":""},{"location":"public-api/helpers/deduplication/#first-occurrence-strategy","title":"First Occurrence Strategy","text":"<p>Keep the first occurrence of duplicate items:</p> <pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n\n  const uniqueItems = this.helpers.deduplicateItems(items, {\n    key: 'email',\n    strategy: 'first'\n  })\n\n  return [uniqueItems]\n}\n</code></pre>"},{"location":"public-api/helpers/deduplication/#last-occurrence-strategy","title":"Last Occurrence Strategy","text":"<p>Keep the last occurrence of duplicate items:</p> <pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n\n  const uniqueItems = this.helpers.deduplicateItems(items, {\n    key: 'id',\n    strategy: 'last'\n  })\n\n  return [uniqueItems]\n}\n</code></pre>"},{"location":"public-api/helpers/deduplication/#merge-strategy","title":"Merge Strategy","text":"<p>Merge duplicate items by combining their data:</p> <pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n\n  const mergedItems = this.helpers.deduplicateItems(items, {\n    key: 'userId',\n    strategy: 'merge',\n    mergeFunction: (existing, duplicate) =&gt; ({\n      ...existing.json,\n      ...duplicate.json,\n      // Combine arrays\n      tags: [...(existing.json.tags || []), ...(duplicate.json.tags || [])],\n      // Keep latest timestamp\n      lastUpdated: Math.max(existing.json.lastUpdated, duplicate.json.lastUpdated)\n    })\n  })\n\n  return [mergedItems]\n}\n</code></pre>"},{"location":"public-api/helpers/deduplication/#common-patterns","title":"Common Patterns","text":""},{"location":"public-api/helpers/deduplication/#multi-field-deduplication","title":"Multi-Field Deduplication","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n\n  // Create composite key from multiple fields\n  const uniqueItems = this.helpers.deduplicateItems(items, {\n    keyFunction: (item) =&gt; {\n      const { firstName, lastName, email } = item.json\n      return `${firstName}|${lastName}|${email}`.toLowerCase()\n    },\n    strategy: 'first'\n  })\n\n  return [uniqueItems]\n}\n</code></pre>"},{"location":"public-api/helpers/deduplication/#case-insensitive-deduplication","title":"Case-Insensitive Deduplication","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n\n  const uniqueItems = this.helpers.deduplicateItems(items, {\n    key: 'email',\n    normalizeFunction: (value) =&gt; value.toLowerCase().trim(),\n    strategy: 'first'\n  })\n\n  return [uniqueItems]\n}\n</code></pre>"},{"location":"public-api/helpers/deduplication/#fuzzy-deduplication","title":"Fuzzy Deduplication","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n\n  // Use similarity threshold for fuzzy matching\n  const uniqueItems = this.helpers.deduplicateItems(items, {\n    key: 'companyName',\n    strategy: 'fuzzy',\n    similarityThreshold: 0.85,\n    normalizeFunction: (value) =&gt; value.toLowerCase().replace(/[^a-z0-9]/g, '')\n  })\n\n  return [uniqueItems]\n}\n</code></pre>"},{"location":"public-api/helpers/deduplication/#batch-deduplication","title":"Batch Deduplication","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n  const batchSize = this.getNodeParameter('batchSize', 0, 1000) as number\n\n  const allUniqueItems = []\n\n  // Process in batches to handle large datasets\n  for (let i = 0; i &lt; items.length; i += batchSize) {\n    const batch = items.slice(i, i + batchSize)\n\n    const uniqueBatch = this.helpers.deduplicateItems(batch, {\n      key: 'id',\n      strategy: 'first'\n    })\n\n    allUniqueItems.push(...uniqueBatch)\n  }\n\n  // Final deduplication across all batches\n  const finalUniqueItems = this.helpers.deduplicateItems(allUniqueItems, {\n    key: 'id',\n    strategy: 'first'\n  })\n\n  return [finalUniqueItems]\n}\n</code></pre>"},{"location":"public-api/helpers/deduplication/#advanced-use-cases","title":"Advanced Use Cases","text":""},{"location":"public-api/helpers/deduplication/#conditional-deduplication","title":"Conditional Deduplication","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n  const onlyActive = this.getNodeParameter('onlyActive', 0, false) as boolean\n\n  let itemsToProcess = items\n\n  // Pre-filter if needed\n  if (onlyActive) {\n    itemsToProcess = items.filter(item =&gt; item.json.status === 'active')\n  }\n\n  const uniqueItems = this.helpers.deduplicateItems(itemsToProcess, {\n    key: 'email',\n    strategy: 'custom',\n    customStrategy: (existing, duplicate) =&gt; {\n      // Keep item with higher priority\n      const existingPriority = existing.json.priority || 0\n      const duplicatePriority = duplicate.json.priority || 0\n\n      return duplicatePriority &gt; existingPriority ? duplicate : existing\n    }\n  })\n\n  return [uniqueItems]\n}\n</code></pre>"},{"location":"public-api/helpers/deduplication/#deduplication-with-statistics","title":"Deduplication with Statistics","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n\n  const result = this.helpers.deduplicateItems(items, {\n    key: 'email',\n    strategy: 'first',\n    includeStats: true\n  })\n\n  return [{\n    json: {\n      originalCount: items.length,\n      uniqueCount: result.items.length,\n      duplicatesRemoved: result.stats.duplicatesRemoved,\n      duplicateGroups: result.stats.duplicateGroups,\n      items: result.items.map(item =&gt; item.json)\n    }\n  }]\n}\n</code></pre>"},{"location":"public-api/helpers/deduplication/#cross-reference-deduplication","title":"Cross-Reference Deduplication","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n  const referenceData = this.getNodeParameter('referenceData', 0) as any[]\n\n  // Remove items that already exist in reference dataset\n  const newItems = this.helpers.deduplicateItems(items, {\n    key: 'id',\n    strategy: 'exclude',\n    referenceSet: new Set(referenceData.map(ref =&gt; ref.id))\n  })\n\n  return [newItems]\n}\n</code></pre>"},{"location":"public-api/helpers/deduplication/#performance-considerations","title":"Performance Considerations","text":""},{"location":"public-api/helpers/deduplication/#memory-efficient-deduplication","title":"Memory-Efficient Deduplication","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n\n  // Use streaming deduplication for large datasets\n  const uniqueItems = this.helpers.deduplicateItemsStream(items, {\n    key: 'id',\n    strategy: 'first',\n    memoryLimit: '100MB'\n  })\n\n  return [uniqueItems]\n}\n</code></pre>"},{"location":"public-api/helpers/deduplication/#index-based-deduplication","title":"Index-Based Deduplication","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n\n  // Create index for faster lookups\n  const dedupeIndex = this.helpers.createDeduplicationIndex(items, 'email')\n\n  const uniqueItems = this.helpers.deduplicateWithIndex(items, {\n    index: dedupeIndex,\n    strategy: 'first'\n  })\n\n  return [uniqueItems]\n}\n</code></pre>"},{"location":"public-api/helpers/deduplication/#best-practices","title":"Best Practices","text":"<ol> <li>Choose appropriate keys for deduplication based on business logic</li> <li>Consider data normalization for consistent matching</li> <li>Use batch processing for large datasets</li> <li>Implement proper error handling for malformed data</li> <li>Monitor performance with large datasets</li> <li>Document deduplication logic for maintainability</li> <li>Test edge cases like null values and empty strings</li> </ol>"},{"location":"public-api/helpers/deduplication/#error-handling","title":"Error Handling","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n  const keyField = this.getNodeParameter('keyField', 0) as string\n\n  try {\n    // Validate that key field exists in all items\n    const invalidItems = items.filter(item =&gt; \n      !item.json.hasOwnProperty(keyField) || \n      item.json[keyField] === null || \n      item.json[keyField] === undefined\n    )\n\n    if (invalidItems.length &gt; 0) {\n      throw new Error(`${invalidItems.length} items missing required field: ${keyField}`)\n    }\n\n    const uniqueItems = this.helpers.deduplicateItems(items, {\n      key: keyField,\n      strategy: 'first'\n    })\n\n    return [uniqueItems]\n  } catch (error) {\n    throw new Error(`Deduplication failed: ${error.message}`)\n  }\n}\n</code></pre>"},{"location":"public-api/helpers/deduplication/#related-documentation","title":"Related Documentation","text":"<ul> <li>Base Helpers - Core helper functions</li> <li>Binary Data Helpers - For deduplicating binary data</li> <li>IExecuteFunctions - Main execution context</li> <li>Error Handling - Advanced error handling patterns</li> </ul>"},{"location":"public-api/helpers/filesystem/","title":"Filesystem Helpers","text":"<p>The filesystem helpers provide utilities for working with files and directories within n8n nodes. These functions handle common file operations while respecting n8n's security constraints and execution environment.</p>"},{"location":"public-api/helpers/filesystem/#when-to-use","title":"When to Use","text":"<p>Use filesystem helpers when your node needs to: - Read or write temporary files during execution - Process file uploads or downloads - Work with local file storage - Handle file metadata and properties - Manage temporary directories for processing</p>"},{"location":"public-api/helpers/filesystem/#available-functions","title":"Available Functions","text":""},{"location":"public-api/helpers/filesystem/#writetemporaryfile","title":"<code>writeTemporaryFile()</code>","text":"<p>Writes data to a temporary file that will be cleaned up after execution.</p> <pre><code>import { IExecuteFunctions } from 'n8n-workflow'\n\nexport async function execute(this: IExecuteFunctions) {\n  const data = this.getInputData()\n\n  // Write temporary file\n  const tempFilePath = await this.helpers.writeTemporaryFile(\n    Buffer.from('Hello, World!'),\n    'temp-file.txt'\n  )\n\n  // Use the file path for further processing\n  console.log('Temporary file created at:', tempFilePath)\n\n  return [data]\n}\n</code></pre>"},{"location":"public-api/helpers/filesystem/#readtemporaryfile","title":"<code>readTemporaryFile()</code>","text":"<p>Reads data from a temporary file.</p> <pre><code>export async function execute(this: IExecuteFunctions) {\n  const filePath = this.getNodeParameter('filePath', 0) as string\n\n  try {\n    const fileContent = await this.helpers.readTemporaryFile(filePath)\n\n    return [{\n      json: {\n        content: fileContent.toString(),\n        size: fileContent.length\n      }\n    }]\n  } catch (error) {\n    throw new Error(`Failed to read file: ${error.message}`)\n  }\n}\n</code></pre>"},{"location":"public-api/helpers/filesystem/#createtemporarydirectory","title":"<code>createTemporaryDirectory()</code>","text":"<p>Creates a temporary directory for file operations.</p> <pre><code>export async function execute(this: IExecuteFunctions) {\n  const tempDir = await this.helpers.createTemporaryDirectory()\n\n  // Use the directory for multiple file operations\n  const file1Path = path.join(tempDir, 'file1.txt')\n  const file2Path = path.join(tempDir, 'file2.txt')\n\n  // Directory will be cleaned up automatically\n\n  return [{ json: { tempDirectory: tempDir } }]\n}\n</code></pre>"},{"location":"public-api/helpers/filesystem/#common-patterns","title":"Common Patterns","text":""},{"location":"public-api/helpers/filesystem/#processing-multiple-files","title":"Processing Multiple Files","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n  const returnData = []\n\n  for (let i = 0; i &lt; items.length; i++) {\n    const binaryData = this.helpers.assertBinaryData(i, 'data')\n\n    // Write binary data to temporary file\n    const tempFile = await this.helpers.writeTemporaryFile(\n      binaryData.data,\n      binaryData.fileName || 'input-file'\n    )\n\n    // Process the file\n    const processedContent = await processFile(tempFile)\n\n    returnData.push({\n      json: {\n        originalFileName: binaryData.fileName,\n        processedSize: processedContent.length\n      },\n      binary: {\n        data: await this.helpers.prepareBinaryData(\n          Buffer.from(processedContent),\n          `processed-${binaryData.fileName}`\n        )\n      }\n    })\n  }\n\n  return [returnData]\n}\n</code></pre>"},{"location":"public-api/helpers/filesystem/#file-validation-and-metadata","title":"File Validation and Metadata","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const filePath = this.getNodeParameter('filePath', 0) as string\n\n  try {\n    // Check if file exists and get metadata\n    const stats = await this.helpers.getFileStats(filePath)\n\n    if (!stats.isFile()) {\n      throw new Error('Path does not point to a file')\n    }\n\n    // Validate file size\n    const maxSize = 10 * 1024 * 1024 // 10MB\n    if (stats.size &gt; maxSize) {\n      throw new Error('File too large')\n    }\n\n    return [{\n      json: {\n        fileName: path.basename(filePath),\n        size: stats.size,\n        modified: stats.mtime,\n        isReadable: await this.helpers.isFileReadable(filePath)\n      }\n    }]\n  } catch (error) {\n    throw new Error(`File validation failed: ${error.message}`)\n  }\n}\n</code></pre>"},{"location":"public-api/helpers/filesystem/#security-considerations","title":"Security Considerations","text":""},{"location":"public-api/helpers/filesystem/#path-traversal-protection","title":"Path Traversal Protection","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const userPath = this.getNodeParameter('path', 0) as string\n\n  // Validate and sanitize the path\n  const safePath = await this.helpers.sanitizeFilePath(userPath)\n\n  if (!safePath) {\n    throw new Error('Invalid file path provided')\n  }\n\n  // Ensure path is within allowed directories\n  if (!await this.helpers.isPathAllowed(safePath)) {\n    throw new Error('Access to this path is not allowed')\n  }\n\n  return [{ json: { safePath } }]\n}\n</code></pre>"},{"location":"public-api/helpers/filesystem/#file-type-validation","title":"File Type Validation","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const allowedExtensions = ['.txt', '.csv', '.json']\n  const filePath = this.getNodeParameter('filePath', 0) as string\n\n  const extension = path.extname(filePath).toLowerCase()\n\n  if (!allowedExtensions.includes(extension)) {\n    throw new Error(`File type ${extension} is not allowed`)\n  }\n\n  // Additional MIME type validation\n  const mimeType = await this.helpers.getMimeType(filePath)\n  const allowedMimeTypes = ['text/plain', 'text/csv', 'application/json']\n\n  if (!allowedMimeTypes.includes(mimeType)) {\n    throw new Error(`MIME type ${mimeType} is not allowed`)\n  }\n\n  return [{ json: { filePath, mimeType } }]\n}\n</code></pre>"},{"location":"public-api/helpers/filesystem/#best-practices","title":"Best Practices","text":"<ol> <li>Always use temporary files for intermediate processing</li> <li>Validate file paths to prevent security issues</li> <li>Check file sizes before processing large files</li> <li>Handle errors gracefully with meaningful messages</li> <li>Clean up resources (though n8n handles this automatically for temp files)</li> <li>Use appropriate file permissions when creating files</li> <li>Validate file types before processing</li> </ol>"},{"location":"public-api/helpers/filesystem/#error-handling","title":"Error Handling","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  try {\n    const filePath = this.getNodeParameter('filePath', 0) as string\n\n    // Comprehensive file operation with error handling\n    if (!await this.helpers.fileExists(filePath)) {\n      throw new Error('File does not exist')\n    }\n\n    const content = await this.helpers.readTemporaryFile(filePath)\n\n    return [{\n      json: {\n        success: true,\n        content: content.toString()\n      }\n    }]\n  } catch (error) {\n    if (error.code === 'ENOENT') {\n      throw new Error('File not found')\n    } else if (error.code === 'EACCES') {\n      throw new Error('Permission denied')\n    } else if (error.code === 'EISDIR') {\n      throw new Error('Path is a directory, not a file')\n    } else {\n      throw new Error(`File operation failed: ${error.message}`)\n    }\n  }\n}\n</code></pre>"},{"location":"public-api/helpers/filesystem/#related-documentation","title":"Related Documentation","text":"<ul> <li>Binary Data Helpers - For handling binary file data</li> <li>HTTP Helpers - For downloading files from URLs</li> <li>IExecuteFunctions - Main execution context</li> <li>Error Handling - Advanced error handling patterns</li> </ul>"},{"location":"public-api/helpers/http/","title":"HTTP Helpers","text":"<p>HTTP helpers provide methods for making HTTP requests with built-in authentication, error handling, and n8n-specific features.</p>"},{"location":"public-api/helpers/http/#available-methods","title":"Available Methods","text":""},{"location":"public-api/helpers/http/#httprequestoptions","title":"<code>httpRequest(options)</code>","text":"<p>Makes an HTTP request with modern options and better error handling.</p> <pre><code>httpRequest(options: IHttpRequestOptions): Promise&lt;any&gt;\n</code></pre> <p>Parameters: - <code>options</code> - HTTP request configuration</p> <p>Example: <pre><code>const response = await this.helpers.httpRequest({\n  method: 'GET',\n  url: 'https://api.example.com/users',\n  headers: {\n    'Authorization': 'Bearer token123',\n    'Content-Type': 'application/json',\n  },\n  qs: {\n    limit: 10,\n    page: 1,\n  },\n});\n</code></pre></p>"},{"location":"public-api/helpers/http/#httprequestwithauthenticationcredentialstype-options-additionalcredentialoptions","title":"<code>httpRequestWithAuthentication(credentialsType, options, additionalCredentialOptions?)</code>","text":"<p>Makes an HTTP request with automatic credential authentication.</p> <pre><code>httpRequestWithAuthentication(\n  this: IAllExecuteFunctions,\n  credentialsType: string,\n  requestOptions: IHttpRequestOptions,\n  additionalCredentialOptions?: IAdditionalCredentialOptions,\n): Promise&lt;any&gt;\n</code></pre> <p>Parameters: - <code>credentialsType</code> - Type of credentials to use - <code>requestOptions</code> - HTTP request configuration - <code>additionalCredentialOptions</code> - Additional credential options</p> <p>Example: <pre><code>// Using OAuth2 credentials\nconst response = await this.helpers.httpRequestWithAuthentication(\n  'googleOAuth2Api',\n  {\n    method: 'GET',\n    url: 'https://www.googleapis.com/drive/v3/files',\n  }\n);\n\n// Using API key credentials\nconst response = await this.helpers.httpRequestWithAuthentication(\n  'slackApi',\n  {\n    method: 'POST',\n    url: 'https://slack.com/api/chat.postMessage',\n    body: {\n      channel: '#general',\n      text: 'Hello from n8n!',\n    },\n  }\n);\n</code></pre></p>"},{"location":"public-api/helpers/http/#request-options","title":"Request Options","text":""},{"location":"public-api/helpers/http/#ihttprequestoptions","title":"<code>IHttpRequestOptions</code>","text":"<p>Configuration object for HTTP requests.</p> <pre><code>interface IHttpRequestOptions {\n  url: string;\n  method?: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH' | 'HEAD';\n  headers?: IDataObject;\n  body?: any;\n  qs?: IDataObject;\n  json?: boolean;\n  returnFullResponse?: boolean;\n  ignoreHttpStatusErrors?: boolean;\n  timeout?: number;\n  encoding?: string;\n  skipSslCertificateValidation?: boolean;\n  proxy?: ProxyConfig;\n  abortSignal?: AbortSignal;\n}\n</code></pre>"},{"location":"public-api/helpers/http/#common-options","title":"Common Options","text":""},{"location":"public-api/helpers/http/#basic-get-request","title":"Basic GET Request","text":"<pre><code>const response = await this.helpers.httpRequest({\n  method: 'GET',\n  url: 'https://api.example.com/data',\n});\n</code></pre>"},{"location":"public-api/helpers/http/#post-with-json-body","title":"POST with JSON Body","text":"<pre><code>const response = await this.helpers.httpRequest({\n  method: 'POST',\n  url: 'https://api.example.com/users',\n  headers: {\n    'Content-Type': 'application/json',\n  },\n  body: {\n    name: 'John Doe',\n    email: 'john@example.com',\n  },\n  json: true, // Automatically stringify body and parse response\n});\n</code></pre>"},{"location":"public-api/helpers/http/#query-parameters","title":"Query Parameters","text":"<pre><code>const response = await this.helpers.httpRequest({\n  method: 'GET',\n  url: 'https://api.example.com/search',\n  qs: {\n    q: 'search term',\n    limit: 10,\n    offset: 0,\n  },\n});\n</code></pre>"},{"location":"public-api/helpers/http/#custom-headers","title":"Custom Headers","text":"<pre><code>const response = await this.helpers.httpRequest({\n  method: 'GET',\n  url: 'https://api.example.com/data',\n  headers: {\n    'Authorization': 'Bearer token123',\n    'User-Agent': 'n8n-custom-node/1.0',\n    'X-Custom-Header': 'value',\n  },\n});\n</code></pre>"},{"location":"public-api/helpers/http/#full-response","title":"Full Response","text":"<pre><code>const response = await this.helpers.httpRequest({\n  method: 'GET',\n  url: 'https://api.example.com/data',\n  returnFullResponse: true,\n});\n\nconsole.log(response.statusCode); // 200\nconsole.log(response.headers); // Response headers\nconsole.log(response.body); // Response body\n</code></pre>"},{"location":"public-api/helpers/http/#error-handling","title":"Error Handling","text":"<pre><code>const response = await this.helpers.httpRequest({\n  method: 'GET',\n  url: 'https://api.example.com/data',\n  ignoreHttpStatusErrors: true, // Don't throw on 4xx/5xx\n});\n\nif (response.statusCode &gt;= 400) {\n  // Handle error response\n  console.log('Error:', response.body);\n}\n</code></pre>"},{"location":"public-api/helpers/http/#timeout","title":"Timeout","text":"<pre><code>const response = await this.helpers.httpRequest({\n  method: 'GET',\n  url: 'https://api.example.com/slow-endpoint',\n  timeout: 30000, // 30 seconds\n});\n</code></pre>"},{"location":"public-api/helpers/http/#ssl-certificate-validation","title":"SSL Certificate Validation","text":"<pre><code>const response = await this.helpers.httpRequest({\n  method: 'GET',\n  url: 'https://self-signed.example.com/api',\n  skipSslCertificateValidation: true,\n});\n</code></pre>"},{"location":"public-api/helpers/http/#authentication-examples","title":"Authentication Examples","text":""},{"location":"public-api/helpers/http/#oauth2","title":"OAuth2","text":"<pre><code>// Credentials are automatically applied\nconst response = await this.helpers.httpRequestWithAuthentication(\n  'googleOAuth2Api',\n  {\n    method: 'GET',\n    url: 'https://www.googleapis.com/calendar/v3/calendars/primary/events',\n  }\n);\n</code></pre>"},{"location":"public-api/helpers/http/#api-key-in-header","title":"API Key in Header","text":"<pre><code>const response = await this.helpers.httpRequestWithAuthentication(\n  'openAiApi', // Credential type that adds API key to headers\n  {\n    method: 'POST',\n    url: 'https://api.openai.com/v1/chat/completions',\n    body: {\n      model: 'gpt-3.5-turbo',\n      messages: [{ role: 'user', content: 'Hello!' }],\n    },\n  }\n);\n</code></pre>"},{"location":"public-api/helpers/http/#basic-authentication","title":"Basic Authentication","text":"<pre><code>const response = await this.helpers.httpRequestWithAuthentication(\n  'httpBasicAuth',\n  {\n    method: 'GET',\n    url: 'https://api.example.com/protected',\n  }\n);\n</code></pre>"},{"location":"public-api/helpers/http/#custom-authentication","title":"Custom Authentication","text":"<pre><code>// For credentials that need custom handling\nconst credentials = await this.getCredentials('customApi');\nconst response = await this.helpers.httpRequest({\n  method: 'GET',\n  url: 'https://api.example.com/data',\n  headers: {\n    'X-API-Key': credentials.apiKey,\n    'X-Secret': credentials.secret,\n  },\n});\n</code></pre>"},{"location":"public-api/helpers/http/#pagination-helper","title":"Pagination Helper","text":""},{"location":"public-api/helpers/http/#requestwithauthenticationpaginatedrequestoptions-itemindex-paginationoptions-credentialstype-additionalcredentialoptions","title":"<code>requestWithAuthenticationPaginated(requestOptions, itemIndex, paginationOptions, credentialsType?, additionalCredentialOptions?)</code>","text":"<p>Handles paginated API responses automatically.</p> <pre><code>requestWithAuthenticationPaginated(\n  this: IAllExecuteFunctions,\n  requestOptions: IRequestOptions,\n  itemIndex: number,\n  paginationOptions: PaginationOptions,\n  credentialsType?: string,\n  additionalCredentialOptions?: IAdditionalCredentialOptions,\n): Promise&lt;any[]&gt;\n</code></pre> <p>Example: <pre><code>const allResults = await this.helpers.requestWithAuthenticationPaginated(\n  {\n    method: 'GET',\n    url: 'https://api.example.com/users',\n    qs: {\n      limit: 100,\n    },\n  },\n  0, // itemIndex\n  {\n    continue: true,\n    request: {\n      qs: {\n        page: '={{$response.nextPage}}',\n      },\n    },\n    requestInterval: 1000, // 1 second between requests\n    maxRequests: 10, // Maximum 10 requests\n  },\n  'apiKeyAuth'\n);\n</code></pre></p>"},{"location":"public-api/helpers/http/#error-handling_1","title":"Error Handling","text":""},{"location":"public-api/helpers/http/#http-status-errors","title":"HTTP Status Errors","text":"<pre><code>try {\n  const response = await this.helpers.httpRequest({\n    method: 'GET',\n    url: 'https://api.example.com/data',\n  });\n} catch (error) {\n  if (error.response) {\n    // HTTP error response\n    console.log('Status:', error.response.status);\n    console.log('Body:', error.response.body);\n  } else {\n    // Network or other error\n    console.log('Error:', error.message);\n  }\n}\n</code></pre>"},{"location":"public-api/helpers/http/#graceful-error-handling","title":"Graceful Error Handling","text":"<pre><code>const response = await this.helpers.httpRequest({\n  method: 'GET',\n  url: 'https://api.example.com/data',\n  ignoreHttpStatusErrors: true,\n  returnFullResponse: true,\n});\n\nif (response.statusCode &gt;= 200 &amp;&amp; response.statusCode &lt; 300) {\n  // Success\n  return response.body;\n} else {\n  // Handle error gracefully\n  return {\n    error: true,\n    statusCode: response.statusCode,\n    message: response.body?.message || 'Request failed',\n  };\n}\n</code></pre>"},{"location":"public-api/helpers/http/#advanced-examples","title":"Advanced Examples","text":""},{"location":"public-api/helpers/http/#file-upload","title":"File Upload","text":"<pre><code>import FormData from 'form-data';\n\nconst formData = new FormData();\nformData.append('file', buffer, 'filename.pdf');\nformData.append('description', 'Uploaded via n8n');\n\nconst response = await this.helpers.httpRequest({\n  method: 'POST',\n  url: 'https://api.example.com/upload',\n  body: formData,\n  headers: formData.getHeaders(),\n});\n</code></pre>"},{"location":"public-api/helpers/http/#binary-response","title":"Binary Response","text":"<pre><code>const response = await this.helpers.httpRequest({\n  method: 'GET',\n  url: 'https://api.example.com/download/file.pdf',\n  encoding: 'arraybuffer', // Get binary data\n  returnFullResponse: true,\n});\n\nconst binaryData = await this.helpers.prepareBinaryData(\n  Buffer.from(response.body),\n  'downloaded-file.pdf',\n  'application/pdf'\n);\n</code></pre>"},{"location":"public-api/helpers/http/#retry-logic","title":"Retry Logic","text":"<pre><code>async function makeRequestWithRetry(\n  this: IExecuteFunctions,\n  options: IHttpRequestOptions,\n  maxRetries = 3\n): Promise&lt;any&gt; {\n  for (let attempt = 1; attempt &lt;= maxRetries; attempt++) {\n    try {\n      return await this.helpers.httpRequest(options);\n    } catch (error) {\n      if (attempt === maxRetries) {\n        throw error;\n      }\n\n      // Wait before retry (exponential backoff)\n      const delay = Math.pow(2, attempt) * 1000;\n      await new Promise(resolve =&gt; setTimeout(resolve, delay));\n    }\n  }\n}\n</code></pre>"},{"location":"public-api/helpers/http/#rate-limiting","title":"Rate Limiting","text":"<pre><code>class RateLimiter {\n  private lastRequest = 0;\n  private minInterval = 1000; // 1 second between requests\n\n  async makeRequest(this: IExecuteFunctions, options: IHttpRequestOptions) {\n    const now = Date.now();\n    const timeSinceLastRequest = now - this.lastRequest;\n\n    if (timeSinceLastRequest &lt; this.minInterval) {\n      const delay = this.minInterval - timeSinceLastRequest;\n      await new Promise(resolve =&gt; setTimeout(resolve, delay));\n    }\n\n    this.lastRequest = Date.now();\n    return this.helpers.httpRequest(options);\n  }\n}\n</code></pre>"},{"location":"public-api/helpers/http/#best-practices","title":"Best Practices","text":""},{"location":"public-api/helpers/http/#1-use-type-safe-responses","title":"1. Use Type-Safe Responses","text":"<pre><code>interface ApiResponse {\n  data: Array&lt;{\n    id: string;\n    name: string;\n    email: string;\n  }&gt;;\n  pagination: {\n    page: number;\n    total: number;\n  };\n}\n\nconst response = await this.helpers.httpRequest({\n  method: 'GET',\n  url: 'https://api.example.com/users',\n}) as ApiResponse;\n\n// TypeScript now knows the structure\nresponse.data.forEach(user =&gt; {\n  console.log(user.name); // Type-safe access\n});\n</code></pre>"},{"location":"public-api/helpers/http/#2-handle-different-response-types","title":"2. Handle Different Response Types","text":"<pre><code>const response = await this.helpers.httpRequest({\n  method: 'GET',\n  url: endpoint,\n  returnFullResponse: true,\n});\n\nconst contentType = response.headers['content-type'];\n\nif (contentType?.includes('application/json')) {\n  return JSON.parse(response.body);\n} else if (contentType?.includes('text/')) {\n  return response.body;\n} else {\n  // Binary data\n  return this.helpers.prepareBinaryData(\n    Buffer.from(response.body),\n    'response-data'\n  );\n}\n</code></pre>"},{"location":"public-api/helpers/http/#3-validate-responses","title":"3. Validate Responses","text":"<pre><code>const response = await this.helpers.httpRequest(options);\n\nif (!response || typeof response !== 'object') {\n  throw new NodeOperationError(\n    this.getNode(),\n    'Invalid response from API'\n  );\n}\n\nif (!response.data || !Array.isArray(response.data)) {\n  throw new NodeOperationError(\n    this.getNode(),\n    'Expected array in response.data'\n  );\n}\n</code></pre>"},{"location":"public-api/helpers/http/#4-use-appropriate-timeouts","title":"4. Use Appropriate Timeouts","text":"<pre><code>// Short timeout for health checks\nconst healthCheck = await this.helpers.httpRequest({\n  method: 'GET',\n  url: 'https://api.example.com/health',\n  timeout: 5000, // 5 seconds\n});\n\n// Longer timeout for data processing\nconst processData = await this.helpers.httpRequest({\n  method: 'POST',\n  url: 'https://api.example.com/process',\n  body: largeDataset,\n  timeout: 300000, // 5 minutes\n});\n</code></pre>"},{"location":"public-api/helpers/http/#deprecated-methods","title":"Deprecated Methods","text":""},{"location":"public-api/helpers/http/#request-deprecated","title":"\u26a0\ufe0f <code>request()</code> - Deprecated","text":"<p>Use <code>httpRequest()</code> instead for new code.</p> <pre><code>// \u274c Deprecated\nconst response = await this.helpers.request('https://api.example.com');\n\n// \u2705 Preferred\nconst response = await this.helpers.httpRequest({\n  method: 'GET',\n  url: 'https://api.example.com',\n});\n</code></pre>"},{"location":"public-api/helpers/http/#requestwithauthentication-deprecated","title":"\u26a0\ufe0f <code>requestWithAuthentication()</code> - Deprecated","text":"<p>Use <code>httpRequestWithAuthentication()</code> instead.</p> <pre><code>// \u274c Deprecated\nconst response = await this.helpers.requestWithAuthentication(\n  'credentialType',\n  { uri: 'https://api.example.com' }\n);\n\n// \u2705 Preferred\nconst response = await this.helpers.httpRequestWithAuthentication(\n  'credentialType',\n  { url: 'https://api.example.com' }\n);\n</code></pre>"},{"location":"public-api/helpers/http/#see-also","title":"See Also","text":"<ul> <li>IExecuteFunctions - Main execution context</li> <li>Binary Helpers - Working with binary data</li> <li>Credential Patterns - Authentication patterns</li> <li>Error Handling - Robust error management</li> </ul>"},{"location":"public-api/parameters/evaluateExpression/","title":"evaluateExpression","text":"<p>The <code>evaluateExpression</code> function allows you to evaluate n8n expressions dynamically within your node code. This enables access to workflow data, previous node outputs, and built-in functions using n8n's expression syntax.</p>"},{"location":"public-api/parameters/evaluateExpression/#when-to-use","title":"When to Use","text":"<p>Use <code>evaluateExpression</code> when your node needs to: - Dynamically evaluate user-provided expressions - Access data from previous nodes in the workflow - Use n8n's built-in expression functions - Implement conditional logic based on workflow data - Transform data using expressions rather than hardcoded logic</p>"},{"location":"public-api/parameters/evaluateExpression/#function-signature","title":"Function Signature","text":"<pre><code>evaluateExpression(\n  expression: string,\n  itemIndex: number,\n  additionalKeys?: IWorkflowDataProxyAdditionalKeys,\n  executeData?: IExecuteData,\n  mode?: WorkflowExecuteMode,\n  timezone?: string\n): any\n</code></pre>"},{"location":"public-api/parameters/evaluateExpression/#parameters","title":"Parameters","text":"<ul> <li>expression: The n8n expression string to evaluate</li> <li>itemIndex: Index of the current item being processed</li> <li>additionalKeys: Optional additional data to make available in expressions</li> <li>executeData: Optional execution data context</li> <li>mode: Optional workflow execution mode</li> <li>timezone: Optional timezone for date operations</li> </ul>"},{"location":"public-api/parameters/evaluateExpression/#basic-usage","title":"Basic Usage","text":""},{"location":"public-api/parameters/evaluateExpression/#simple-expression-evaluation","title":"Simple Expression Evaluation","text":"<pre><code>import { IExecuteFunctions } from 'n8n-workflow'\n\nexport async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n  const expression = this.getNodeParameter('expression', 0) as string\n\n  const results = []\n\n  for (let i = 0; i &lt; items.length; i++) {\n    // Evaluate expression for current item\n    const result = this.evaluateExpression(expression, i)\n\n    results.push({\n      json: {\n        originalData: items[i].json,\n        expressionResult: result\n      }\n    })\n  }\n\n  return [results]\n}\n</code></pre>"},{"location":"public-api/parameters/evaluateExpression/#accessing-previous-node-data","title":"Accessing Previous Node Data","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n\n  const results = []\n\n  for (let i = 0; i &lt; items.length; i++) {\n    // Access data from previous nodes\n    const userName = this.evaluateExpression('{{ $(\"HTTP Request\").first().json.user.name }}', i)\n    const timestamp = this.evaluateExpression('{{ $now }}', i)\n    const itemCount = this.evaluateExpression('{{ $(\"HTTP Request\").length }}', i)\n\n    results.push({\n      json: {\n        userName,\n        timestamp,\n        itemCount,\n        currentItem: items[i].json\n      }\n    })\n  }\n\n  return [results]\n}\n</code></pre>"},{"location":"public-api/parameters/evaluateExpression/#common-expression-patterns","title":"Common Expression Patterns","text":""},{"location":"public-api/parameters/evaluateExpression/#working-with-current-item-data","title":"Working with Current Item Data","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n  const results = []\n\n  for (let i = 0; i &lt; items.length; i++) {\n    // Access current item properties\n    const fullName = this.evaluateExpression('{{ $json.firstName + \" \" + $json.lastName }}', i)\n    const isActive = this.evaluateExpression('{{ $json.status === \"active\" }}', i)\n    const age = this.evaluateExpression('{{ $json.birthYear ? new Date().getFullYear() - $json.birthYear : null }}', i)\n\n    results.push({\n      json: {\n        ...items[i].json,\n        fullName,\n        isActive,\n        age\n      }\n    })\n  }\n\n  return [results]\n}\n</code></pre>"},{"location":"public-api/parameters/evaluateExpression/#conditional-logic","title":"Conditional Logic","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n  const condition = this.getNodeParameter('condition', 0) as string\n\n  const results = []\n\n  for (let i = 0; i &lt; items.length; i++) {\n    // Evaluate condition\n    const shouldProcess = this.evaluateExpression(condition, i)\n\n    if (shouldProcess) {\n      const processedData = this.evaluateExpression('{{ $json.value * 2 }}', i)\n\n      results.push({\n        json: {\n          ...items[i].json,\n          processed: true,\n          processedValue: processedData\n        }\n      })\n    } else {\n      results.push({\n        json: {\n          ...items[i].json,\n          processed: false,\n          reason: 'Condition not met'\n        }\n      })\n    }\n  }\n\n  return [results]\n}\n</code></pre>"},{"location":"public-api/parameters/evaluateExpression/#using-built-in-functions","title":"Using Built-in Functions","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n  const results = []\n\n  for (let i = 0; i &lt; items.length; i++) {\n    // Use various built-in functions\n    const formattedDate = this.evaluateExpression('{{ $now.format(\"YYYY-MM-DD\") }}', i)\n    const randomId = this.evaluateExpression('{{ $randomString(10) }}', i)\n    const hashedEmail = this.evaluateExpression('{{ $hash($json.email, \"sha256\") }}', i)\n    const upperName = this.evaluateExpression('{{ $json.name.toUpperCase() }}', i)\n\n    results.push({\n      json: {\n        ...items[i].json,\n        formattedDate,\n        randomId,\n        hashedEmail,\n        upperName\n      }\n    })\n  }\n\n  return [results]\n}\n</code></pre>"},{"location":"public-api/parameters/evaluateExpression/#advanced-usage","title":"Advanced Usage","text":""},{"location":"public-api/parameters/evaluateExpression/#custom-additional-keys","title":"Custom Additional Keys","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n  const customData = this.getNodeParameter('customData', 0) as object\n\n  const results = []\n\n  for (let i = 0; i &lt; items.length; i++) {\n    // Provide additional data to expressions\n    const additionalKeys = {\n      $custom: customData,\n      $config: {\n        apiUrl: 'https://api.example.com',\n        version: '1.0'\n      }\n    }\n\n    const result = this.evaluateExpression(\n      '{{ $json.id + \"-\" + $custom.prefix + \"-\" + $config.version }}',\n      i,\n      additionalKeys\n    )\n\n    results.push({\n      json: {\n        ...items[i].json,\n        generatedId: result\n      }\n    })\n  }\n\n  return [results]\n}\n</code></pre>"},{"location":"public-api/parameters/evaluateExpression/#dynamic-expression-building","title":"Dynamic Expression Building","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n  const fieldName = this.getNodeParameter('fieldName', 0) as string\n  const operation = this.getNodeParameter('operation', 0) as string\n\n  const results = []\n\n  for (let i = 0; i &lt; items.length; i++) {\n    // Build expression dynamically\n    let expression = ''\n\n    switch (operation) {\n      case 'uppercase':\n        expression = `{{ $json.${fieldName}.toUpperCase() }}`\n        break\n      case 'length':\n        expression = `{{ $json.${fieldName}.length }}`\n        break\n      case 'reverse':\n        expression = `{{ $json.${fieldName}.split(\"\").reverse().join(\"\") }}`\n        break\n      default:\n        expression = `{{ $json.${fieldName} }}`\n    }\n\n    const result = this.evaluateExpression(expression, i)\n\n    results.push({\n      json: {\n        ...items[i].json,\n        [`${fieldName}_${operation}`]: result\n      }\n    })\n  }\n\n  return [results]\n}\n</code></pre>"},{"location":"public-api/parameters/evaluateExpression/#error-handling-in-expressions","title":"Error Handling in Expressions","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n  const expressions = this.getNodeParameter('expressions', 0) as string[]\n\n  const results = []\n\n  for (let i = 0; i &lt; items.length; i++) {\n    const itemResult: any = { ...items[i].json }\n\n    for (const expression of expressions) {\n      try {\n        const result = this.evaluateExpression(expression, i)\n        itemResult[`expr_${expressions.indexOf(expression)}`] = result\n      } catch (error) {\n        itemResult[`expr_${expressions.indexOf(expression)}_error`] = error.message\n        itemResult[`expr_${expressions.indexOf(expression)}`] = null\n      }\n    }\n\n    results.push({ json: itemResult })\n  }\n\n  return [results]\n}\n</code></pre>"},{"location":"public-api/parameters/evaluateExpression/#working-with-complex-data","title":"Working with Complex Data","text":""},{"location":"public-api/parameters/evaluateExpression/#array-and-object-manipulation","title":"Array and Object Manipulation","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n  const results = []\n\n  for (let i = 0; i &lt; items.length; i++) {\n    // Complex array operations\n    const filteredItems = this.evaluateExpression(\n      '{{ $json.items.filter(item =&gt; item.status === \"active\") }}',\n      i\n    )\n\n    const mappedValues = this.evaluateExpression(\n      '{{ $json.items.map(item =&gt; item.name.toUpperCase()) }}',\n      i\n    )\n\n    const totalValue = this.evaluateExpression(\n      '{{ $json.items.reduce((sum, item) =&gt; sum + item.value, 0) }}',\n      i\n    )\n\n    results.push({\n      json: {\n        ...items[i].json,\n        filteredItems,\n        mappedValues,\n        totalValue\n      }\n    })\n  }\n\n  return [results]\n}\n</code></pre>"},{"location":"public-api/parameters/evaluateExpression/#cross-node-data-access","title":"Cross-Node Data Access","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n  const results = []\n\n  for (let i = 0; i &lt; items.length; i++) {\n    // Access data from multiple previous nodes\n    const userData = this.evaluateExpression('{{ $(\"Get User\").first().json }}', i)\n    const settingsData = this.evaluateExpression('{{ $(\"Get Settings\").first().json }}', i)\n\n    // Combine data from different sources\n    const combinedData = this.evaluateExpression(`\n      {{\n        {\n          userId: $(\"Get User\").first().json.id,\n          userName: $(\"Get User\").first().json.name,\n          theme: $(\"Get Settings\").first().json.theme,\n          currentData: $json\n        }\n      }}\n    `, i)\n\n    results.push({\n      json: combinedData\n    })\n  }\n\n  return [results]\n}\n</code></pre>"},{"location":"public-api/parameters/evaluateExpression/#performance-considerations","title":"Performance Considerations","text":""},{"location":"public-api/parameters/evaluateExpression/#caching-expression-results","title":"Caching Expression Results","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n  const expression = this.getNodeParameter('expression', 0) as string\n\n  // Cache for expressions that don't depend on item data\n  const expressionCache = new Map&lt;string, any&gt;()\n\n  const results = []\n\n  for (let i = 0; i &lt; items.length; i++) {\n    let result\n\n    // Check if expression uses item-specific data\n    if (expression.includes('$json') || expression.includes('$item')) {\n      // Evaluate for each item\n      result = this.evaluateExpression(expression, i)\n    } else {\n      // Use cached result for static expressions\n      if (!expressionCache.has(expression)) {\n        expressionCache.set(expression, this.evaluateExpression(expression, i))\n      }\n      result = expressionCache.get(expression)\n    }\n\n    results.push({\n      json: {\n        ...items[i].json,\n        result\n      }\n    })\n  }\n\n  return [results]\n}\n</code></pre>"},{"location":"public-api/parameters/evaluateExpression/#batch-expression-evaluation","title":"Batch Expression Evaluation","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n  const expressions = this.getNodeParameter('expressions', 0) as string[]\n\n  const results = []\n\n  // Pre-evaluate static expressions\n  const staticResults = new Map&lt;string, any&gt;()\n  for (const expr of expressions) {\n    if (!expr.includes('$json') &amp;&amp; !expr.includes('$item')) {\n      staticResults.set(expr, this.evaluateExpression(expr, 0))\n    }\n  }\n\n  for (let i = 0; i &lt; items.length; i++) {\n    const itemResult: any = { ...items[i].json }\n\n    for (const expression of expressions) {\n      if (staticResults.has(expression)) {\n        itemResult[`expr_${expressions.indexOf(expression)}`] = staticResults.get(expression)\n      } else {\n        itemResult[`expr_${expressions.indexOf(expression)}`] = this.evaluateExpression(expression, i)\n      }\n    }\n\n    results.push({ json: itemResult })\n  }\n\n  return [results]\n}\n</code></pre>"},{"location":"public-api/parameters/evaluateExpression/#best-practices","title":"Best Practices","text":"<ol> <li>Validate expressions before evaluation to prevent runtime errors</li> <li>Cache static expressions that don't depend on item data</li> <li>Handle errors gracefully when expressions fail</li> <li>Use meaningful variable names in complex expressions</li> <li>Document complex expressions for maintainability</li> <li>Test expressions with various data types and edge cases</li> <li>Consider performance when evaluating many expressions</li> </ol>"},{"location":"public-api/parameters/evaluateExpression/#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"public-api/parameters/evaluateExpression/#handling-undefined-values","title":"Handling Undefined Values","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n  const results = []\n\n  for (let i = 0; i &lt; items.length; i++) {\n    // Safe property access with fallbacks\n    const safeValue = this.evaluateExpression(\n      '{{ $json.nested?.property ?? \"default\" }}',\n      i\n    )\n\n    // Check for existence before operations\n    const conditionalResult = this.evaluateExpression(\n      '{{ $json.value ? $json.value * 2 : 0 }}',\n      i\n    )\n\n    results.push({\n      json: {\n        ...items[i].json,\n        safeValue,\n        conditionalResult\n      }\n    })\n  }\n\n  return [results]\n}\n</code></pre>"},{"location":"public-api/parameters/evaluateExpression/#related-documentation","title":"Related Documentation","text":"<ul> <li>getNodeParameter - For accessing node parameters</li> <li>getCurrentNodeParameter - For current node parameter access</li> <li>IExecuteFunctions - Main execution context</li> <li>Base Helpers - Core helper functions</li> </ul>"},{"location":"public-api/parameters/getCurrentNodeParameter/","title":"getCurrentNodeParameter","text":"<p>The <code>getCurrentNodeParameter</code> function provides access to parameters of the current node during execution. This is useful for accessing node configuration values that may have been set dynamically or need to be retrieved in specific execution contexts.</p>"},{"location":"public-api/parameters/getCurrentNodeParameter/#when-to-use","title":"When to Use","text":"<p>Use <code>getCurrentNodeParameter</code> when your node needs to: - Access its own parameter values during execution - Retrieve dynamically set parameter values - Get parameter values in contexts where <code>getNodeParameter</code> might not be available - Access parameter metadata or additional information - Implement parameter-dependent logic within the node</p>"},{"location":"public-api/parameters/getCurrentNodeParameter/#function-signature","title":"Function Signature","text":"<pre><code>getCurrentNodeParameter(\n  parameterName: string,\n  fallbackValue?: any\n): any\n</code></pre>"},{"location":"public-api/parameters/getCurrentNodeParameter/#parameters","title":"Parameters","text":"<ul> <li>parameterName: The name of the parameter to retrieve</li> <li>fallbackValue: Optional fallback value if parameter is not found</li> </ul>"},{"location":"public-api/parameters/getCurrentNodeParameter/#basic-usage","title":"Basic Usage","text":""},{"location":"public-api/parameters/getCurrentNodeParameter/#simple-parameter-access","title":"Simple Parameter Access","text":"<pre><code>import { IExecuteFunctions } from 'n8n-workflow'\n\nexport async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n\n  // Access current node parameters\n  const apiUrl = this.getCurrentNodeParameter('apiUrl')\n  const timeout = this.getCurrentNodeParameter('timeout', 30000)\n  const enableLogging = this.getCurrentNodeParameter('enableLogging', false)\n\n  const results = []\n\n  for (const item of items) {\n    if (enableLogging) {\n      console.log(`Processing item with API URL: ${apiUrl}`)\n    }\n\n    // Use parameters in processing\n    const result = await processWithConfig(item, {\n      apiUrl,\n      timeout,\n      enableLogging\n    })\n\n    results.push(result)\n  }\n\n  return [results]\n}\n</code></pre>"},{"location":"public-api/parameters/getCurrentNodeParameter/#parameter-validation","title":"Parameter Validation","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n\n  // Validate required parameters\n  const apiKey = this.getCurrentNodeParameter('apiKey')\n  if (!apiKey) {\n    throw new Error('API Key is required')\n  }\n\n  const endpoint = this.getCurrentNodeParameter('endpoint')\n  if (!endpoint) {\n    throw new Error('Endpoint URL is required')\n  }\n\n  // Validate parameter format\n  const batchSize = this.getCurrentNodeParameter('batchSize', 10)\n  if (batchSize &lt; 1 || batchSize &gt; 100) {\n    throw new Error('Batch size must be between 1 and 100')\n  }\n\n  return [items]\n}\n</code></pre>"},{"location":"public-api/parameters/getCurrentNodeParameter/#advanced-usage","title":"Advanced Usage","text":""},{"location":"public-api/parameters/getCurrentNodeParameter/#dynamic-parameter-access","title":"Dynamic Parameter Access","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n  const operation = this.getCurrentNodeParameter('operation')\n\n  // Access different parameters based on operation\n  let config: any = {}\n\n  switch (operation) {\n    case 'create':\n      config = {\n        name: this.getCurrentNodeParameter('name'),\n        description: this.getCurrentNodeParameter('description'),\n        tags: this.getCurrentNodeParameter('tags', [])\n      }\n      break\n\n    case 'update':\n      config = {\n        id: this.getCurrentNodeParameter('id'),\n        fields: this.getCurrentNodeParameter('updateFields', {})\n      }\n      break\n\n    case 'delete':\n      config = {\n        id: this.getCurrentNodeParameter('id'),\n        force: this.getCurrentNodeParameter('force', false)\n      }\n      break\n\n    default:\n      throw new Error(`Unknown operation: ${operation}`)\n  }\n\n  const results = []\n\n  for (const item of items) {\n    const result = await performOperation(operation, config, item)\n    results.push(result)\n  }\n\n  return [results]\n}\n</code></pre>"},{"location":"public-api/parameters/getCurrentNodeParameter/#parameter-based-configuration","title":"Parameter-Based Configuration","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n\n  // Build configuration from multiple parameters\n  const config = {\n    // Connection settings\n    host: this.getCurrentNodeParameter('host'),\n    port: this.getCurrentNodeParameter('port', 443),\n    ssl: this.getCurrentNodeParameter('ssl', true),\n\n    // Authentication\n    authType: this.getCurrentNodeParameter('authType'),\n    credentials: this.getCurrentNodeParameter('credentials'),\n\n    // Processing options\n    retries: this.getCurrentNodeParameter('retries', 3),\n    timeout: this.getCurrentNodeParameter('timeout', 30000),\n    batchSize: this.getCurrentNodeParameter('batchSize', 50),\n\n    // Output options\n    includeMetadata: this.getCurrentNodeParameter('includeMetadata', false),\n    format: this.getCurrentNodeParameter('outputFormat', 'json')\n  }\n\n  // Validate configuration\n  if (!config.host) {\n    throw new Error('Host is required')\n  }\n\n  if (config.authType === 'credentials' &amp;&amp; !config.credentials) {\n    throw new Error('Credentials are required when using credential authentication')\n  }\n\n  return [items]\n}\n</code></pre>"},{"location":"public-api/parameters/getCurrentNodeParameter/#conditional-parameter-access","title":"Conditional Parameter Access","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n\n  // Check if advanced options are enabled\n  const useAdvancedOptions = this.getCurrentNodeParameter('useAdvancedOptions', false)\n\n  let config: any = {\n    // Basic configuration\n    url: this.getCurrentNodeParameter('url'),\n    method: this.getCurrentNodeParameter('method', 'GET')\n  }\n\n  if (useAdvancedOptions) {\n    // Add advanced configuration\n    config = {\n      ...config,\n      headers: this.getCurrentNodeParameter('headers', {}),\n      queryParams: this.getCurrentNodeParameter('queryParams', {}),\n      timeout: this.getCurrentNodeParameter('timeout', 30000),\n      followRedirects: this.getCurrentNodeParameter('followRedirects', true),\n      maxRedirects: this.getCurrentNodeParameter('maxRedirects', 5)\n    }\n  }\n\n  return [items]\n}\n</code></pre>"},{"location":"public-api/parameters/getCurrentNodeParameter/#parameter-types-and-handling","title":"Parameter Types and Handling","text":""},{"location":"public-api/parameters/getCurrentNodeParameter/#string-parameters","title":"String Parameters","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n\n  // String parameters with validation\n  const name = this.getCurrentNodeParameter('name')\n  if (typeof name !== 'string' || name.trim().length === 0) {\n    throw new Error('Name must be a non-empty string')\n  }\n\n  const description = this.getCurrentNodeParameter('description', '')\n  const category = this.getCurrentNodeParameter('category', 'default')\n\n  return [items]\n}\n</code></pre>"},{"location":"public-api/parameters/getCurrentNodeParameter/#number-parameters","title":"Number Parameters","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n\n  // Number parameters with validation\n  const limit = this.getCurrentNodeParameter('limit', 100)\n  if (typeof limit !== 'number' || limit &lt; 1) {\n    throw new Error('Limit must be a positive number')\n  }\n\n  const offset = this.getCurrentNodeParameter('offset', 0)\n  if (typeof offset !== 'number' || offset &lt; 0) {\n    throw new Error('Offset must be a non-negative number')\n  }\n\n  return [items]\n}\n</code></pre>"},{"location":"public-api/parameters/getCurrentNodeParameter/#boolean-parameters","title":"Boolean Parameters","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n\n  // Boolean parameters\n  const includeDeleted = this.getCurrentNodeParameter('includeDeleted', false)\n  const sortAscending = this.getCurrentNodeParameter('sortAscending', true)\n  const enableCache = this.getCurrentNodeParameter('enableCache', false)\n\n  const config = {\n    includeDeleted: Boolean(includeDeleted),\n    sortAscending: Boolean(sortAscending),\n    enableCache: Boolean(enableCache)\n  }\n\n  return [items]\n}\n</code></pre>"},{"location":"public-api/parameters/getCurrentNodeParameter/#array-parameters","title":"Array Parameters","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n\n  // Array parameters\n  const fields = this.getCurrentNodeParameter('fields', [])\n  if (!Array.isArray(fields)) {\n    throw new Error('Fields must be an array')\n  }\n\n  const tags = this.getCurrentNodeParameter('tags', [])\n  const filters = this.getCurrentNodeParameter('filters', [])\n\n  return [items]\n}\n</code></pre>"},{"location":"public-api/parameters/getCurrentNodeParameter/#object-parameters","title":"Object Parameters","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n\n  // Object parameters\n  const headers = this.getCurrentNodeParameter('headers', {})\n  if (typeof headers !== 'object' || headers === null) {\n    throw new Error('Headers must be an object')\n  }\n\n  const metadata = this.getCurrentNodeParameter('metadata', {})\n  const options = this.getCurrentNodeParameter('options', {})\n\n  return [items]\n}\n</code></pre>"},{"location":"public-api/parameters/getCurrentNodeParameter/#error-handling","title":"Error Handling","text":""},{"location":"public-api/parameters/getCurrentNodeParameter/#parameter-existence-checking","title":"Parameter Existence Checking","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n\n  try {\n    // Check if parameter exists\n    const requiredParam = this.getCurrentNodeParameter('requiredParam')\n    if (requiredParam === undefined || requiredParam === null) {\n      throw new Error('Required parameter is missing')\n    }\n\n    // Optional parameter with fallback\n    const optionalParam = this.getCurrentNodeParameter('optionalParam', 'default')\n\n    return [items]\n  } catch (error) {\n    throw new Error(`Parameter access failed: ${error.message}`)\n  }\n}\n</code></pre>"},{"location":"public-api/parameters/getCurrentNodeParameter/#type-safety","title":"Type Safety","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n\n  // Type-safe parameter access\n  function getTypedParameter&lt;T&gt;(name: string, defaultValue: T, validator?: (value: any) =&gt; value is T): T {\n    const value = this.getCurrentNodeParameter(name, defaultValue)\n\n    if (validator &amp;&amp; !validator(value)) {\n      throw new Error(`Parameter ${name} has invalid type`)\n    }\n\n    return value\n  }\n\n  // Usage with type validation\n  const timeout = getTypedParameter('timeout', 30000, (v): v is number =&gt; typeof v === 'number' &amp;&amp; v &gt; 0)\n  const enabled = getTypedParameter('enabled', false, (v): v is boolean =&gt; typeof v === 'boolean')\n\n  return [items]\n}\n</code></pre>"},{"location":"public-api/parameters/getCurrentNodeParameter/#common-patterns","title":"Common Patterns","text":""},{"location":"public-api/parameters/getCurrentNodeParameter/#configuration-builder","title":"Configuration Builder","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n\n  // Build configuration object from parameters\n  const buildConfig = () =&gt; {\n    const config: any = {}\n\n    // Required parameters\n    const requiredParams = ['apiUrl', 'apiKey']\n    for (const param of requiredParams) {\n      const value = this.getCurrentNodeParameter(param)\n      if (!value) {\n        throw new Error(`Required parameter ${param} is missing`)\n      }\n      config[param] = value\n    }\n\n    // Optional parameters with defaults\n    const optionalParams = {\n      timeout: 30000,\n      retries: 3,\n      batchSize: 50,\n      enableLogging: false\n    }\n\n    for (const [param, defaultValue] of Object.entries(optionalParams)) {\n      config[param] = this.getCurrentNodeParameter(param, defaultValue)\n    }\n\n    return config\n  }\n\n  const config = buildConfig()\n\n  return [items]\n}\n</code></pre>"},{"location":"public-api/parameters/getCurrentNodeParameter/#parameter-inheritance","title":"Parameter Inheritance","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n\n  // Get base configuration\n  const baseConfig = {\n    timeout: this.getCurrentNodeParameter('timeout', 30000),\n    retries: this.getCurrentNodeParameter('retries', 3)\n  }\n\n  // Override with operation-specific parameters\n  const operation = this.getCurrentNodeParameter('operation')\n  let operationConfig = {}\n\n  if (operation === 'upload') {\n    operationConfig = {\n      chunkSize: this.getCurrentNodeParameter('chunkSize', 1024 * 1024),\n      compression: this.getCurrentNodeParameter('compression', false)\n    }\n  } else if (operation === 'download') {\n    operationConfig = {\n      bufferSize: this.getCurrentNodeParameter('bufferSize', 64 * 1024),\n      validateChecksum: this.getCurrentNodeParameter('validateChecksum', true)\n    }\n  }\n\n  const finalConfig = { ...baseConfig, ...operationConfig }\n\n  return [items]\n}\n</code></pre>"},{"location":"public-api/parameters/getCurrentNodeParameter/#parameter-validation-pipeline","title":"Parameter Validation Pipeline","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n\n  // Validation pipeline\n  const validators = [\n    () =&gt; {\n      const url = this.getCurrentNodeParameter('url')\n      if (!url || typeof url !== 'string') {\n        throw new Error('URL is required and must be a string')\n      }\n      if (!url.startsWith('http')) {\n        throw new Error('URL must start with http or https')\n      }\n    },\n\n    () =&gt; {\n      const timeout = this.getCurrentNodeParameter('timeout', 30000)\n      if (typeof timeout !== 'number' || timeout &lt; 1000 || timeout &gt; 300000) {\n        throw new Error('Timeout must be between 1000 and 300000 milliseconds')\n      }\n    },\n\n    () =&gt; {\n      const method = this.getCurrentNodeParameter('method', 'GET')\n      const allowedMethods = ['GET', 'POST', 'PUT', 'DELETE', 'PATCH']\n      if (!allowedMethods.includes(method)) {\n        throw new Error(`Method must be one of: ${allowedMethods.join(', ')}`)\n      }\n    }\n  ]\n\n  // Run all validators\n  for (const validator of validators) {\n    validator()\n  }\n\n  return [items]\n}\n</code></pre>"},{"location":"public-api/parameters/getCurrentNodeParameter/#best-practices","title":"Best Practices","text":"<ol> <li>Always provide fallback values for optional parameters</li> <li>Validate parameter types and values before using them</li> <li>Use meaningful error messages when parameters are invalid</li> <li>Group related parameters into configuration objects</li> <li>Document parameter requirements clearly</li> <li>Handle missing parameters gracefully</li> <li>Use type-safe parameter access when possible</li> </ol>"},{"location":"public-api/parameters/getCurrentNodeParameter/#comparison-with-getnodeparameter","title":"Comparison with getNodeParameter","text":""},{"location":"public-api/parameters/getCurrentNodeParameter/#when-to-use-getcurrentnodeparameter-vs-getnodeparameter","title":"When to Use getCurrentNodeParameter vs getNodeParameter","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n\n  // Use getNodeParameter for item-specific parameter access\n  for (let i = 0; i &lt; items.length; i++) {\n    const itemSpecificValue = this.getNodeParameter('dynamicField', i)\n    // Process with item-specific value\n  }\n\n  // Use getCurrentNodeParameter for node-level configuration\n  const globalConfig = {\n    apiUrl: this.getCurrentNodeParameter('apiUrl'),\n    timeout: this.getCurrentNodeParameter('timeout', 30000),\n    enableLogging: this.getCurrentNodeParameter('enableLogging', false)\n  }\n\n  return [items]\n}\n</code></pre>"},{"location":"public-api/parameters/getCurrentNodeParameter/#related-documentation","title":"Related Documentation","text":"<ul> <li>getNodeParameter - For item-specific parameter access</li> <li>evaluateExpression - For dynamic expression evaluation</li> <li>IExecuteFunctions - Main execution context</li> <li>Base Helpers - Core helper functions</li> </ul>"},{"location":"public-api/parameters/getNodeParameter/","title":"getNodeParameter","text":"<p>Gets a parameter value configured by the user in the node's UI. This is the primary method for accessing user-configured settings in your node.</p>"},{"location":"public-api/parameters/getNodeParameter/#signature","title":"Signature","text":"<pre><code>getNodeParameter(\n  parameterName: string,\n  itemIndex: number,\n  fallbackValue?: any,\n  options?: IGetNodeParameterOptions\n): NodeParameterValueType | object\n</code></pre>"},{"location":"public-api/parameters/getNodeParameter/#parameters","title":"Parameters","text":"<ul> <li><code>parameterName</code> - Name of the parameter as defined in the node description</li> <li><code>itemIndex</code> - Index of the current item being processed (usually the loop index)</li> <li><code>fallbackValue</code> - Default value if parameter is not set or is undefined</li> <li><code>options</code> - Additional options for parameter retrieval</li> </ul>"},{"location":"public-api/parameters/getNodeParameter/#return-types","title":"Return Types","text":"<p>The return type depends on the parameter type defined in your node description:</p> <pre><code>type NodeParameterValueType = \n  | string \n  | number \n  | boolean \n  | undefined \n  | null;\n</code></pre> <p>For complex parameters (objects, collections), the return type is <code>object</code>.</p>"},{"location":"public-api/parameters/getNodeParameter/#basic-usage","title":"Basic Usage","text":""},{"location":"public-api/parameters/getNodeParameter/#string-parameters","title":"String Parameters","text":"<pre><code>const operation = this.getNodeParameter('operation', 0) as string;\nconst apiUrl = this.getNodeParameter('apiUrl', i) as string;\nconst message = this.getNodeParameter('message', i, 'Default message') as string;\n</code></pre>"},{"location":"public-api/parameters/getNodeParameter/#number-parameters","title":"Number Parameters","text":"<pre><code>const limit = this.getNodeParameter('limit', i) as number;\nconst timeout = this.getNodeParameter('timeout', i, 30000) as number;\nconst retries = this.getNodeParameter('retries', i, 3) as number;\n</code></pre>"},{"location":"public-api/parameters/getNodeParameter/#boolean-parameters","title":"Boolean Parameters","text":"<pre><code>const returnAll = this.getNodeParameter('returnAll', i) as boolean;\nconst includeMetadata = this.getNodeParameter('includeMetadata', i, false) as boolean;\nconst skipErrors = this.getNodeParameter('skipErrors', i) as boolean;\n</code></pre>"},{"location":"public-api/parameters/getNodeParameter/#object-parameters","title":"Object Parameters","text":"<pre><code>// For additionalFields, filters, etc.\nconst additionalFields = this.getNodeParameter('additionalFields', i, {}) as IDataObject;\nconst filters = this.getNodeParameter('filters', i, {}) as IDataObject;\nconst options = this.getNodeParameter('options', i, {}) as IDataObject;\n</code></pre>"},{"location":"public-api/parameters/getNodeParameter/#advanced-usage","title":"Advanced Usage","text":""},{"location":"public-api/parameters/getNodeParameter/#collections","title":"Collections","text":"<pre><code>// For collection parameters\ninterface EmailRecipient {\n  email: string;\n  name?: string;\n  type: 'to' | 'cc' | 'bcc';\n}\n\nconst recipients = this.getNodeParameter('recipients', i, []) as EmailRecipient[];\n\nfor (const recipient of recipients) {\n  console.log(`Sending to: ${recipient.email} (${recipient.type})`);\n}\n</code></pre>"},{"location":"public-api/parameters/getNodeParameter/#nested-objects","title":"Nested Objects","text":"<pre><code>// For complex nested structures\ninterface ApiConfig {\n  endpoint: string;\n  authentication: {\n    type: 'apiKey' | 'oauth';\n    credentials: IDataObject;\n  };\n  options: {\n    timeout: number;\n    retries: number;\n  };\n}\n\nconst config = this.getNodeParameter('apiConfig', i) as ApiConfig;\nconst endpoint = config.endpoint;\nconst authType = config.authentication.type;\nconst timeout = config.options.timeout;\n</code></pre>"},{"location":"public-api/parameters/getNodeParameter/#dynamic-parameters","title":"Dynamic Parameters","text":"<pre><code>// Parameters that depend on other parameters\nconst resource = this.getNodeParameter('resource', i) as string;\n\nif (resource === 'user') {\n  const userId = this.getNodeParameter('userId', i) as string;\n  const includeProfile = this.getNodeParameter('includeProfile', i, false) as boolean;\n} else if (resource === 'post') {\n  const postId = this.getNodeParameter('postId', i) as string;\n  const includeComments = this.getNodeParameter('includeComments', i, false) as boolean;\n}\n</code></pre>"},{"location":"public-api/parameters/getNodeParameter/#type-safety","title":"Type Safety","text":""},{"location":"public-api/parameters/getNodeParameter/#using-type-assertions","title":"Using Type Assertions","text":"<pre><code>// Basic type assertions\nconst operation = this.getNodeParameter('operation', i) as string;\nconst limit = this.getNodeParameter('limit', i) as number;\nconst enabled = this.getNodeParameter('enabled', i) as boolean;\n</code></pre>"},{"location":"public-api/parameters/getNodeParameter/#using-interfaces","title":"Using Interfaces","text":"<pre><code>interface NodeParameters {\n  operation: string;\n  resource: string;\n  limit?: number;\n  additionalFields?: {\n    includeMetadata?: boolean;\n    format?: 'json' | 'xml';\n    timeout?: number;\n  };\n}\n\n// Type-safe parameter access\nconst operation = this.getNodeParameter('operation', i) as NodeParameters['operation'];\nconst additionalFields = this.getNodeParameter('additionalFields', i, {}) as NodeParameters['additionalFields'];\n\nif (additionalFields?.includeMetadata) {\n  // TypeScript knows this is a boolean\n}\n</code></pre>"},{"location":"public-api/parameters/getNodeParameter/#generic-helper-function","title":"Generic Helper Function","text":"<pre><code>function getTypedParameter&lt;T&gt;(\n  this: IExecuteFunctions,\n  parameterName: string,\n  itemIndex: number,\n  fallbackValue?: T\n): T {\n  return this.getNodeParameter(parameterName, itemIndex, fallbackValue) as T;\n}\n\n// Usage\nconst limit = getTypedParameter&lt;number&gt;('limit', i, 100);\nconst options = getTypedParameter&lt;IDataObject&gt;('options', i, {});\n</code></pre>"},{"location":"public-api/parameters/getNodeParameter/#parameter-options","title":"Parameter Options","text":""},{"location":"public-api/parameters/getNodeParameter/#igetnodeparameteroptions","title":"<code>IGetNodeParameterOptions</code>","text":"<pre><code>interface IGetNodeParameterOptions {\n  extractValue?: boolean;\n  rawExpressions?: boolean;\n}\n</code></pre>"},{"location":"public-api/parameters/getNodeParameter/#extract-value","title":"Extract Value","text":"<pre><code>// Get the raw parameter value without expression evaluation\nconst rawValue = this.getNodeParameter('expression', i, '', { \n  extractValue: false \n});\n\n// Get the evaluated expression result\nconst evaluatedValue = this.getNodeParameter('expression', i, '', { \n  extractValue: true \n});\n</code></pre>"},{"location":"public-api/parameters/getNodeParameter/#raw-expressions","title":"Raw Expressions","text":"<pre><code>// Get expressions as strings without evaluation\nconst expression = this.getNodeParameter('dynamicValue', i, '', { \n  rawExpressions: true \n});\nconsole.log(expression); // \"={{ $json.name }}\"\n\n// Get evaluated expression result (default behavior)\nconst value = this.getNodeParameter('dynamicValue', i);\nconsole.log(value); // \"John Doe\"\n</code></pre>"},{"location":"public-api/parameters/getNodeParameter/#common-patterns","title":"Common Patterns","text":""},{"location":"public-api/parameters/getNodeParameter/#resource-and-operation-pattern","title":"Resource and Operation Pattern","text":"<pre><code>const resource = this.getNodeParameter('resource', 0) as string;\nconst operation = this.getNodeParameter('operation', 0) as string;\n\nif (resource === 'user') {\n  if (operation === 'get') {\n    const userId = this.getNodeParameter('userId', i) as string;\n    // Get user logic\n  } else if (operation === 'create') {\n    const userData = this.getNodeParameter('userData', i) as IDataObject;\n    // Create user logic\n  }\n}\n</code></pre>"},{"location":"public-api/parameters/getNodeParameter/#conditional-parameters","title":"Conditional Parameters","text":"<pre><code>const returnAll = this.getNodeParameter('returnAll', i) as boolean;\nlet limit: number | undefined;\n\nif (!returnAll) {\n  limit = this.getNodeParameter('limit', i, 50) as number;\n}\n</code></pre>"},{"location":"public-api/parameters/getNodeParameter/#additional-fields-pattern","title":"Additional Fields Pattern","text":"<pre><code>const additionalFields = this.getNodeParameter('additionalFields', i, {}) as IDataObject;\n\n// Build request body with base fields + additional fields\nconst requestBody: IDataObject = {\n  name: this.getNodeParameter('name', i) as string,\n  email: this.getNodeParameter('email', i) as string,\n  ...additionalFields, // Spread additional fields\n};\n\n// Or access specific additional fields\nif (additionalFields.phone) {\n  requestBody.phone = additionalFields.phone;\n}\nif (additionalFields.company) {\n  requestBody.company = additionalFields.company;\n}\n</code></pre>"},{"location":"public-api/parameters/getNodeParameter/#filters-pattern","title":"Filters Pattern","text":"<pre><code>interface FilterCondition {\n  field: string;\n  operator: 'equals' | 'contains' | 'startsWith' | 'greaterThan';\n  value: string | number;\n}\n\nconst filters = this.getNodeParameter('filters', i, {}) as {\n  conditions?: FilterCondition[];\n  combineWith?: 'AND' | 'OR';\n};\n\nif (filters.conditions &amp;&amp; filters.conditions.length &gt; 0) {\n  // Apply filters to query\n  const queryFilters = filters.conditions.map(condition =&gt; {\n    return `${condition.field} ${condition.operator} ${condition.value}`;\n  });\n\n  const filterString = queryFilters.join(` ${filters.combineWith || 'AND'} `);\n}\n</code></pre>"},{"location":"public-api/parameters/getNodeParameter/#error-handling","title":"Error Handling","text":""},{"location":"public-api/parameters/getNodeParameter/#required-parameters","title":"Required Parameters","text":"<pre><code>const apiKey = this.getNodeParameter('apiKey', i) as string;\nif (!apiKey) {\n  throw new NodeOperationError(\n    this.getNode(),\n    'API Key is required',\n    { itemIndex: i }\n  );\n}\n</code></pre>"},{"location":"public-api/parameters/getNodeParameter/#parameter-validation","title":"Parameter Validation","text":"<pre><code>const limit = this.getNodeParameter('limit', i, 100) as number;\nif (limit &lt; 1 || limit &gt; 1000) {\n  throw new NodeOperationError(\n    this.getNode(),\n    'Limit must be between 1 and 1000',\n    { itemIndex: i }\n  );\n}\n</code></pre>"},{"location":"public-api/parameters/getNodeParameter/#safe-parameter-access","title":"Safe Parameter Access","text":"<pre><code>function safeGetParameter&lt;T&gt;(\n  this: IExecuteFunctions,\n  parameterName: string,\n  itemIndex: number,\n  fallbackValue: T,\n  validator?: (value: T) =&gt; boolean\n): T {\n  try {\n    const value = this.getNodeParameter(parameterName, itemIndex, fallbackValue) as T;\n\n    if (validator &amp;&amp; !validator(value)) {\n      throw new Error(`Invalid value for parameter ${parameterName}`);\n    }\n\n    return value;\n  } catch (error) {\n    throw new NodeOperationError(\n      this.getNode(),\n      `Error getting parameter ${parameterName}: ${error.message}`,\n      { itemIndex }\n    );\n  }\n}\n\n// Usage\nconst limit = safeGetParameter(\n  'limit',\n  i,\n  100,\n  (value: number) =&gt; value &gt; 0 &amp;&amp; value &lt;= 1000\n);\n</code></pre>"},{"location":"public-api/parameters/getNodeParameter/#performance-considerations","title":"Performance Considerations","text":""},{"location":"public-api/parameters/getNodeParameter/#cache-parameter-values","title":"Cache Parameter Values","text":"<pre><code>// \u274c Bad - Getting the same parameter multiple times\nfor (let i = 0; i &lt; items.length; i++) {\n  const apiUrl = this.getNodeParameter('apiUrl', i) as string; // Same for all items\n  const timeout = this.getNodeParameter('timeout', i) as number; // Same for all items\n  // Process item\n}\n\n// \u2705 Good - Cache parameters that don't change per item\nconst apiUrl = this.getNodeParameter('apiUrl', 0) as string;\nconst timeout = this.getNodeParameter('timeout', 0) as number;\n\nfor (let i = 0; i &lt; items.length; i++) {\n  const itemSpecificParam = this.getNodeParameter('itemParam', i) as string;\n  // Process item\n}\n</code></pre>"},{"location":"public-api/parameters/getNodeParameter/#batch-parameter-access","title":"Batch Parameter Access","text":"<pre><code>// For parameters that might be expensive to evaluate\nconst batchSize = 100;\nconst cachedParams = new Map&lt;string, any&gt;();\n\nfunction getCachedParameter(paramName: string, itemIndex: number, fallback?: any) {\n  const key = `${paramName}_${itemIndex}`;\n  if (!cachedParams.has(key)) {\n    cachedParams.set(key, this.getNodeParameter(paramName, itemIndex, fallback));\n  }\n  return cachedParams.get(key);\n}\n</code></pre>"},{"location":"public-api/parameters/getNodeParameter/#best-practices","title":"Best Practices","text":""},{"location":"public-api/parameters/getNodeParameter/#1-use-descriptive-parameter-names","title":"1. Use Descriptive Parameter Names","text":"<pre><code>// \u2705 Good\nconst maxRetries = this.getNodeParameter('maxRetries', i, 3) as number;\nconst includeMetadata = this.getNodeParameter('includeMetadata', i, false) as boolean;\n\n// \u274c Bad\nconst max = this.getNodeParameter('max', i, 3) as number;\nconst flag = this.getNodeParameter('flag', i, false) as boolean;\n</code></pre>"},{"location":"public-api/parameters/getNodeParameter/#2-provide-sensible-defaults","title":"2. Provide Sensible Defaults","text":"<pre><code>// \u2705 Good - Provide reasonable defaults\nconst timeout = this.getNodeParameter('timeout', i, 30000) as number;\nconst retries = this.getNodeParameter('retries', i, 3) as number;\nconst batchSize = this.getNodeParameter('batchSize', i, 100) as number;\n</code></pre>"},{"location":"public-api/parameters/getNodeParameter/#3-validate-parameter-values","title":"3. Validate Parameter Values","text":"<pre><code>// \u2705 Good - Validate critical parameters\nconst limit = this.getNodeParameter('limit', i, 100) as number;\nif (limit &lt; 1) {\n  throw new NodeOperationError(this.getNode(), 'Limit must be at least 1');\n}\n\nconst email = this.getNodeParameter('email', i) as string;\nif (!email.includes('@')) {\n  throw new NodeOperationError(this.getNode(), 'Invalid email format');\n}\n</code></pre>"},{"location":"public-api/parameters/getNodeParameter/#4-use-type-safe-interfaces","title":"4. Use Type-Safe Interfaces","text":"<pre><code>// \u2705 Good - Define interfaces for complex parameters\ninterface EmailConfig {\n  to: string[];\n  cc?: string[];\n  bcc?: string[];\n  subject: string;\n  body: string;\n  attachments?: Array&lt;{\n    filename: string;\n    content: string;\n  }&gt;;\n}\n\nconst emailConfig = this.getNodeParameter('emailConfig', i) as EmailConfig;\n</code></pre>"},{"location":"public-api/parameters/getNodeParameter/#see-also","title":"See Also","text":"<ul> <li>IExecuteFunctions - Main execution context</li> <li>evaluateExpression - Evaluating n8n expressions</li> <li>getCurrentNodeParameter - Getting current parameter values</li> <li>Error Handling - Robust error management</li> </ul>"},{"location":"public-api/reference/interfaces/","title":"Common Interfaces","text":"<p>This page provides a reference for key interfaces used throughout the n8n public API. These interfaces define the structure of data passed between nodes, workflows, credentials, and the execution engine.</p>"},{"location":"public-api/reference/interfaces/#inodeexecutiondata","title":"INodeExecutionData","text":"<pre><code>interface INodeExecutionData {\n  json: IDataObject\n  binary?: IBinaryKeyData\n  error?: NodeApiError | NodeOperationError\n  pairedItem?: IPairedItemData | IPairedItemData[] | number\n  metadata?: {\n    subExecution: RelatedExecution\n  }\n}\n</code></pre> <p>Represents a single item of data passed between nodes.</p>"},{"location":"public-api/reference/interfaces/#idataobject","title":"IDataObject","text":"<pre><code>interface IDataObject {\n  [key: string]: string | number | boolean | object | null | undefined | IDataObject | IDataObject[]\n}\n</code></pre> <p>Generic key-value structure used throughout the API.</p>"},{"location":"public-api/reference/interfaces/#ibinarydata","title":"IBinaryData","text":"<pre><code>interface IBinaryData {\n  data: string\n  mimeType: string\n  fileType?: string\n  fileName?: string\n  directory?: string\n  fileExtension?: string\n  fileSize?: string\n  id?: string\n}\n</code></pre> <p>Represents binary file data attached to an item.</p>"},{"location":"public-api/reference/interfaces/#inodeproperties","title":"INodeProperties","text":"<pre><code>interface INodeProperties {\n  displayName: string\n  name: string\n  type: NodePropertyTypes\n  default: NodeParameterValueType\n  description?: string\n  required?: boolean\n  options?: INodePropertyOptions[]\n  displayOptions?: IDisplayOptions\n}\n</code></pre> <p>Defines a parameter for a node.</p>"},{"location":"public-api/reference/interfaces/#icredentialtype","title":"ICredentialType","text":"<pre><code>interface ICredentialType {\n  name: string\n  displayName: string\n  properties: INodeProperties[]\n  authenticate?: IAuthenticate\n  test?: ICredentialTestRequest\n}\n</code></pre> <p>Defines a credential type used by nodes.</p>"},{"location":"public-api/reference/interfaces/#inodetypedescription","title":"INodeTypeDescription","text":"<pre><code>interface INodeTypeDescription {\n  displayName: string\n  name: string\n  group: string[]\n  version: number\n  inputs: string[]\n  outputs: string[]\n  properties: INodeProperties[]\n  credentials?: INodeCredentialDescription[]\n}\n</code></pre> <p>Metadata for a node type.</p>"},{"location":"public-api/reference/interfaces/#iworkflowmetadata","title":"IWorkflowMetadata","text":"<pre><code>interface IWorkflowMetadata {\n  id?: string\n  name?: string\n  active: boolean\n}\n</code></pre> <p>Basic metadata about a workflow.</p>"},{"location":"public-api/reference/interfaces/#inode","title":"INode","text":"<pre><code>interface INode {\n  id: string\n  name: string\n  type: string\n  typeVersion: number\n  position: [number, number]\n  disabled?: boolean\n  notes?: string\n  notesInFlow?: boolean\n  retryOnFail?: boolean\n  maxTries?: number\n  waitBetweenTries?: number\n  alwaysOutputData?: boolean\n  executeOnce?: boolean\n  onError?: 'continueErrorOutput' | 'continueRegularOutput' | 'stopWorkflow'\n  continueOnFail?: boolean\n  parameters: INodeParameters\n  credentials?: INodeCredentials\n  webhookId?: string\n  extendsCredential?: string\n  rewireOutputLogTo?: string\n}\n</code></pre> <p>Represents a node instance in a workflow.</p>"},{"location":"public-api/reference/interfaces/#inodetype","title":"INodeType","text":"<pre><code>interface INodeType {\n  description: INodeTypeDescription\n  supplyData?(this: ISupplyDataFunctions, itemIndex: number): Promise&lt;SupplyData&gt;\n  execute?(this: IExecuteFunctions): Promise&lt;INodeExecutionData[][] | null&gt;\n  poll?(this: IPollFunctions): Promise&lt;INodeExecutionData[][] | null&gt;\n  trigger?(this: ITriggerFunctions): Promise&lt;ITriggerResponse | undefined&gt;\n  webhook?(this: IWebhookFunctions): Promise&lt;IWebhookResponseData&gt;\n  methods?: {\n    loadOptions?: {\n      [key: string]: (this: ILoadOptionsFunctions) =&gt; Promise&lt;INodePropertyOptions[]&gt;\n    }\n    listSearch?: {\n      [key: string]: (\n        this: ILoadOptionsFunctions,\n        filter?: string,\n        paginationToken?: string,\n      ) =&gt; Promise&lt;INodeListSearchResult&gt;\n    }\n    credentialTest?: {\n      [functionName: string]: ICredentialTestFunction\n    }\n    resourceMapping?: {\n      [functionName: string]: (this: ILoadOptionsFunctions) =&gt; Promise&lt;ResourceMapperFields&gt;\n    }\n    localResourceMapping?: {\n      [functionName: string]: (this: ILocalLoadOptionsFunctions) =&gt; Promise&lt;ResourceMapperFields&gt;\n    }\n    actionHandler?: {\n      [functionName: string]: (\n        this: ILoadOptionsFunctions,\n        payload: IDataObject | string | undefined,\n      ) =&gt; Promise&lt;NodeParameterValueType&gt;\n    }\n  }\n  webhookMethods?: {\n    [name in WebhookType]?: {\n      [method in WebhookSetupMethodNames]: (this: IHookFunctions) =&gt; Promise&lt;boolean&gt;\n    }\n  }\n  customOperations?: {\n    [resource: string]: {\n      [operation: string]: (this: IExecuteFunctions) =&gt; Promise&lt;INodeExecutionData[][] | null&gt;\n    }\n  }\n}\n</code></pre> <p>Defines the structure and behavior of a node implementation.</p> <pre><code>interface INodeParameters {\n  [key: string]: NodeParameterValueType\n}\n</code></pre> <p>Holds the configured parameter values for a node.</p>"},{"location":"public-api/reference/interfaces/#see-also","title":"See Also","text":"<ul> <li>Types Reference</li> <li>Execution Contexts</li> <li>Helpers</li> </ul>"},{"location":"public-api/reference/types/","title":"Common Types","text":"<p>This page provides a reference for common type aliases used throughout the n8n public API. These types are used in node parameters, execution contexts, helpers, and workflow metadata.</p>"},{"location":"public-api/reference/types/#nodeparametervaluetype","title":"NodeParameterValueType","text":"<pre><code>type NodeParameterValueType =\n  string |\n  number |\n  boolean |\n  undefined |\n  null |\n  INodeParameters |\n  INodeParameterResourceLocator |\n  ResourceMapperValue |\n  FilterValue |\n  AssignmentCollectionValue |\n  NodeParameterValue[] |\n  INodeParameters[] |\n  INodeParameterResourceLocator[] |\n  ResourceMapperValue[]\n</code></pre> <p>Represents the full range of values a node parameter can take.</p>"},{"location":"public-api/reference/types/#nodeconnectiontype","title":"NodeConnectionType","text":"<pre><code>type NodeConnectionType =\n  | 'main'\n  | 'ai_agent'\n  | 'ai_chain'\n  | 'ai_document'\n  | 'ai_embedding'\n  | 'ai_languageModel'\n  | 'ai_memory'\n  | 'ai_outputParser'\n  | 'ai_retriever'\n  | 'ai_textSplitter'\n  | 'ai_tool'\n  | 'ai_vectorStore'\n</code></pre> <p>Used to define the type of connection between nodes.</p>"},{"location":"public-api/reference/types/#workflowexecutemode","title":"WorkflowExecuteMode","text":"<pre><code>type WorkflowExecuteMode =\n  | 'cli'\n  | 'error'\n  | 'integrated'\n  | 'internal'\n  | 'manual'\n  | 'retry'\n  | 'trigger'\n  | 'webhook'\n  | 'evaluation'\n</code></pre> <p>Indicates how a workflow is being executed.</p>"},{"location":"public-api/reference/types/#fieldtype","title":"FieldType","text":"<pre><code>type FieldType =\n  | 'boolean'\n  | 'number'\n  | 'string'\n  | 'string-alphanumeric'\n  | 'dateTime'\n  | 'time'\n  | 'array'\n  | 'object'\n  | 'options'\n  | 'url'\n  | 'jwt'\n  | 'form-fields'\n</code></pre> <p>Used for validation and resource mapping.</p>"},{"location":"public-api/reference/types/#aievent","title":"AiEvent","text":"<pre><code>type AiEvent =\n  | 'ai-messages-retrieved-from-memory'\n  | 'ai-message-added-to-memory'\n  | 'ai-output-parsed'\n  | 'ai-documents-retrieved'\n  | 'ai-document-embedded'\n  | 'ai-query-embedded'\n  | 'ai-document-processed'\n  | 'ai-text-split'\n  | 'ai-tool-called'\n  | 'ai-vector-store-searched'\n  | 'ai-llm-generated-output'\n  | 'ai-llm-errored'\n  | 'ai-vector-store-populated'\n  | 'ai-vector-store-updated'\n</code></pre> <p>Used with <code>logAiEvent()</code> to track AI-related operations.</p>"},{"location":"public-api/reference/types/#webhookresponsemode","title":"WebhookResponseMode","text":"<pre><code>type WebhookResponseMode = 'onReceived' | 'lastNode' | 'responseNode' | 'formPage'\n</code></pre> <p>Controls how webhook responses are handled.</p>"},{"location":"public-api/reference/types/#loglevel","title":"LogLevel","text":"<pre><code>type LogLevel = 'debug' | 'info' | 'warn' | 'error'\n</code></pre> <p>Used for logging levels in the <code>Logger</code> interface.</p>"},{"location":"public-api/reference/types/#result","title":"Result","text":"<pre><code>type Result&lt;T, E&gt; = { success: true; data: T } | { success: false; error: E }\n</code></pre> <p>Used by <code>startJob()</code> and other async helpers to return success or error outcomes.</p>"},{"location":"public-api/reference/types/#genericvalue","title":"GenericValue","text":"<pre><code>type GenericValue = string | object | number | boolean | undefined | null\n</code></pre> <p>A flexible value type used in many places like <code>IDataObject</code>.</p>"},{"location":"public-api/reference/types/#see-also","title":"See Also","text":"<ul> <li>Interfaces Reference</li> <li>Execution Contexts</li> <li>Helpers</li> </ul>"},{"location":"public-api/workflow/executeWorkflow/","title":"executeWorkflow","text":"<p>The <code>executeWorkflow</code> function allows you to programmatically execute another workflow from within a node. This enables modular workflow design, reusable workflow components, and complex orchestration patterns.</p>"},{"location":"public-api/workflow/executeWorkflow/#when-to-use","title":"When to Use","text":"<p>Use <code>executeWorkflow</code> when your node needs to: - Execute reusable workflow components - Implement modular workflow architecture - Orchestrate complex multi-step processes - Call specialized workflows for specific tasks - Implement workflow-based microservices patterns - Create workflow templates and compositions</p>"},{"location":"public-api/workflow/executeWorkflow/#function-signature","title":"Function Signature","text":"<pre><code>executeWorkflow(\n  workflowInfo: IExecuteWorkflowInfo,\n  items: INodeExecutionData[],\n  options?: IExecuteWorkflowOptions\n): Promise&lt;INodeExecutionData[][]&gt;\n</code></pre>"},{"location":"public-api/workflow/executeWorkflow/#parameters","title":"Parameters","text":"<ul> <li>workflowInfo: Information about the workflow to execute (ID or name)</li> <li>items: Input data to pass to the sub-workflow</li> <li>options: Optional execution configuration</li> </ul>"},{"location":"public-api/workflow/executeWorkflow/#return-value","title":"Return Value","text":"<p>Returns a Promise that resolves to an array of arrays containing the execution results from the sub-workflow.</p>"},{"location":"public-api/workflow/executeWorkflow/#basic-usage","title":"Basic Usage","text":""},{"location":"public-api/workflow/executeWorkflow/#execute-workflow-by-id","title":"Execute Workflow by ID","text":"<pre><code>import { IExecuteFunctions } from 'n8n-workflow'\n\nexport async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n  const subWorkflowId = this.getNodeParameter('workflowId', 0) as string\n\n  const results = []\n\n  for (const item of items) {\n    try {\n      // Execute sub-workflow with current item\n      const subWorkflowResults = await this.executeWorkflow(\n        { id: subWorkflowId },\n        [item]\n      )\n\n      // Process results from sub-workflow\n      const processedResults = subWorkflowResults[0] || []\n\n      results.push({\n        json: {\n          originalData: item.json,\n          subWorkflowResults: processedResults.map(result =&gt; result.json),\n          executedWorkflowId: subWorkflowId,\n          timestamp: new Date().toISOString()\n        }\n      })\n    } catch (error) {\n      results.push({\n        json: {\n          originalData: item.json,\n          error: error.message,\n          workflowId: subWorkflowId,\n          timestamp: new Date().toISOString()\n        }\n      })\n    }\n  }\n\n  return [results]\n}\n</code></pre>"},{"location":"public-api/workflow/executeWorkflow/#execute-workflow-by-name","title":"Execute Workflow by Name","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n  const workflowName = this.getNodeParameter('workflowName', 0) as string\n\n  const results = []\n\n  for (const item of items) {\n    // Execute workflow by name\n    const subWorkflowResults = await this.executeWorkflow(\n      { name: workflowName },\n      [item],\n      {\n        loadedWorkflowData: undefined, // Let n8n resolve the workflow\n        loadedRunData: undefined\n      }\n    )\n\n    results.push({\n      json: {\n        ...item.json,\n        processedBy: workflowName,\n        results: subWorkflowResults[0]?.map(result =&gt; result.json) || []\n      }\n    })\n  }\n\n  return [results]\n}\n</code></pre>"},{"location":"public-api/workflow/executeWorkflow/#advanced-usage","title":"Advanced Usage","text":""},{"location":"public-api/workflow/executeWorkflow/#batch-processing-with-sub-workflows","title":"Batch Processing with Sub-Workflows","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n  const batchSize = this.getNodeParameter('batchSize', 0, 10) as number\n  const processingWorkflowId = this.getNodeParameter('processingWorkflowId', 0) as string\n\n  const results = []\n\n  // Process items in batches\n  for (let i = 0; i &lt; items.length; i += batchSize) {\n    const batch = items.slice(i, i + batchSize)\n\n    try {\n      // Execute sub-workflow with batch\n      const batchResults = await this.executeWorkflow(\n        { id: processingWorkflowId },\n        batch,\n        {\n          parentExecution: {\n            executionId: this.getExecutionId(),\n            workflowId: this.getWorkflow().id\n          }\n        }\n      )\n\n      // Flatten results from all output branches\n      const flattenedResults = batchResults.flat()\n\n      results.push({\n        json: {\n          batchNumber: Math.floor(i / batchSize) + 1,\n          batchSize: batch.length,\n          processedItems: flattenedResults.length,\n          results: flattenedResults.map(result =&gt; result.json),\n          processingTime: new Date().toISOString()\n        }\n      })\n    } catch (error) {\n      results.push({\n        json: {\n          batchNumber: Math.floor(i / batchSize) + 1,\n          batchSize: batch.length,\n          error: error.message,\n          failedItems: batch.map(item =&gt; item.json)\n        }\n      })\n    }\n  }\n\n  return [results]\n}\n</code></pre>"},{"location":"public-api/workflow/executeWorkflow/#conditional-workflow-execution","title":"Conditional Workflow Execution","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n\n  // Define workflow mappings based on conditions\n  const workflowMappings = {\n    'high_priority': this.getNodeParameter('highPriorityWorkflowId', 0) as string,\n    'medium_priority': this.getNodeParameter('mediumPriorityWorkflowId', 0) as string,\n    'low_priority': this.getNodeParameter('lowPriorityWorkflowId', 0) as string,\n    'default': this.getNodeParameter('defaultWorkflowId', 0) as string\n  }\n\n  const results = []\n\n  for (const item of items) {\n    // Determine which workflow to execute\n    const priority = item.json.priority || 'default'\n    const workflowId = workflowMappings[priority] || workflowMappings['default']\n\n    try {\n      const subWorkflowResults = await this.executeWorkflow(\n        { id: workflowId },\n        [item],\n        {\n          // Pass additional context\n          additionalData: {\n            priority,\n            parentWorkflow: this.getWorkflow().name,\n            executionContext: 'conditional_routing'\n          }\n        }\n      )\n\n      results.push({\n        json: {\n          ...item.json,\n          processedBy: workflowId,\n          priority,\n          results: subWorkflowResults[0]?.map(result =&gt; result.json) || []\n        }\n      })\n    } catch (error) {\n      results.push({\n        json: {\n          ...item.json,\n          error: error.message,\n          priority,\n          failedWorkflowId: workflowId\n        }\n      })\n    }\n  }\n\n  return [results]\n}\n</code></pre>"},{"location":"public-api/workflow/executeWorkflow/#parallel-workflow-execution","title":"Parallel Workflow Execution","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n  const maxConcurrency = this.getNodeParameter('maxConcurrency', 0, 3) as number\n  const workflowIds = this.getNodeParameter('workflowIds', 0) as string[]\n\n  const results = []\n\n  // Process items with controlled concurrency\n  const processItem = async (item: any) =&gt; {\n    const itemResults = []\n\n    // Execute multiple workflows for each item\n    const workflowPromises = workflowIds.map(async (workflowId) =&gt; {\n      try {\n        const subWorkflowResults = await this.executeWorkflow(\n          { id: workflowId },\n          [item]\n        )\n\n        return {\n          workflowId,\n          success: true,\n          results: subWorkflowResults[0] || []\n        }\n      } catch (error) {\n        return {\n          workflowId,\n          success: false,\n          error: error.message\n        }\n      }\n    })\n\n    const workflowResults = await Promise.all(workflowPromises)\n\n    return {\n      json: {\n        originalData: item.json,\n        workflowResults,\n        executionSummary: {\n          total: workflowIds.length,\n          successful: workflowResults.filter(r =&gt; r.success).length,\n          failed: workflowResults.filter(r =&gt; !r.success).length\n        }\n      }\n    }\n  }\n\n  // Control concurrency\n  const semaphore = new Array(maxConcurrency).fill(null)\n  const processQueue = items.map(item =&gt; () =&gt; processItem(item))\n\n  const processWithConcurrency = async () =&gt; {\n    const results = []\n    let index = 0\n\n    const workers = semaphore.map(async () =&gt; {\n      while (index &lt; processQueue.length) {\n        const currentIndex = index++\n        const processor = processQueue[currentIndex]\n        const result = await processor()\n        results[currentIndex] = result\n      }\n    })\n\n    await Promise.all(workers)\n    return results.filter(Boolean)\n  }\n\n  const processedResults = await processWithConcurrency()\n\n  return [processedResults]\n}\n</code></pre>"},{"location":"public-api/workflow/executeWorkflow/#workflow-orchestration-patterns","title":"Workflow Orchestration Patterns","text":""},{"location":"public-api/workflow/executeWorkflow/#pipeline-pattern","title":"Pipeline Pattern","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n  const pipelineSteps = this.getNodeParameter('pipelineSteps', 0) as Array&lt;{\n    workflowId: string\n    name: string\n    required: boolean\n  }&gt;\n\n  const results = []\n\n  for (const item of items) {\n    let currentData = [item]\n    const pipelineResults = []\n\n    // Execute pipeline steps sequentially\n    for (const step of pipelineSteps) {\n      try {\n        const stepResults = await this.executeWorkflow(\n          { id: step.workflowId },\n          currentData\n        )\n\n        pipelineResults.push({\n          step: step.name,\n          workflowId: step.workflowId,\n          success: true,\n          outputCount: stepResults[0]?.length || 0\n        })\n\n        // Use output as input for next step\n        currentData = stepResults[0] || []\n\n        // If no output and step is required, fail the pipeline\n        if (currentData.length === 0 &amp;&amp; step.required) {\n          throw new Error(`Required step '${step.name}' produced no output`)\n        }\n      } catch (error) {\n        pipelineResults.push({\n          step: step.name,\n          workflowId: step.workflowId,\n          success: false,\n          error: error.message\n        })\n\n        if (step.required) {\n          break // Stop pipeline on required step failure\n        }\n      }\n    }\n\n    results.push({\n      json: {\n        originalData: item.json,\n        pipelineResults,\n        finalOutput: currentData.map(d =&gt; d.json),\n        pipelineSuccess: pipelineResults.every(r =&gt; r.success || !r.required)\n      }\n    })\n  }\n\n  return [results]\n}\n</code></pre>"},{"location":"public-api/workflow/executeWorkflow/#fan-outfan-in-pattern","title":"Fan-Out/Fan-In Pattern","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n  const fanOutWorkflows = this.getNodeParameter('fanOutWorkflows', 0) as string[]\n  const fanInWorkflowId = this.getNodeParameter('fanInWorkflowId', 0) as string\n\n  const results = []\n\n  for (const item of items) {\n    // Fan-out: Execute multiple workflows in parallel\n    const fanOutPromises = fanOutWorkflows.map(async (workflowId) =&gt; {\n      try {\n        const results = await this.executeWorkflow(\n          { id: workflowId },\n          [item]\n        )\n        return {\n          workflowId,\n          success: true,\n          data: results[0] || []\n        }\n      } catch (error) {\n        return {\n          workflowId,\n          success: false,\n          error: error.message,\n          data: []\n        }\n      }\n    })\n\n    const fanOutResults = await Promise.all(fanOutPromises)\n\n    // Collect all successful results\n    const allFanOutData = fanOutResults\n      .filter(result =&gt; result.success)\n      .flatMap(result =&gt; result.data)\n\n    // Fan-in: Aggregate results through final workflow\n    let fanInResults = []\n    if (allFanOutData.length &gt; 0) {\n      try {\n        const aggregatedResults = await this.executeWorkflow(\n          { id: fanInWorkflowId },\n          allFanOutData\n        )\n        fanInResults = aggregatedResults[0] || []\n      } catch (error) {\n        // Handle fan-in failure\n        fanInResults = [{\n          json: {\n            error: 'Fan-in workflow failed',\n            details: error.message,\n            inputData: allFanOutData.map(d =&gt; d.json)\n          }\n        }]\n      }\n    }\n\n    results.push({\n      json: {\n        originalData: item.json,\n        fanOutResults: fanOutResults.map(r =&gt; ({\n          workflowId: r.workflowId,\n          success: r.success,\n          error: r.error,\n          outputCount: r.data.length\n        })),\n        fanInResults: fanInResults.map(r =&gt; r.json),\n        totalProcessed: allFanOutData.length\n      }\n    })\n  }\n\n  return [results]\n}\n</code></pre>"},{"location":"public-api/workflow/executeWorkflow/#error-handling-and-retry-logic","title":"Error Handling and Retry Logic","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n  const workflowId = this.getNodeParameter('workflowId', 0) as string\n  const maxRetries = this.getNodeParameter('maxRetries', 0, 3) as number\n  const retryDelay = this.getNodeParameter('retryDelay', 0, 1000) as number\n\n  const executeWithRetry = async (item: any, retries: number = 0): Promise&lt;any&gt; =&gt; {\n    try {\n      const results = await this.executeWorkflow(\n        { id: workflowId },\n        [item],\n        {\n          timeout: 30000, // 30 second timeout\n          continueOnFail: false\n        }\n      )\n\n      return {\n        success: true,\n        data: results[0] || [],\n        retries\n      }\n    } catch (error) {\n      if (retries &lt; maxRetries) {\n        // Wait before retry\n        await new Promise(resolve =&gt; setTimeout(resolve, retryDelay * Math.pow(2, retries)))\n        return executeWithRetry(item, retries + 1)\n      } else {\n        return {\n          success: false,\n          error: error.message,\n          retries,\n          finalFailure: true\n        }\n      }\n    }\n  }\n\n  const results = []\n\n  for (const item of items) {\n    const result = await executeWithRetry(item)\n\n    results.push({\n      json: {\n        originalData: item.json,\n        ...result,\n        workflowId,\n        timestamp: new Date().toISOString()\n      }\n    })\n  }\n\n  return [results]\n}\n</code></pre>"},{"location":"public-api/workflow/executeWorkflow/#performance-considerations","title":"Performance Considerations","text":""},{"location":"public-api/workflow/executeWorkflow/#workflow-caching","title":"Workflow Caching","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n  const staticData = this.getWorkflowStaticData('global')\n\n  // Cache workflow metadata\n  if (!staticData.workflowCache) {\n    staticData.workflowCache = {}\n  }\n\n  const getWorkflowInfo = async (workflowId: string) =&gt; {\n    if (!staticData.workflowCache[workflowId]) {\n      // Cache workflow information for faster subsequent calls\n      staticData.workflowCache[workflowId] = {\n        id: workflowId,\n        lastAccessed: Date.now(),\n        executionCount: 0\n      }\n    }\n\n    staticData.workflowCache[workflowId].lastAccessed = Date.now()\n    staticData.workflowCache[workflowId].executionCount++\n\n    return staticData.workflowCache[workflowId]\n  }\n\n  const workflowId = this.getNodeParameter('workflowId', 0) as string\n  const workflowInfo = await getWorkflowInfo(workflowId)\n\n  const results = []\n\n  for (const item of items) {\n    const subWorkflowResults = await this.executeWorkflow(\n      { id: workflowId },\n      [item]\n    )\n\n    results.push({\n      json: {\n        ...item.json,\n        results: subWorkflowResults[0]?.map(r =&gt; r.json) || [],\n        workflowInfo\n      }\n    })\n  }\n\n  return [results]\n}\n</code></pre>"},{"location":"public-api/workflow/executeWorkflow/#best-practices","title":"Best Practices","text":"<ol> <li>Handle errors gracefully with proper try-catch blocks</li> <li>Implement retry logic for transient failures</li> <li>Use appropriate timeouts to prevent hanging executions</li> <li>Monitor sub-workflow performance and resource usage</li> <li>Cache workflow metadata when executing the same workflow repeatedly</li> <li>Implement circuit breaker patterns for unreliable sub-workflows</li> <li>Use meaningful error messages for debugging</li> <li>Consider workflow versioning for production environments</li> </ol>"},{"location":"public-api/workflow/executeWorkflow/#common-use-cases","title":"Common Use Cases","text":""},{"location":"public-api/workflow/executeWorkflow/#data-processing-pipeline","title":"Data Processing Pipeline","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n  const dataProcessingWorkflowId = this.getNodeParameter('dataProcessingWorkflowId', 0) as string\n\n  const results = []\n\n  for (const item of items) {\n    // Execute data processing workflow\n    const processedResults = await this.executeWorkflow(\n      { id: dataProcessingWorkflowId },\n      [item]\n    )\n\n    results.push({\n      json: {\n        originalData: item.json,\n        processedData: processedResults[0]?.map(r =&gt; r.json) || [],\n        processingTimestamp: new Date().toISOString()\n      }\n    })\n  }\n\n  return [results]\n}\n</code></pre>"},{"location":"public-api/workflow/executeWorkflow/#microservice-orchestration","title":"Microservice Orchestration","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n\n  // Define microservice workflows\n  const services = {\n    userService: this.getNodeParameter('userServiceWorkflowId', 0) as string,\n    paymentService: this.getNodeParameter('paymentServiceWorkflowId', 0) as string,\n    notificationService: this.getNodeParameter('notificationServiceWorkflowId', 0) as string\n  }\n\n  const results = []\n\n  for (const item of items) {\n    const serviceResults = {}\n\n    // Call each microservice\n    for (const [serviceName, workflowId] of Object.entries(services)) {\n      try {\n        const serviceResult = await this.executeWorkflow(\n          { id: workflowId },\n          [item]\n        )\n\n        serviceResults[serviceName] = {\n          success: true,\n          data: serviceResult[0]?.map(r =&gt; r.json) || []\n        }\n      } catch (error) {\n        serviceResults[serviceName] = {\n          success: false,\n          error: error.message\n        }\n      }\n    }\n\n    results.push({\n      json: {\n        originalData: item.json,\n        serviceResults,\n        allServicesSuccessful: Object.values(serviceResults).every((r: any) =&gt; r.success)\n      }\n    })\n  }\n\n  return [results]\n}\n</code></pre>"},{"location":"public-api/workflow/executeWorkflow/#related-documentation","title":"Related Documentation","text":"<ul> <li>getWorkflow - For accessing workflow information</li> <li>getWorkflowStaticData - For persistent workflow data</li> <li>putExecutionToWait - For pausing executions</li> <li>IExecuteFunctions - Main execution context</li> <li>Error Handling - Advanced error handling patterns</li> </ul>"},{"location":"public-api/workflow/getWorkflow/","title":"getWorkflow","text":"<p>The <code>getWorkflow</code> function provides access to the current workflow's information and metadata during node execution. This allows nodes to access workflow-level data, settings, and configuration that may be needed for processing.</p>"},{"location":"public-api/workflow/getWorkflow/#when-to-use","title":"When to Use","text":"<p>Use <code>getWorkflow</code> when your node needs to: - Access workflow metadata and properties - Get workflow ID, name, or other identifying information - Access workflow-level settings or configuration - Implement workflow-aware logic - Log or track workflow execution information</p>"},{"location":"public-api/workflow/getWorkflow/#function-signature","title":"Function Signature","text":"<pre><code>getWorkflow(): Workflow\n</code></pre>"},{"location":"public-api/workflow/getWorkflow/#return-value","title":"Return Value","text":"<p>Returns a <code>Workflow</code> object containing: - id: Workflow identifier - name: Workflow name - nodes: Array of workflow nodes - connections: Node connections configuration - settings: Workflow settings and configuration - staticData: Workflow static data - meta: Additional workflow metadata</p>"},{"location":"public-api/workflow/getWorkflow/#basic-usage","title":"Basic Usage","text":""},{"location":"public-api/workflow/getWorkflow/#accessing-workflow-information","title":"Accessing Workflow Information","text":"<pre><code>import { IExecuteFunctions } from 'n8n-workflow'\n\nexport async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n  const workflow = this.getWorkflow()\n\n  const results = []\n\n  for (const item of items) {\n    results.push({\n      json: {\n        ...item.json,\n        workflowInfo: {\n          id: workflow.id,\n          name: workflow.name,\n          nodeCount: workflow.nodes.length\n        }\n      }\n    })\n  }\n\n  return [results]\n}\n</code></pre>"},{"location":"public-api/workflow/getWorkflow/#workflow-based-conditional-logic","title":"Workflow-Based Conditional Logic","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n  const workflow = this.getWorkflow()\n\n  // Different behavior based on workflow name\n  const isProductionWorkflow = workflow.name?.includes('Production')\n  const isTestWorkflow = workflow.name?.includes('Test')\n\n  const results = []\n\n  for (const item of items) {\n    let processedItem = { ...item.json }\n\n    if (isProductionWorkflow) {\n      // Production-specific processing\n      processedItem.environment = 'production'\n      processedItem.logLevel = 'error'\n    } else if (isTestWorkflow) {\n      // Test-specific processing\n      processedItem.environment = 'test'\n      processedItem.logLevel = 'debug'\n    } else {\n      // Development processing\n      processedItem.environment = 'development'\n      processedItem.logLevel = 'verbose'\n    }\n\n    results.push({ json: processedItem })\n  }\n\n  return [results]\n}\n</code></pre>"},{"location":"public-api/workflow/getWorkflow/#advanced-usage","title":"Advanced Usage","text":""},{"location":"public-api/workflow/getWorkflow/#analyzing-workflow-structure","title":"Analyzing Workflow Structure","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n  const workflow = this.getWorkflow()\n\n  // Analyze workflow structure\n  const nodeTypes = workflow.nodes.map(node =&gt; node.type)\n  const uniqueNodeTypes = [...new Set(nodeTypes)]\n\n  // Find specific node types\n  const httpNodes = workflow.nodes.filter(node =&gt; node.type === 'n8n-nodes-base.httpRequest')\n  const webhookNodes = workflow.nodes.filter(node =&gt; node.type === 'n8n-nodes-base.webhook')\n\n  // Analyze connections\n  const connectionCount = Object.keys(workflow.connections).length\n\n  const workflowAnalysis = {\n    totalNodes: workflow.nodes.length,\n    uniqueNodeTypes: uniqueNodeTypes.length,\n    nodeTypes: uniqueNodeTypes,\n    httpRequestCount: httpNodes.length,\n    webhookCount: webhookNodes.length,\n    connectionCount\n  }\n\n  const results = []\n\n  for (const item of items) {\n    results.push({\n      json: {\n        ...item.json,\n        workflowAnalysis\n      }\n    })\n  }\n\n  return [results]\n}\n</code></pre>"},{"location":"public-api/workflow/getWorkflow/#workflow-settings-access","title":"Workflow Settings Access","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n  const workflow = this.getWorkflow()\n\n  // Access workflow settings\n  const settings = workflow.settings || {}\n\n  // Common workflow settings\n  const timezone = settings.timezone || 'UTC'\n  const saveDataErrorExecution = settings.saveDataErrorExecution !== false\n  const saveDataSuccessExecution = settings.saveDataSuccessExecution !== false\n  const executionTimeout = settings.executionTimeout || 0\n\n  const results = []\n\n  for (const item of items) {\n    results.push({\n      json: {\n        ...item.json,\n        workflowSettings: {\n          timezone,\n          saveDataErrorExecution,\n          saveDataSuccessExecution,\n          executionTimeout\n        }\n      }\n    })\n  }\n\n  return [results]\n}\n</code></pre>"},{"location":"public-api/workflow/getWorkflow/#node-relationship-analysis","title":"Node Relationship Analysis","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n  const workflow = this.getWorkflow()\n  const currentNodeName = this.getNode().name\n\n  // Find current node in workflow\n  const currentNode = workflow.nodes.find(node =&gt; node.name === currentNodeName)\n\n  // Analyze node connections\n  const connections = workflow.connections\n  const nodeConnections = connections[currentNodeName] || {}\n\n  // Find predecessor nodes\n  const predecessors = []\n  for (const [nodeName, nodeConnections] of Object.entries(connections)) {\n    const outputs = nodeConnections.main || []\n    for (const outputConnections of outputs) {\n      if (outputConnections?.some(conn =&gt; conn.node === currentNodeName)) {\n        predecessors.push(nodeName)\n      }\n    }\n  }\n\n  // Find successor nodes\n  const successors = []\n  const mainOutputs = nodeConnections.main || []\n  for (const outputConnections of mainOutputs) {\n    if (outputConnections) {\n      successors.push(...outputConnections.map(conn =&gt; conn.node))\n    }\n  }\n\n  const results = []\n\n  for (const item of items) {\n    results.push({\n      json: {\n        ...item.json,\n        nodeRelationships: {\n          currentNode: currentNodeName,\n          predecessors,\n          successors,\n          isFirstNode: predecessors.length === 0,\n          isLastNode: successors.length === 0\n        }\n      }\n    })\n  }\n\n  return [results]\n}\n</code></pre>"},{"location":"public-api/workflow/getWorkflow/#workflow-metadata-patterns","title":"Workflow Metadata Patterns","text":""},{"location":"public-api/workflow/getWorkflow/#workflow-tagging-and-classification","title":"Workflow Tagging and Classification","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n  const workflow = this.getWorkflow()\n\n  // Extract tags from workflow name or metadata\n  const workflowName = workflow.name || ''\n  const tags = []\n\n  // Extract tags from name patterns\n  if (workflowName.includes('[PROD]')) tags.push('production')\n  if (workflowName.includes('[TEST]')) tags.push('test')\n  if (workflowName.includes('[DEV]')) tags.push('development')\n\n  // Classify by node types\n  const nodeTypes = workflow.nodes.map(node =&gt; node.type)\n  if (nodeTypes.some(type =&gt; type.includes('webhook'))) tags.push('webhook-triggered')\n  if (nodeTypes.some(type =&gt; type.includes('cron'))) tags.push('scheduled')\n  if (nodeTypes.some(type =&gt; type.includes('http'))) tags.push('api-integration')\n\n  const results = []\n\n  for (const item of items) {\n    results.push({\n      json: {\n        ...item.json,\n        workflowClassification: {\n          name: workflowName,\n          tags,\n          category: tags.includes('production') ? 'production' : 'development'\n        }\n      }\n    })\n  }\n\n  return [results]\n}\n</code></pre>"},{"location":"public-api/workflow/getWorkflow/#workflow-complexity-analysis","title":"Workflow Complexity Analysis","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n  const workflow = this.getWorkflow()\n\n  // Calculate workflow complexity metrics\n  const nodeCount = workflow.nodes.length\n  const connectionCount = Object.values(workflow.connections).reduce((total, nodeConns) =&gt; {\n    const mainConns = nodeConns.main || []\n    return total + mainConns.reduce((sum, conns) =&gt; sum + (conns?.length || 0), 0)\n  }, 0)\n\n  // Analyze node type diversity\n  const nodeTypes = workflow.nodes.map(node =&gt; node.type)\n  const uniqueNodeTypes = new Set(nodeTypes)\n  const typeComplexity = uniqueNodeTypes.size / nodeCount\n\n  // Calculate branching factor\n  const branchingNodes = workflow.nodes.filter(node =&gt; {\n    const connections = workflow.connections[node.name]?.main || []\n    return connections.some(conns =&gt; conns &amp;&amp; conns.length &gt; 1)\n  })\n\n  const complexityScore = {\n    nodeCount,\n    connectionCount,\n    uniqueNodeTypes: uniqueNodeTypes.size,\n    typeComplexity: Math.round(typeComplexity * 100) / 100,\n    branchingNodes: branchingNodes.length,\n    complexity: nodeCount &lt; 5 ? 'simple' : nodeCount &lt; 15 ? 'moderate' : 'complex'\n  }\n\n  const results = []\n\n  for (const item of items) {\n    results.push({\n      json: {\n        ...item.json,\n        workflowComplexity: complexityScore\n      }\n    })\n  }\n\n  return [results]\n}\n</code></pre>"},{"location":"public-api/workflow/getWorkflow/#workflow-validation","title":"Workflow Validation","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n  const workflow = this.getWorkflow()\n\n  const validationResults = {\n    isValid: true,\n    warnings: [],\n    errors: []\n  }\n\n  // Validate workflow structure\n  if (!workflow.name || workflow.name.trim().length === 0) {\n    validationResults.warnings.push('Workflow has no name')\n  }\n\n  if (workflow.nodes.length === 0) {\n    validationResults.errors.push('Workflow has no nodes')\n    validationResults.isValid = false\n  }\n\n  // Check for orphaned nodes\n  const connectedNodes = new Set()\n  Object.values(workflow.connections).forEach(nodeConns =&gt; {\n    const mainConns = nodeConns.main || []\n    mainConns.forEach(conns =&gt; {\n      conns?.forEach(conn =&gt; connectedNodes.add(conn.node))\n    })\n  })\n\n  const orphanedNodes = workflow.nodes.filter(node =&gt; \n    !connectedNodes.has(node.name) &amp;&amp; \n    !Object.keys(workflow.connections).includes(node.name)\n  )\n\n  if (orphanedNodes.length &gt; 0) {\n    validationResults.warnings.push(`Found ${orphanedNodes.length} orphaned nodes`)\n  }\n\n  // Check for missing required parameters\n  const nodesWithMissingParams = workflow.nodes.filter(node =&gt; {\n    // This would need to be customized based on node type requirements\n    return false // Placeholder\n  })\n\n  const results = []\n\n  for (const item of items) {\n    results.push({\n      json: {\n        ...item.json,\n        workflowValidation: validationResults\n      }\n    })\n  }\n\n  return [results]\n}\n</code></pre>"},{"location":"public-api/workflow/getWorkflow/#performance-considerations","title":"Performance Considerations","text":""},{"location":"public-api/workflow/getWorkflow/#caching-workflow-information","title":"Caching Workflow Information","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n\n  // Cache workflow info to avoid repeated calls\n  if (!this._workflowCache) {\n    const workflow = this.getWorkflow()\n    this._workflowCache = {\n      id: workflow.id,\n      name: workflow.name,\n      nodeCount: workflow.nodes.length,\n      settings: workflow.settings || {}\n    }\n  }\n\n  const results = []\n\n  for (const item of items) {\n    results.push({\n      json: {\n        ...item.json,\n        workflowInfo: this._workflowCache\n      }\n    })\n  }\n\n  return [results]\n}\n</code></pre>"},{"location":"public-api/workflow/getWorkflow/#selective-workflow-data-access","title":"Selective Workflow Data Access","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n  const workflow = this.getWorkflow()\n\n  // Only extract needed information to minimize memory usage\n  const workflowSummary = {\n    id: workflow.id,\n    name: workflow.name,\n    nodeCount: workflow.nodes.length,\n    // Don't include full nodes array or connections for large workflows\n    hasWebhooks: workflow.nodes.some(node =&gt; node.type.includes('webhook')),\n    hasSchedule: workflow.nodes.some(node =&gt; node.type.includes('cron'))\n  }\n\n  const results = []\n\n  for (const item of items) {\n    results.push({\n      json: {\n        ...item.json,\n        workflow: workflowSummary\n      }\n    })\n  }\n\n  return [results]\n}\n</code></pre>"},{"location":"public-api/workflow/getWorkflow/#best-practices","title":"Best Practices","text":"<ol> <li>Cache workflow information when processing multiple items</li> <li>Extract only needed data to minimize memory usage</li> <li>Validate workflow structure before relying on it</li> <li>Handle missing workflow data gracefully</li> <li>Use workflow metadata for environment-specific logic</li> <li>Document workflow dependencies in your node</li> <li>Consider workflow complexity when implementing features</li> </ol>"},{"location":"public-api/workflow/getWorkflow/#common-use-cases","title":"Common Use Cases","text":""},{"location":"public-api/workflow/getWorkflow/#environment-detection","title":"Environment Detection","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n  const workflow = this.getWorkflow()\n\n  // Detect environment from workflow name or settings\n  const workflowName = workflow.name?.toLowerCase() || ''\n  const environment = workflowName.includes('prod') ? 'production' :\n                     workflowName.includes('test') ? 'test' : 'development'\n\n  // Adjust behavior based on environment\n  const config = {\n    logLevel: environment === 'production' ? 'error' : 'debug',\n    enableMetrics: environment === 'production',\n    timeout: environment === 'production' ? 30000 : 60000\n  }\n\n  return [items]\n}\n</code></pre>"},{"location":"public-api/workflow/getWorkflow/#workflow-documentation","title":"Workflow Documentation","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n  const workflow = this.getWorkflow()\n\n  // Generate workflow documentation\n  const documentation = {\n    name: workflow.name,\n    description: workflow.meta?.description || 'No description provided',\n    nodes: workflow.nodes.map(node =&gt; ({\n      name: node.name,\n      type: node.type,\n      position: node.position\n    })),\n    complexity: workflow.nodes.length &lt; 10 ? 'Simple' : 'Complex',\n    lastModified: workflow.meta?.lastModified || 'Unknown'\n  }\n\n  return [{\n    json: {\n      workflowDocumentation: documentation\n    }\n  }]\n}\n</code></pre>"},{"location":"public-api/workflow/getWorkflow/#related-documentation","title":"Related Documentation","text":"<ul> <li>getWorkflowStaticData - For accessing workflow static data</li> <li>executeWorkflow - For executing sub-workflows</li> <li>IExecuteFunctions - Main execution context</li> <li>Base Helpers - Core helper functions</li> </ul>"},{"location":"public-api/workflow/getWorkflowStaticData/","title":"getWorkflowStaticData","text":"<p>The <code>getWorkflowStaticData</code> function provides access to persistent, workflow-scoped static data that persists across workflow executions. This data is stored at the workflow level and can be used to maintain state, cache information, or store configuration that needs to persist between runs.</p>"},{"location":"public-api/workflow/getWorkflowStaticData/#when-to-use","title":"When to Use","text":"<p>Use <code>getWorkflowStaticData</code> when your node needs to: - Store state that persists across workflow executions - Cache expensive computations or API responses - Maintain counters, timestamps, or tracking information - Store configuration that should persist between runs - Implement rate limiting or throttling mechanisms - Track execution history or statistics</p>"},{"location":"public-api/workflow/getWorkflowStaticData/#function-signature","title":"Function Signature","text":"<pre><code>getWorkflowStaticData(type: string): IDataObject\n</code></pre>"},{"location":"public-api/workflow/getWorkflowStaticData/#parameters","title":"Parameters","text":"<ul> <li>type: The type/namespace of static data to access (e.g., 'global', 'node', 'user')</li> </ul>"},{"location":"public-api/workflow/getWorkflowStaticData/#return-value","title":"Return Value","text":"<p>Returns an <code>IDataObject</code> that can be read from and written to. Changes are automatically persisted.</p>"},{"location":"public-api/workflow/getWorkflowStaticData/#basic-usage","title":"Basic Usage","text":""},{"location":"public-api/workflow/getWorkflowStaticData/#simple-state-storage","title":"Simple State Storage","text":"<pre><code>import { IExecuteFunctions } from 'n8n-workflow'\n\nexport async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n\n  // Get workflow static data\n  const staticData = this.getWorkflowStaticData('global')\n\n  // Initialize counter if it doesn't exist\n  if (!staticData.executionCount) {\n    staticData.executionCount = 0\n  }\n\n  // Increment counter\n  staticData.executionCount++\n  staticData.lastExecuted = new Date().toISOString()\n\n  const results = []\n\n  for (const item of items) {\n    results.push({\n      json: {\n        ...item.json,\n        executionNumber: staticData.executionCount,\n        lastExecuted: staticData.lastExecuted\n      }\n    })\n  }\n\n  return [results]\n}\n</code></pre>"},{"location":"public-api/workflow/getWorkflowStaticData/#caching-api-responses","title":"Caching API Responses","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n  const staticData = this.getWorkflowStaticData('global')\n\n  // Initialize cache if it doesn't exist\n  if (!staticData.cache) {\n    staticData.cache = {}\n  }\n\n  const results = []\n\n  for (const item of items) {\n    const cacheKey = `user_${item.json.userId}`\n    const cacheExpiry = 5 * 60 * 1000 // 5 minutes\n\n    // Check if we have cached data\n    const cachedData = staticData.cache[cacheKey]\n    const now = Date.now()\n\n    let userData\n\n    if (cachedData &amp;&amp; (now - cachedData.timestamp) &lt; cacheExpiry) {\n      // Use cached data\n      userData = cachedData.data\n    } else {\n      // Fetch fresh data\n      userData = await fetchUserData(item.json.userId)\n\n      // Cache the result\n      staticData.cache[cacheKey] = {\n        data: userData,\n        timestamp: now\n      }\n    }\n\n    results.push({\n      json: {\n        ...item.json,\n        userData,\n        fromCache: cachedData &amp;&amp; (now - cachedData.timestamp) &lt; cacheExpiry\n      }\n    })\n  }\n\n  return [results]\n}\n</code></pre>"},{"location":"public-api/workflow/getWorkflowStaticData/#advanced-usage","title":"Advanced Usage","text":""},{"location":"public-api/workflow/getWorkflowStaticData/#rate-limiting","title":"Rate Limiting","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n  const staticData = this.getWorkflowStaticData('global')\n\n  // Initialize rate limiting data\n  if (!staticData.rateLimiting) {\n    staticData.rateLimiting = {\n      requests: [],\n      maxRequests: 100,\n      timeWindow: 60 * 1000 // 1 minute\n    }\n  }\n\n  const rateLimiting = staticData.rateLimiting\n  const now = Date.now()\n\n  // Clean old requests outside time window\n  rateLimiting.requests = rateLimiting.requests.filter(\n    timestamp =&gt; (now - timestamp) &lt; rateLimiting.timeWindow\n  )\n\n  const results = []\n\n  for (const item of items) {\n    // Check rate limit\n    if (rateLimiting.requests.length &gt;= rateLimiting.maxRequests) {\n      results.push({\n        json: {\n          ...item.json,\n          error: 'Rate limit exceeded',\n          rateLimitStatus: {\n            current: rateLimiting.requests.length,\n            max: rateLimiting.maxRequests,\n            resetTime: Math.min(...rateLimiting.requests) + rateLimiting.timeWindow\n          }\n        }\n      })\n      continue\n    }\n\n    // Record this request\n    rateLimiting.requests.push(now)\n\n    // Process the item\n    const result = await processItem(item)\n\n    results.push({\n      json: {\n        ...result,\n        rateLimitStatus: {\n          current: rateLimiting.requests.length,\n          max: rateLimiting.maxRequests,\n          remaining: rateLimiting.maxRequests - rateLimiting.requests.length\n        }\n      }\n    })\n  }\n\n  return [results]\n}\n</code></pre>"},{"location":"public-api/workflow/getWorkflowStaticData/#configuration-management","title":"Configuration Management","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n  const staticData = this.getWorkflowStaticData('global')\n\n  // Initialize configuration\n  if (!staticData.config) {\n    staticData.config = {\n      apiEndpoints: {\n        primary: 'https://api.example.com',\n        fallback: 'https://backup-api.example.com'\n      },\n      retrySettings: {\n        maxRetries: 3,\n        backoffMultiplier: 2,\n        initialDelay: 1000\n      },\n      features: {\n        enableLogging: true,\n        enableMetrics: false,\n        enableCache: true\n      },\n      lastUpdated: new Date().toISOString()\n    }\n  }\n\n  const config = staticData.config\n\n  // Update configuration if needed\n  const forceConfigUpdate = this.getNodeParameter('forceConfigUpdate', 0, false) as boolean\n  if (forceConfigUpdate) {\n    config.features.enableLogging = this.getNodeParameter('enableLogging', 0, true) as boolean\n    config.features.enableMetrics = this.getNodeParameter('enableMetrics', 0, false) as boolean\n    config.lastUpdated = new Date().toISOString()\n  }\n\n  const results = []\n\n  for (const item of items) {\n    results.push({\n      json: {\n        ...item.json,\n        config: {\n          ...config,\n          // Don't expose sensitive configuration\n          apiEndpoints: undefined\n        }\n      }\n    })\n  }\n\n  return [results]\n}\n</code></pre>"},{"location":"public-api/workflow/getWorkflowStaticData/#execution-history-tracking","title":"Execution History Tracking","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n  const staticData = this.getWorkflowStaticData('global')\n\n  // Initialize execution history\n  if (!staticData.executionHistory) {\n    staticData.executionHistory = {\n      executions: [],\n      maxHistory: 100,\n      statistics: {\n        totalExecutions: 0,\n        successfulExecutions: 0,\n        failedExecutions: 0,\n        averageItemsProcessed: 0\n      }\n    }\n  }\n\n  const history = staticData.executionHistory\n  const executionStart = Date.now()\n\n  let success = true\n  const results = []\n\n  try {\n    for (const item of items) {\n      const processedItem = await processItem(item)\n      results.push(processedItem)\n    }\n  } catch (error) {\n    success = false\n    throw error\n  } finally {\n    // Record execution\n    const executionEnd = Date.now()\n    const execution = {\n      timestamp: new Date().toISOString(),\n      duration: executionEnd - executionStart,\n      itemsProcessed: items.length,\n      success,\n      error: success ? null : 'Execution failed'\n    }\n\n    // Add to history\n    history.executions.push(execution)\n\n    // Trim history if too long\n    if (history.executions.length &gt; history.maxHistory) {\n      history.executions = history.executions.slice(-history.maxHistory)\n    }\n\n    // Update statistics\n    history.statistics.totalExecutions++\n    if (success) {\n      history.statistics.successfulExecutions++\n    } else {\n      history.statistics.failedExecutions++\n    }\n\n    // Calculate average items processed\n    const totalItems = history.executions.reduce((sum, exec) =&gt; sum + exec.itemsProcessed, 0)\n    history.statistics.averageItemsProcessed = totalItems / history.executions.length\n  }\n\n  return [results]\n}\n</code></pre>"},{"location":"public-api/workflow/getWorkflowStaticData/#data-management-patterns","title":"Data Management Patterns","text":""},{"location":"public-api/workflow/getWorkflowStaticData/#namespaced-data-storage","title":"Namespaced Data Storage","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n  const nodeType = this.getNode().type\n\n  // Use node-specific namespace\n  const staticData = this.getWorkflowStaticData('global')\n\n  // Create namespace for this node type\n  if (!staticData[nodeType]) {\n    staticData[nodeType] = {\n      settings: {},\n      cache: {},\n      counters: {},\n      lastAccess: new Date().toISOString()\n    }\n  }\n\n  const nodeData = staticData[nodeType]\n  nodeData.lastAccess = new Date().toISOString()\n\n  // Use namespaced data\n  if (!nodeData.counters.processedItems) {\n    nodeData.counters.processedItems = 0\n  }\n\n  nodeData.counters.processedItems += items.length\n\n  return [items]\n}\n</code></pre>"},{"location":"public-api/workflow/getWorkflowStaticData/#data-cleanup-and-maintenance","title":"Data Cleanup and Maintenance","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n  const staticData = this.getWorkflowStaticData('global')\n\n  // Initialize cleanup settings\n  if (!staticData.cleanup) {\n    staticData.cleanup = {\n      lastCleanup: 0,\n      cleanupInterval: 24 * 60 * 60 * 1000, // 24 hours\n      maxCacheAge: 7 * 24 * 60 * 60 * 1000, // 7 days\n      maxHistoryEntries: 1000\n    }\n  }\n\n  const now = Date.now()\n  const cleanup = staticData.cleanup\n\n  // Perform cleanup if needed\n  if ((now - cleanup.lastCleanup) &gt; cleanup.cleanupInterval) {\n    // Clean old cache entries\n    if (staticData.cache) {\n      Object.keys(staticData.cache).forEach(key =&gt; {\n        const entry = staticData.cache[key]\n        if (entry.timestamp &amp;&amp; (now - entry.timestamp) &gt; cleanup.maxCacheAge) {\n          delete staticData.cache[key]\n        }\n      })\n    }\n\n    // Clean old history entries\n    if (staticData.executionHistory?.executions) {\n      const maxEntries = cleanup.maxHistoryEntries\n      if (staticData.executionHistory.executions.length &gt; maxEntries) {\n        staticData.executionHistory.executions = \n          staticData.executionHistory.executions.slice(-maxEntries)\n      }\n    }\n\n    // Update cleanup timestamp\n    cleanup.lastCleanup = now\n  }\n\n  return [items]\n}\n</code></pre>"},{"location":"public-api/workflow/getWorkflowStaticData/#conditional-data-initialization","title":"Conditional Data Initialization","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n  const staticData = this.getWorkflowStaticData('global')\n\n  // Initialize data based on workflow configuration\n  const workflowName = this.getWorkflow().name\n  const isProduction = workflowName?.includes('Production')\n\n  if (!staticData.environment) {\n    staticData.environment = {\n      type: isProduction ? 'production' : 'development',\n      settings: isProduction ? {\n        logLevel: 'error',\n        cacheEnabled: true,\n        metricsEnabled: true,\n        debugMode: false\n      } : {\n        logLevel: 'debug',\n        cacheEnabled: false,\n        metricsEnabled: false,\n        debugMode: true\n      },\n      initialized: new Date().toISOString()\n    }\n  }\n\n  const environment = staticData.environment\n\n  // Use environment-specific processing\n  const results = []\n\n  for (const item of items) {\n    let processedItem = { ...item.json }\n\n    if (environment.settings.debugMode) {\n      processedItem._debug = {\n        environment: environment.type,\n        timestamp: new Date().toISOString(),\n        nodeId: this.getNode().id\n      }\n    }\n\n    results.push({ json: processedItem })\n  }\n\n  return [results]\n}\n</code></pre>"},{"location":"public-api/workflow/getWorkflowStaticData/#performance-considerations","title":"Performance Considerations","text":""},{"location":"public-api/workflow/getWorkflowStaticData/#memory-management","title":"Memory Management","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n  const staticData = this.getWorkflowStaticData('global')\n\n  // Monitor static data size\n  const getDataSize = (obj: any): number =&gt; {\n    return JSON.stringify(obj).length\n  }\n\n  const currentSize = getDataSize(staticData)\n  const maxSize = 10 * 1024 * 1024 // 10MB limit\n\n  if (currentSize &gt; maxSize) {\n    // Implement data reduction strategy\n    if (staticData.cache) {\n      // Remove oldest cache entries\n      const cacheEntries = Object.entries(staticData.cache)\n        .map(([key, value]: [string, any]) =&gt; ({ key, ...value }))\n        .sort((a, b) =&gt; a.timestamp - b.timestamp)\n\n      // Remove oldest 25% of entries\n      const toRemove = Math.floor(cacheEntries.length * 0.25)\n      for (let i = 0; i &lt; toRemove; i++) {\n        delete staticData.cache[cacheEntries[i].key]\n      }\n    }\n  }\n\n  return [items]\n}\n</code></pre>"},{"location":"public-api/workflow/getWorkflowStaticData/#efficient-data-access","title":"Efficient Data Access","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n  const staticData = this.getWorkflowStaticData('global')\n\n  // Use lazy initialization for expensive data structures\n  const getOrCreateIndex = () =&gt; {\n    if (!staticData._searchIndex) {\n      staticData._searchIndex = new Map()\n      staticData._indexLastBuilt = Date.now()\n    }\n    return staticData._searchIndex\n  }\n\n  // Rebuild index if stale\n  const indexAge = Date.now() - (staticData._indexLastBuilt || 0)\n  const maxIndexAge = 60 * 60 * 1000 // 1 hour\n\n  if (indexAge &gt; maxIndexAge) {\n    delete staticData._searchIndex\n    staticData._indexLastBuilt = Date.now()\n  }\n\n  const searchIndex = getOrCreateIndex()\n\n  return [items]\n}\n</code></pre>"},{"location":"public-api/workflow/getWorkflowStaticData/#best-practices","title":"Best Practices","text":"<ol> <li>Use appropriate namespaces to avoid data conflicts</li> <li>Implement data cleanup to prevent memory bloat</li> <li>Monitor data size and implement size limits</li> <li>Use lazy initialization for expensive data structures</li> <li>Handle concurrent access carefully in multi-execution scenarios</li> <li>Document data structure and lifecycle</li> <li>Consider data migration when changing data formats</li> </ol>"},{"location":"public-api/workflow/getWorkflowStaticData/#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"public-api/workflow/getWorkflowStaticData/#avoiding-data-corruption","title":"Avoiding Data Corruption","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n  const staticData = this.getWorkflowStaticData('global')\n\n  // Use atomic updates for critical data\n  const updateCounter = (key: string, increment: number = 1) =&gt; {\n    if (!staticData.counters) {\n      staticData.counters = {}\n    }\n\n    const current = staticData.counters[key] || 0\n    staticData.counters[key] = current + increment\n\n    return staticData.counters[key]\n  }\n\n  // Avoid direct mutation of complex objects\n  const updateConfig = (updates: any) =&gt; {\n    staticData.config = {\n      ...staticData.config,\n      ...updates,\n      lastUpdated: new Date().toISOString()\n    }\n  }\n\n  return [items]\n}\n</code></pre>"},{"location":"public-api/workflow/getWorkflowStaticData/#related-documentation","title":"Related Documentation","text":"<ul> <li>getWorkflow - For accessing workflow information</li> <li>executeWorkflow - For executing sub-workflows</li> <li>IExecuteFunctions - Main execution context</li> <li>Base Helpers - Core helper functions</li> </ul>"},{"location":"public-api/workflow/putExecutionToWait/","title":"putExecutionToWait","text":"<p>The <code>putExecutionToWait</code> function allows you to pause the current workflow execution and resume it later when specific conditions are met or external events occur. This is essential for implementing long-running processes, waiting for external approvals, or creating event-driven workflows.</p>"},{"location":"public-api/workflow/putExecutionToWait/#when-to-use","title":"When to Use","text":"<p>Use <code>putExecutionToWait</code> when your node needs to: - Wait for external approvals or manual interventions - Implement long-running processes that span hours, days, or weeks - Create event-driven workflows that respond to external triggers - Pause execution until specific conditions are met - Implement timeout-based workflows - Create workflows that wait for webhook callbacks - Handle asynchronous operations with unknown completion times</p>"},{"location":"public-api/workflow/putExecutionToWait/#function-signature","title":"Function Signature","text":"<pre><code>putExecutionToWait(waitTill: Date): Promise&lt;void&gt;\n</code></pre>"},{"location":"public-api/workflow/putExecutionToWait/#parameters","title":"Parameters","text":"<ul> <li>waitTill: The date/time when the execution should automatically resume (can be far in the future for manual resume)</li> </ul>"},{"location":"public-api/workflow/putExecutionToWait/#return-value","title":"Return Value","text":"<p>Returns a Promise that resolves when the execution is successfully put into wait state.</p>"},{"location":"public-api/workflow/putExecutionToWait/#basic-usage","title":"Basic Usage","text":""},{"location":"public-api/workflow/putExecutionToWait/#simple-wait-with-timeout","title":"Simple Wait with Timeout","text":"<pre><code>import { IExecuteFunctions } from 'n8n-workflow'\n\nexport async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n  const waitMinutes = this.getNodeParameter('waitMinutes', 0, 60) as number\n\n  // Calculate wait time\n  const waitUntil = new Date()\n  waitUntil.setMinutes(waitUntil.getMinutes() + waitMinutes)\n\n  // Store data for when execution resumes\n  const staticData = this.getWorkflowStaticData('global')\n  staticData.waitingData = {\n    originalItems: items,\n    waitStarted: new Date().toISOString(),\n    waitUntil: waitUntil.toISOString(),\n    reason: 'timeout_wait'\n  }\n\n  // Put execution to wait\n  await this.putExecutionToWait(waitUntil)\n\n  // This code runs when execution resumes\n  const resumedData = staticData.waitingData\n  delete staticData.waitingData\n\n  const results = []\n\n  for (const item of resumedData.originalItems) {\n    results.push({\n      json: {\n        ...item.json,\n        waitInfo: {\n          waitStarted: resumedData.waitStarted,\n          waitUntil: resumedData.waitUntil,\n          resumedAt: new Date().toISOString(),\n          waitDuration: Date.now() - new Date(resumedData.waitStarted).getTime()\n        }\n      }\n    })\n  }\n\n  return [results]\n}\n</code></pre>"},{"location":"public-api/workflow/putExecutionToWait/#wait-for-external-approval","title":"Wait for External Approval","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n  const approvalTimeoutHours = this.getNodeParameter('approvalTimeoutHours', 0, 24) as number\n\n  // Set timeout for approval (24 hours default)\n  const timeoutDate = new Date()\n  timeoutDate.setHours(timeoutDate.getHours() + approvalTimeoutHours)\n\n  // Store approval request data\n  const staticData = this.getWorkflowStaticData('global')\n  const approvalId = `approval_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`\n\n  staticData.pendingApprovals = staticData.pendingApprovals || {}\n  staticData.pendingApprovals[approvalId] = {\n    items,\n    requestedAt: new Date().toISOString(),\n    timeoutAt: timeoutDate.toISOString(),\n    status: 'pending',\n    approver: null,\n    approvedAt: null\n  }\n\n  // Send approval notification (this would typically trigger a webhook or email)\n  await this.helpers.httpRequest({\n    method: 'POST',\n    url: 'https://your-approval-system.com/api/approvals',\n    body: {\n      approvalId,\n      items: items.map(item =&gt; item.json),\n      timeoutAt: timeoutDate.toISOString(),\n      resumeWebhook: `https://your-n8n-instance.com/webhook/approval/${approvalId}`\n    }\n  })\n\n  // Put execution to wait\n  await this.putExecutionToWait(timeoutDate)\n\n  // This code runs when execution resumes (either approved or timed out)\n  const approvalData = staticData.pendingApprovals[approvalId]\n  delete staticData.pendingApprovals[approvalId]\n\n  const results = []\n\n  if (approvalData.status === 'approved') {\n    // Process approved items\n    for (const item of approvalData.items) {\n      results.push({\n        json: {\n          ...item.json,\n          approvalInfo: {\n            approvalId,\n            status: 'approved',\n            approver: approvalData.approver,\n            approvedAt: approvalData.approvedAt,\n            requestedAt: approvalData.requestedAt\n          }\n        }\n      })\n    }\n  } else {\n    // Handle timeout or rejection\n    for (const item of approvalData.items) {\n      results.push({\n        json: {\n          ...item.json,\n          approvalInfo: {\n            approvalId,\n            status: approvalData.status || 'timeout',\n            requestedAt: approvalData.requestedAt,\n            timeoutAt: approvalData.timeoutAt,\n            error: 'Approval not received within timeout period'\n          }\n        }\n      })\n    }\n  }\n\n  return [results]\n}\n</code></pre>"},{"location":"public-api/workflow/putExecutionToWait/#advanced-usage","title":"Advanced Usage","text":""},{"location":"public-api/workflow/putExecutionToWait/#multi-stage-approval-process","title":"Multi-Stage Approval Process","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n  const staticData = this.getWorkflowStaticData('global')\n\n  // Initialize or get current approval stage\n  if (!staticData.approvalProcess) {\n    staticData.approvalProcess = {\n      stage: 1,\n      maxStages: 3,\n      approvals: [],\n      items,\n      startedAt: new Date().toISOString()\n    }\n  }\n\n  const process = staticData.approvalProcess\n  const currentStage = process.stage\n\n  // Define approval stages\n  const approvalStages = [\n    { name: 'Manager Approval', timeoutHours: 24, required: true },\n    { name: 'Finance Approval', timeoutHours: 48, required: true },\n    { name: 'Executive Approval', timeoutHours: 72, required: false }\n  ]\n\n  if (currentStage &lt;= approvalStages.length) {\n    const stage = approvalStages[currentStage - 1]\n    const timeoutDate = new Date()\n    timeoutDate.setHours(timeoutDate.getHours() + stage.timeoutHours)\n\n    // Request approval for current stage\n    const approvalId = `stage_${currentStage}_${Date.now()}`\n\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: 'https://approval-system.com/api/stage-approval',\n      body: {\n        approvalId,\n        stage: currentStage,\n        stageName: stage.name,\n        items: process.items.map(item =&gt; item.json),\n        timeoutAt: timeoutDate.toISOString(),\n        previousApprovals: process.approvals\n      }\n    })\n\n    // Wait for this stage\n    await this.putExecutionToWait(timeoutDate)\n\n    // Check if approval was received (this would be set by webhook)\n    const stageApproval = staticData.currentStageApproval\n    delete staticData.currentStageApproval\n\n    if (stageApproval?.approved) {\n      // Add approval to process\n      process.approvals.push({\n        stage: currentStage,\n        stageName: stage.name,\n        approver: stageApproval.approver,\n        approvedAt: stageApproval.approvedAt,\n        comments: stageApproval.comments\n      })\n\n      // Move to next stage\n      process.stage++\n\n      // If more stages, continue the process\n      if (process.stage &lt;= approvalStages.length) {\n        return this.execute() // Recursive call for next stage\n      }\n    } else {\n      // Stage was rejected or timed out\n      process.status = 'rejected'\n      process.rejectedAt = new Date().toISOString()\n      process.rejectionReason = stageApproval?.reason || 'Timeout'\n    }\n  }\n\n  // All stages complete or process rejected\n  const results = []\n  const finalStatus = process.status || 'approved'\n\n  for (const item of process.items) {\n    results.push({\n      json: {\n        ...item.json,\n        approvalProcess: {\n          status: finalStatus,\n          stages: process.approvals,\n          startedAt: process.startedAt,\n          completedAt: new Date().toISOString(),\n          totalStages: process.approvals.length\n        }\n      }\n    })\n  }\n\n  // Clean up\n  delete staticData.approvalProcess\n\n  return [results]\n}\n</code></pre>"},{"location":"public-api/workflow/putExecutionToWait/#event-driven-wait-with-multiple-triggers","title":"Event-Driven Wait with Multiple Triggers","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n  const staticData = this.getWorkflowStaticData('global')\n\n  // Initialize wait state\n  if (!staticData.eventWait) {\n    const waitId = `wait_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`\n    const maxWaitHours = this.getNodeParameter('maxWaitHours', 0, 168) as number // 1 week default\n\n    const timeoutDate = new Date()\n    timeoutDate.setHours(timeoutDate.getHours() + maxWaitHours)\n\n    staticData.eventWait = {\n      waitId,\n      items,\n      startedAt: new Date().toISOString(),\n      timeoutAt: timeoutDate.toISOString(),\n      expectedEvents: [\n        'payment_received',\n        'document_signed',\n        'approval_granted'\n      ],\n      receivedEvents: [],\n      status: 'waiting'\n    }\n\n    // Register for events (webhook endpoints)\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: 'https://event-system.com/api/register-wait',\n      body: {\n        waitId,\n        events: staticData.eventWait.expectedEvents,\n        webhookUrl: `https://your-n8n-instance.com/webhook/event/${waitId}`,\n        timeoutAt: timeoutDate.toISOString()\n      }\n    })\n\n    // Put execution to wait\n    await this.putExecutionToWait(timeoutDate)\n  }\n\n  // Execution resumed - check what triggered it\n  const waitData = staticData.eventWait\n  const triggerEvent = staticData.triggerEvent // Set by webhook\n  delete staticData.triggerEvent\n\n  if (triggerEvent) {\n    // Event received\n    waitData.receivedEvents.push({\n      event: triggerEvent.type,\n      data: triggerEvent.data,\n      receivedAt: new Date().toISOString()\n    })\n\n    // Check if all required events received\n    const allEventsReceived = waitData.expectedEvents.every(expectedEvent =&gt;\n      waitData.receivedEvents.some(received =&gt; received.event === expectedEvent)\n    )\n\n    if (allEventsReceived) {\n      waitData.status = 'completed'\n    } else {\n      // Still waiting for more events, continue waiting\n      const remainingTime = new Date(waitData.timeoutAt).getTime() - Date.now()\n      if (remainingTime &gt; 0) {\n        const newTimeoutDate = new Date(waitData.timeoutAt)\n        await this.putExecutionToWait(newTimeoutDate)\n        return // Will resume when next event arrives or timeout\n      } else {\n        waitData.status = 'timeout'\n      }\n    }\n  } else {\n    // Timeout occurred\n    waitData.status = 'timeout'\n  }\n\n  // Process final results\n  const results = []\n\n  for (const item of waitData.items) {\n    results.push({\n      json: {\n        ...item.json,\n        eventWaitResult: {\n          waitId: waitData.waitId,\n          status: waitData.status,\n          startedAt: waitData.startedAt,\n          completedAt: new Date().toISOString(),\n          expectedEvents: waitData.expectedEvents,\n          receivedEvents: waitData.receivedEvents,\n          allEventsReceived: waitData.status === 'completed'\n        }\n      }\n    })\n  }\n\n  // Cleanup\n  delete staticData.eventWait\n\n  return [results]\n}\n</code></pre>"},{"location":"public-api/workflow/putExecutionToWait/#conditional-wait-with-dynamic-conditions","title":"Conditional Wait with Dynamic Conditions","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n  const staticData = this.getWorkflowStaticData('global')\n\n  // Check if we're resuming from a wait\n  const isResuming = staticData.conditionalWait !== undefined\n\n  if (!isResuming) {\n    // Initial execution - set up conditional wait\n    const condition = this.getNodeParameter('waitCondition', 0) as string\n    const checkIntervalMinutes = this.getNodeParameter('checkIntervalMinutes', 0, 15) as number\n    const maxWaitHours = this.getNodeParameter('maxWaitHours', 0, 24) as number\n\n    staticData.conditionalWait = {\n      items,\n      condition,\n      checkIntervalMinutes,\n      startedAt: new Date().toISOString(),\n      maxWaitUntil: new Date(Date.now() + maxWaitHours * 60 * 60 * 1000).toISOString(),\n      checkCount: 0,\n      lastChecked: null\n    }\n  }\n\n  const waitData = staticData.conditionalWait\n  waitData.checkCount++\n  waitData.lastChecked = new Date().toISOString()\n\n  // Check the condition\n  const conditionMet = await this.checkCondition(waitData.condition, items)\n\n  if (conditionMet) {\n    // Condition met, proceed with execution\n    const results = []\n\n    for (const item of waitData.items) {\n      results.push({\n        json: {\n          ...item.json,\n          conditionalWaitResult: {\n            conditionMet: true,\n            condition: waitData.condition,\n            startedAt: waitData.startedAt,\n            completedAt: new Date().toISOString(),\n            checkCount: waitData.checkCount,\n            waitDuration: Date.now() - new Date(waitData.startedAt).getTime()\n          }\n        }\n      })\n    }\n\n    delete staticData.conditionalWait\n    return [results]\n  }\n\n  // Check if we've exceeded max wait time\n  const now = new Date()\n  const maxWaitTime = new Date(waitData.maxWaitUntil)\n\n  if (now &gt;= maxWaitTime) {\n    // Timeout reached\n    const results = []\n\n    for (const item of waitData.items) {\n      results.push({\n        json: {\n          ...item.json,\n          conditionalWaitResult: {\n            conditionMet: false,\n            condition: waitData.condition,\n            startedAt: waitData.startedAt,\n            timedOutAt: new Date().toISOString(),\n            checkCount: waitData.checkCount,\n            error: 'Condition not met within timeout period'\n          }\n        }\n      })\n    }\n\n    delete staticData.conditionalWait\n    return [results]\n  }\n\n  // Continue waiting - schedule next check\n  const nextCheckTime = new Date()\n  nextCheckTime.setMinutes(nextCheckTime.getMinutes() + waitData.checkIntervalMinutes)\n\n  await this.putExecutionToWait(nextCheckTime)\n\n  // This return won't be reached as execution is paused\n  return []\n}\n\n// Helper method to check conditions\nprivate async checkCondition(condition: string, items: any[]): Promise&lt;boolean&gt; {\n  switch (condition) {\n    case 'api_status_ready':\n      try {\n        const response = await this.helpers.httpRequest({\n          method: 'GET',\n          url: 'https://api.example.com/status'\n        })\n        return response.status === 'ready'\n      } catch {\n        return false\n      }\n\n    case 'file_exists':\n      try {\n        const filePath = items[0]?.json?.filePath\n        if (!filePath) return false\n\n        const response = await this.helpers.httpRequest({\n          method: 'HEAD',\n          url: filePath\n        })\n        return response.statusCode === 200\n      } catch {\n        return false\n      }\n\n    case 'database_record_updated':\n      try {\n        const recordId = items[0]?.json?.recordId\n        const response = await this.helpers.httpRequest({\n          method: 'GET',\n          url: `https://api.example.com/records/${recordId}`\n        })\n        return response.lastModified &gt; items[0]?.json?.lastKnownModified\n      } catch {\n        return false\n      }\n\n    default:\n      return false\n  }\n}\n</code></pre>"},{"location":"public-api/workflow/putExecutionToWait/#wait-state-management","title":"Wait State Management","text":""},{"location":"public-api/workflow/putExecutionToWait/#resuming-executions-programmatically","title":"Resuming Executions Programmatically","text":"<pre><code>// This would typically be in a webhook or trigger node\nexport async function resumeExecution(executionId: string, data?: any) {\n  const staticData = this.getWorkflowStaticData('global')\n\n  // Store resume data\n  if (data) {\n    staticData.resumeData = data\n  }\n\n  // Resume the execution (this would be done through n8n's API)\n  await this.helpers.httpRequest({\n    method: 'POST',\n    url: `https://your-n8n-instance.com/api/v1/executions/${executionId}/resume`,\n    headers: {\n      'Authorization': 'Bearer YOUR_API_TOKEN'\n    },\n    body: {\n      data\n    }\n  })\n}\n</code></pre>"},{"location":"public-api/workflow/putExecutionToWait/#wait-state-monitoring","title":"Wait State Monitoring","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n  const staticData = this.getWorkflowStaticData('global')\n\n  // Initialize monitoring\n  if (!staticData.waitMonitoring) {\n    staticData.waitMonitoring = {\n      activeWaits: [],\n      completedWaits: [],\n      statistics: {\n        totalWaits: 0,\n        averageWaitTime: 0,\n        timeoutRate: 0\n      }\n    }\n  }\n\n  const monitoring = staticData.waitMonitoring\n  const waitId = `wait_${Date.now()}`\n\n  // Record wait start\n  const waitRecord = {\n    waitId,\n    startedAt: new Date().toISOString(),\n    items: items.length,\n    reason: this.getNodeParameter('waitReason', 0, 'general') as string,\n    status: 'active'\n  }\n\n  monitoring.activeWaits.push(waitRecord)\n  monitoring.statistics.totalWaits++\n\n  // Set up wait\n  const waitMinutes = this.getNodeParameter('waitMinutes', 0, 30) as number\n  const waitUntil = new Date()\n  waitUntil.setMinutes(waitUntil.getMinutes() + waitMinutes)\n\n  await this.putExecutionToWait(waitUntil)\n\n  // Execution resumed - update monitoring\n  const waitIndex = monitoring.activeWaits.findIndex(w =&gt; w.waitId === waitId)\n  if (waitIndex &gt;= 0) {\n    const completedWait = monitoring.activeWaits[waitIndex]\n    completedWait.completedAt = new Date().toISOString()\n    completedWait.duration = Date.now() - new Date(completedWait.startedAt).getTime()\n    completedWait.status = 'completed'\n\n    // Move to completed\n    monitoring.activeWaits.splice(waitIndex, 1)\n    monitoring.completedWaits.push(completedWait)\n\n    // Update statistics\n    const completedWaits = monitoring.completedWaits\n    const totalDuration = completedWaits.reduce((sum, wait) =&gt; sum + (wait.duration || 0), 0)\n    monitoring.statistics.averageWaitTime = totalDuration / completedWaits.length\n  }\n\n  return [items]\n}\n</code></pre>"},{"location":"public-api/workflow/putExecutionToWait/#best-practices","title":"Best Practices","text":"<ol> <li>Always store necessary data in static data before waiting</li> <li>Set reasonable timeouts to prevent indefinite waits</li> <li>Handle resume scenarios gracefully with proper state checks</li> <li>Implement cleanup logic for expired or cancelled waits</li> <li>Use unique identifiers for tracking multiple concurrent waits</li> <li>Monitor wait states and implement alerting for stuck executions</li> <li>Test resume scenarios thoroughly in development</li> <li>Document wait conditions clearly for maintenance</li> </ol>"},{"location":"public-api/workflow/putExecutionToWait/#common-patterns","title":"Common Patterns","text":""},{"location":"public-api/workflow/putExecutionToWait/#polling-with-backoff","title":"Polling with Backoff","text":"<pre><code>export async function execute(this: IExecuteFunctions) {\n  const items = this.getInputData()\n  const staticData = this.getWorkflowStaticData('global')\n\n  if (!staticData.pollingState) {\n    staticData.pollingState = {\n      attempt: 0,\n      maxAttempts: 10,\n      baseDelayMinutes: 1,\n      backoffMultiplier: 2,\n      startedAt: new Date().toISOString()\n    }\n  }\n\n  const state = staticData.pollingState\n  state.attempt++\n\n  // Check condition\n  const success = await this.checkExternalCondition()\n\n  if (success || state.attempt &gt;= state.maxAttempts) {\n    // Success or max attempts reached\n    delete staticData.pollingState\n    return [items]\n  }\n\n  // Calculate next delay with exponential backoff\n  const delayMinutes = state.baseDelayMinutes * Math.pow(state.backoffMultiplier, state.attempt - 1)\n  const nextCheck = new Date()\n  nextCheck.setMinutes(nextCheck.getMinutes() + delayMinutes)\n\n  await this.putExecutionToWait(nextCheck)\n  return []\n}\n</code></pre>"},{"location":"public-api/workflow/putExecutionToWait/#related-documentation","title":"Related Documentation","text":"<ul> <li>getWorkflow - For accessing workflow information</li> <li>getWorkflowStaticData - For persistent data storage</li> <li>executeWorkflow - For sub-workflow execution</li> <li>IExecuteFunctions - Main execution context</li> <li>ITriggerFunctions - For trigger-based resumes</li> <li>IWebhookFunctions - For webhook-based resumes</li> </ul>"},{"location":"real-world/AirtopNode/","title":"Airtop Node","text":"<p>This node integrates with Airtop, a fictional or internal API, to demonstrate advanced node patterns.</p>"},{"location":"real-world/AirtopNode/#key-features","title":"Key Features","text":"<ul> <li>Uses custom authentication</li> <li>Supports multiple operations (list, create, update)</li> <li>Handles pagination and error recovery</li> </ul>"},{"location":"real-world/AirtopNode/#implementation-highlights","title":"Implementation Highlights","text":"<ul> <li>Uses <code>authenticate()</code> to inject token</li> <li>Implements <code>loadOptions</code> for dynamic dropdowns</li> <li>Uses <code>continueOnFail</code> to handle partial failures</li> </ul>"},{"location":"real-world/AirtopNode/#use-cases","title":"Use Cases","text":"<ul> <li>Internal business tools</li> <li>Custom CRM or ERP integrations</li> <li>Teaching advanced node design</li> </ul>"},{"location":"real-world/AirtopNode/#teaching-value","title":"Teaching Value","text":"<ul> <li>Combines multiple advanced patterns</li> <li>Demonstrates robust error handling</li> <li>Great for showcasing real-world complexity</li> </ul> <p>[TODO: inline code]</p>"},{"location":"real-world/ApifyNode/","title":"Apify Node","text":"<p>This node integrates with the Apify platform to run actors and retrieve datasets.</p>"},{"location":"real-world/ApifyNode/#key-features","title":"Key Features","text":"<ul> <li>Uses API token for authentication</li> <li>Can trigger actors and wait for completion</li> <li>Fetches dataset items from actor runs</li> </ul>"},{"location":"real-world/ApifyNode/#implementation-highlights","title":"Implementation Highlights","text":"<ul> <li>Uses <code>httpRequest</code> with <code>Authorization: Bearer</code> header</li> <li>Polls actor run status until finished</li> <li>Streams dataset items into workflow</li> </ul>"},{"location":"real-world/ApifyNode/#use-cases","title":"Use Cases","text":"<ul> <li>Web scraping pipelines</li> <li>Data enrichment workflows</li> <li>Scheduled data collection</li> </ul>"},{"location":"real-world/ApifyNode/#teaching-value","title":"Teaching Value","text":"<ul> <li>Demonstrates polling pattern for async jobs</li> <li>Shows how to chain multiple API calls</li> <li>Good example of a multi-step integration</li> </ul>"},{"location":"real-world/ApifyNode/#complete-apify-actor-runner-implementation","title":"Complete Apify Actor Runner Implementation","text":"<p>Here's a full Apify node that runs actors and polls for completion:</p> <pre><code>import {\n  IExecuteFunctions,\n  INodeExecutionData,\n  INodeType,\n  INodeTypeDescription,\n  NodeApiError,\n  NodeOperationError,\n} from 'n8n-workflow';\n\nexport class ApifyNode implements INodeType {\n  description: INodeTypeDescription = {\n    displayName: 'Apify',\n    name: 'apify',\n    icon: 'file:apify.svg',\n    group: ['transform'],\n    version: 1,\n    description: 'Run Apify actors and retrieve datasets',\n    defaults: {\n      name: 'Apify',\n    },\n    inputs: ['main'],\n    outputs: ['main'],\n    credentials: [\n      {\n        name: 'apifyApi',\n        required: true,\n      },\n    ],\n    properties: [\n      {\n        displayName: 'Operation',\n        name: 'operation',\n        type: 'options',\n        noDataExpression: true,\n        options: [\n          {\n            name: 'Run Actor',\n            value: 'runActor',\n            description: 'Start an actor and wait for completion',\n            action: 'Run an actor',\n          },\n          {\n            name: 'Get Dataset Items',\n            value: 'getDatasetItems',\n            description: 'Retrieve items from a dataset',\n            action: 'Get dataset items',\n          },\n          {\n            name: 'Get Actor Run',\n            value: 'getActorRun',\n            description: 'Get information about an actor run',\n            action: 'Get actor run details',\n          },\n        ],\n        default: 'runActor',\n      },\n      {\n        displayName: 'Actor ID',\n        name: 'actorId',\n        type: 'string',\n        default: '',\n        required: true,\n        displayOptions: {\n          show: {\n            operation: ['runActor'],\n          },\n        },\n        description: 'ID or name of the actor to run',\n        placeholder: 'apify/web-scraper',\n      },\n      {\n        displayName: 'Actor Input',\n        name: 'actorInput',\n        type: 'json',\n        default: '{}',\n        displayOptions: {\n          show: {\n            operation: ['runActor'],\n          },\n        },\n        description: 'Input configuration for the actor (JSON)',\n        placeholder: '{\"startUrls\": [{\"url\": \"https://example.com\"}]}',\n      },\n      {\n        displayName: 'Wait for Completion',\n        name: 'waitForCompletion',\n        type: 'boolean',\n        default: true,\n        displayOptions: {\n          show: {\n            operation: ['runActor'],\n          },\n        },\n        description: 'Whether to wait for the actor run to complete',\n      },\n      {\n        displayName: 'Timeout (minutes)',\n        name: 'timeout',\n        type: 'number',\n        default: 10,\n        displayOptions: {\n          show: {\n            operation: ['runActor'],\n            waitForCompletion: [true],\n          },\n        },\n        description: 'Maximum time to wait for actor completion',\n      },\n      {\n        displayName: 'Dataset ID',\n        name: 'datasetId',\n        type: 'string',\n        default: '',\n        required: true,\n        displayOptions: {\n          show: {\n            operation: ['getDatasetItems'],\n          },\n        },\n        description: 'ID of the dataset to retrieve items from',\n      },\n      {\n        displayName: 'Run ID',\n        name: 'runId',\n        type: 'string',\n        default: '',\n        required: true,\n        displayOptions: {\n          show: {\n            operation: ['getActorRun'],\n          },\n        },\n        description: 'ID of the actor run to retrieve',\n      },\n      {\n        displayName: 'Additional Options',\n        name: 'additionalOptions',\n        type: 'collection',\n        placeholder: 'Add Option',\n        default: {},\n        options: [\n          {\n            displayName: 'Memory (MB)',\n            name: 'memory',\n            type: 'number',\n            default: 1024,\n            description: 'Amount of memory allocated for the actor run',\n          },\n          {\n            displayName: 'Build',\n            name: 'build',\n            type: 'string',\n            default: 'latest',\n            description: 'Tag or number of the actor build to run',\n          },\n          {\n            displayName: 'Max Items',\n            name: 'maxItems',\n            type: 'number',\n            default: 1000,\n            description: 'Maximum number of dataset items to retrieve',\n          },\n          {\n            displayName: 'Clean Items',\n            name: 'clean',\n            type: 'boolean',\n            default: true,\n            description: 'Whether to omit empty items and unify output format',\n          },\n        ],\n      },\n    ],\n  };\n\n  async execute(this: IExecuteFunctions): Promise&lt;INodeExecutionData[][]&gt; {\n    const items = this.getInputData();\n    const returnData: INodeExecutionData[] = [];\n    const operation = this.getNodeParameter('operation', 0) as string;\n\n    const credentials = await this.getCredentials('apifyApi');\n    const apiToken = credentials.apiToken as string;\n    const baseUrl = 'https://api.apify.com/v2';\n\n    const headers = {\n      'Authorization': `Bearer ${apiToken}`,\n      'Content-Type': 'application/json',\n    };\n\n    try {\n      if (operation === 'runActor') {\n        const actorId = this.getNodeParameter('actorId', 0) as string;\n        const actorInput = this.getNodeParameter('actorInput', 0) as string;\n        const waitForCompletion = this.getNodeParameter('waitForCompletion', 0) as boolean;\n        const timeout = this.getNodeParameter('timeout', 0) as number;\n        const additionalOptions = this.getNodeParameter('additionalOptions', 0, {}) as any;\n\n        let parsedInput: any = {};\n        try {\n          parsedInput = JSON.parse(actorInput);\n        } catch (error) {\n          throw new NodeOperationError(\n            this.getNode(),\n            `Invalid JSON in Actor Input: ${error.message}`\n          );\n        }\n\n        // Start the actor run\n        const runPayload: any = {\n          ...parsedInput,\n        };\n\n        if (additionalOptions.memory) {\n          runPayload.memory = additionalOptions.memory;\n        }\n        if (additionalOptions.build) {\n          runPayload.build = additionalOptions.build;\n        }\n\n        const runResponse = await this.helpers.request({\n          method: 'POST',\n          url: `${baseUrl}/acts/${actorId}/runs`,\n          headers,\n          body: runPayload,\n          json: true,\n        });\n\n        const runId = runResponse.data.id;\n\n        returnData.push({\n          json: {\n            runId,\n            status: runResponse.data.status,\n            startedAt: runResponse.data.startedAt,\n            actorId,\n            message: 'Actor run started',\n          },\n        });\n\n        if (waitForCompletion) {\n          // Poll for completion\n          const startTime = Date.now();\n          const timeoutMs = timeout * 60 * 1000;\n          let completed = false;\n          let finalStatus = '';\n\n          while (!completed &amp;&amp; (Date.now() - startTime) &lt; timeoutMs) {\n            await new Promise(resolve =&gt; setTimeout(resolve, 5000)); // Wait 5 seconds\n\n            const statusResponse = await this.helpers.request({\n              method: 'GET',\n              url: `${baseUrl}/actor-runs/${runId}`,\n              headers,\n              json: true,\n            });\n\n            const status = statusResponse.data.status;\n            finalStatus = status;\n\n            if (status === 'SUCCEEDED' || status === 'FAILED' || status === 'ABORTED' || status === 'TIMED-OUT') {\n              completed = true;\n            }\n          }\n\n          if (!completed) {\n            throw new NodeOperationError(\n              this.getNode(),\n              `Actor run timed out after ${timeout} minutes`\n            );\n          }\n\n          if (finalStatus === 'FAILED') {\n            throw new NodeOperationError(\n              this.getNode(),\n              'Actor run failed'\n            );\n          }\n\n          // Get final run details\n          const finalRunResponse = await this.helpers.request({\n            method: 'GET',\n            url: `${baseUrl}/actor-runs/${runId}`,\n            headers,\n            json: true,\n          });\n\n          const runData = finalRunResponse.data;\n\n          returnData.push({\n            json: {\n              runId,\n              status: runData.status,\n              startedAt: runData.startedAt,\n              finishedAt: runData.finishedAt,\n              stats: runData.stats,\n              defaultDatasetId: runData.defaultDatasetId,\n              defaultKeyValueStoreId: runData.defaultKeyValueStoreId,\n              message: 'Actor run completed',\n            },\n          });\n\n          // Automatically fetch dataset items if available\n          if (runData.defaultDatasetId) {\n            const datasetItems = await this.fetchDatasetItems(\n              runData.defaultDatasetId,\n              additionalOptions.maxItems || 1000,\n              additionalOptions.clean !== false,\n              headers\n            );\n\n            for (const item of datasetItems) {\n              returnData.push({\n                json: item,\n              });\n            }\n          }\n        }\n\n      } else if (operation === 'getDatasetItems') {\n        const datasetId = this.getNodeParameter('datasetId', 0) as string;\n        const additionalOptions = this.getNodeParameter('additionalOptions', 0, {}) as any;\n\n        const datasetItems = await this.fetchDatasetItems(\n          datasetId,\n          additionalOptions.maxItems || 1000,\n          additionalOptions.clean !== false,\n          headers\n        );\n\n        for (const item of datasetItems) {\n          returnData.push({\n            json: item,\n          });\n        }\n\n      } else if (operation === 'getActorRun') {\n        const runId = this.getNodeParameter('runId', 0) as string;\n\n        const runResponse = await this.helpers.request({\n          method: 'GET',\n          url: `${baseUrl}/actor-runs/${runId}`,\n          headers,\n          json: true,\n        });\n\n        returnData.push({\n          json: runResponse.data,\n        });\n      }\n\n    } catch (error) {\n      throw new NodeApiError(this.getNode(), error, {\n        message: `Apify operation failed: ${error.message}`,\n        description: error.description || 'Check your API token and parameters',\n      });\n    }\n\n    return [returnData];\n  }\n\n  // Helper method to fetch dataset items\n  private async fetchDatasetItems(\n    datasetId: string,\n    maxItems: number,\n    clean: boolean,\n    headers: any\n  ): Promise&lt;any[]&gt; {\n    const baseUrl = 'https://api.apify.com/v2';\n    const items: any[] = [];\n    let offset = 0;\n    const limit = Math.min(1000, maxItems); // API limit is 1000 per request\n\n    while (items.length &lt; maxItems) {\n      const queryParams = new URLSearchParams({\n        offset: offset.toString(),\n        limit: limit.toString(),\n        clean: clean.toString(),\n      });\n\n      const response = await this.helpers.request({\n        method: 'GET',\n        url: `${baseUrl}/datasets/${datasetId}/items?${queryParams}`,\n        headers,\n        json: true,\n      });\n\n      const batchItems = response;\n\n      if (!Array.isArray(batchItems) || batchItems.length === 0) {\n        break;\n      }\n\n      items.push(...batchItems);\n      offset += batchItems.length;\n\n      // If we got fewer items than requested, we've reached the end\n      if (batchItems.length &lt; limit) {\n        break;\n      }\n    }\n\n    return items.slice(0, maxItems);\n  }\n}\n</code></pre> <p>Apify API Credentials: <pre><code>import {\n  ICredentialType,\n  INodeProperties,\n  ICredentialTestRequest,\n} from 'n8n-workflow';\n\nexport class ApifyApi implements ICredentialType {\n  name = 'apifyApi';\n  displayName = 'Apify API';\n  documentationUrl = 'https://docs.apify.com/api/v2';\n  properties: INodeProperties[] = [\n    {\n      displayName: 'API Token',\n      name: 'apiToken',\n      type: 'string',\n      typeOptions: {\n        password: true,\n      },\n      default: '',\n      required: true,\n      description: 'Your Apify API token',\n    },\n  ];\n\n  test: ICredentialTestRequest = {\n    request: {\n      baseURL: 'https://api.apify.com/v2',\n      url: '/users/me',\n      method: 'GET',\n      headers: {\n        'Authorization': '=Bearer {{$credentials.apiToken}}',\n      },\n    },\n  };\n}\n</code></pre></p> <p>Advanced Apify Node with Error Handling: <pre><code>export class AdvancedApifyNode implements INodeType {\n  description: INodeTypeDescription = {\n    // ... base description ...\n    properties: [\n      // ... existing properties ...\n      {\n        displayName: 'Error Handling',\n        name: 'errorHandling',\n        type: 'collection',\n        placeholder: 'Add Option',\n        default: {},\n        options: [\n          {\n            displayName: 'Retry Failed Runs',\n            name: 'retryFailedRuns',\n            type: 'boolean',\n            default: false,\n            description: 'Automatically retry failed actor runs',\n          },\n          {\n            displayName: 'Max Retries',\n            name: 'maxRetries',\n            type: 'number',\n            default: 3,\n            description: 'Maximum number of retry attempts',\n          },\n          {\n            displayName: 'Continue on Empty Dataset',\n            name: 'continueOnEmpty',\n            type: 'boolean',\n            default: true,\n            description: 'Continue execution even if dataset is empty',\n          },\n        ],\n      },\n    ],\n  };\n\n  async execute(this: IExecuteFunctions): Promise&lt;INodeExecutionData[][]&gt; {\n    // Enhanced error handling and retry logic\n    const errorHandling = this.getNodeParameter('errorHandling', 0, {}) as any;\n    const retryFailedRuns = errorHandling.retryFailedRuns ?? false;\n    const maxRetries = errorHandling.maxRetries ?? 3;\n\n    if (operation === 'runActor' &amp;&amp; retryFailedRuns) {\n      let retryCount = 0;\n      let success = false;\n\n      while (!success &amp;&amp; retryCount &lt;= maxRetries) {\n        try {\n          // ... existing actor run logic ...\n          success = true;\n        } catch (error) {\n          retryCount++;\n\n          if (retryCount &gt; maxRetries) {\n            throw error;\n          }\n\n          // Wait before retry (exponential backoff)\n          const delay = Math.pow(2, retryCount) * 1000;\n          await new Promise(resolve =&gt; setTimeout(resolve, delay));\n\n          returnData.push({\n            json: {\n              retryAttempt: retryCount,\n              error: error.message,\n              nextRetryIn: `${delay}ms`,\n            },\n          });\n        }\n      }\n    }\n\n    return [returnData];\n  }\n}\n</code></pre></p> <p>Usage Examples:</p> <ol> <li> <p>Web Scraping: <pre><code>{\n  \"startUrls\": [\n    {\"url\": \"https://example.com/products\"}\n  ],\n  \"maxRequestsPerCrawl\": 100,\n  \"proxyConfiguration\": {\n    \"useApifyProxy\": true\n  }\n}\n</code></pre></p> </li> <li> <p>Data Enrichment: <pre><code>{\n  \"urls\": [\"https://company1.com\", \"https://company2.com\"],\n  \"extractEmails\": true,\n  \"extractPhones\": true\n}\n</code></pre></p> </li> <li> <p>Scheduled Monitoring:</p> </li> <li>Run actor every hour to check for changes</li> <li>Compare results with previous runs</li> <li>Send alerts on significant changes</li> </ol> <p>This Apify node demonstrates: - Async job management with polling patterns - Multi-step API workflows (start \u2192 poll \u2192 fetch results) - Robust error handling with retries and timeouts - Dataset streaming for large result sets - Flexible input handling with JSON configuration - Credential testing for API validation</p> <p>Perfect for building web scraping pipelines, data collection workflows, and automated monitoring systems!</p>"},{"location":"real-world/GlobalsNode/","title":"Globals Node","text":"<p>The Globals node is a clever hack that injects user-defined constants into the workflow using a credential as a configuration store.</p>"},{"location":"real-world/GlobalsNode/#credential","title":"Credential","text":"<pre><code>export class GlobalConstantsCredentials implements ICredentialType {\n  name = \"globalConstantsApi\"\n  displayName = \"Global Constants\"\n  properties = [\n    {\n      displayName: \"Global Constants\",\n      name: \"globalConstants\",\n      type: \"string\",\n      default: \"\",\n      placeholder: \"name1=value1\\\\nname2=value2\",\n      typeOptions: { rows: 10 },\n    },\n  ]\n}\n</code></pre>"},{"location":"real-world/GlobalsNode/#node","title":"Node","text":"<pre><code>const credentials = await this.getCredentials(\"globalConstantsApi\")\nconst constants = splitConstants(credentials.globalConstants)\n</code></pre> <ul> <li>Optionally wraps constants in a single key</li> <li>Injects constants into each item or creates a new one</li> </ul>"},{"location":"real-world/GlobalsNode/#use-cases","title":"Use Cases","text":"<ul> <li>Inject environment-specific values</li> <li>Centralize constants for reuse</li> <li>Avoid hardcoding values in workflows</li> </ul>"},{"location":"real-world/GlobalsNode/#teaching-value","title":"Teaching Value","text":"<ul> <li>Shows how credentials can be used for non-auth config</li> <li>Demonstrates flexible output shaping</li> <li>Great example of a transform node with no external API</li> </ul> <p>[TODO: inline code]</p>"},{"location":"real-world/PowerBINode/","title":"Power BI Node","text":"<p>This node integrates with Microsoft Power BI to push data into datasets using the REST API.</p>"},{"location":"real-world/PowerBINode/#key-features","title":"Key Features","text":"<ul> <li>Uses OAuth2 for authentication</li> <li>Supports streaming rows into a dataset</li> <li>Can create or update datasets dynamically</li> </ul>"},{"location":"real-world/PowerBINode/#implementation-highlights","title":"Implementation Highlights","text":"<ul> <li>Uses <code>oAuth2Api</code> credential with Microsoft endpoints</li> <li>Constructs dataset schema from input data</li> <li>Sends rows using <code>POST /datasets/{id}/tables/{name}/rows</code></li> </ul>"},{"location":"real-world/PowerBINode/#use-cases","title":"Use Cases","text":"<ul> <li>Real-time dashboards</li> <li>Business intelligence pipelines</li> <li>Automated reporting</li> </ul>"},{"location":"real-world/PowerBINode/#teaching-value","title":"Teaching Value","text":"<ul> <li>Demonstrates OAuth2 integration with Microsoft</li> <li>Shows how to map JSON to tabular schema</li> <li>Good example of a data sink node</li> </ul>"},{"location":"real-world/PowerBINode/#complete-power-bi-integration-implementation","title":"Complete Power BI Integration Implementation","text":"<p>Here's a full Power BI node that pushes data to datasets using OAuth2 authentication:</p> <pre><code>import {\n  IExecuteFunctions,\n  INodeExecutionData,\n  INodeType,\n  INodeTypeDescription,\n  NodeApiError,\n  NodeOperationError,\n} from 'n8n-workflow';\n\nexport class PowerBINode implements INodeType {\n  description: INodeTypeDescription = {\n    displayName: 'Power BI',\n    name: 'powerBI',\n    icon: 'file:powerbi.svg',\n    group: ['output'],\n    version: 1,\n    description: 'Push data to Microsoft Power BI datasets',\n    defaults: {\n      name: 'Power BI',\n    },\n    inputs: ['main'],\n    outputs: ['main'],\n    credentials: [\n      {\n        name: 'powerBIApi',\n        required: true,\n      },\n    ],\n    properties: [\n      {\n        displayName: 'Operation',\n        name: 'operation',\n        type: 'options',\n        noDataExpression: true,\n        options: [\n          {\n            name: 'Push Rows',\n            value: 'pushRows',\n            description: 'Add rows to an existing dataset table',\n            action: 'Push rows to a dataset table',\n          },\n          {\n            name: 'Create Dataset',\n            value: 'createDataset',\n            description: 'Create a new dataset with schema',\n            action: 'Create a new dataset',\n          },\n          {\n            name: 'Get Datasets',\n            value: 'getDatasets',\n            description: 'List all datasets in workspace',\n            action: 'Get all datasets',\n          },\n        ],\n        default: 'pushRows',\n      },\n      {\n        displayName: 'Workspace ID',\n        name: 'workspaceId',\n        type: 'string',\n        default: '',\n        required: true,\n        description: 'Power BI workspace (group) ID',\n        placeholder: 'f089354e-8366-4e18-aea3-4cb4a3a50b48',\n      },\n      {\n        displayName: 'Dataset ID',\n        name: 'datasetId',\n        type: 'string',\n        default: '',\n        required: true,\n        displayOptions: {\n          show: {\n            operation: ['pushRows'],\n          },\n        },\n        description: 'ID of the dataset to push data to',\n        placeholder: 'cfafbeb1-8037-4d0c-896e-a46fb27ff229',\n      },\n      {\n        displayName: 'Table Name',\n        name: 'tableName',\n        type: 'string',\n        default: 'Table1',\n        required: true,\n        displayOptions: {\n          show: {\n            operation: ['pushRows'],\n          },\n        },\n        description: 'Name of the table within the dataset',\n      },\n      {\n        displayName: 'Dataset Name',\n        name: 'datasetName',\n        type: 'string',\n        default: '',\n        required: true,\n        displayOptions: {\n          show: {\n            operation: ['createDataset'],\n          },\n        },\n        description: 'Name for the new dataset',\n        placeholder: 'My Dataset',\n      },\n      {\n        displayName: 'Default Mode',\n        name: 'defaultMode',\n        type: 'options',\n        options: [\n          {\n            name: 'Push',\n            value: 'Push',\n            description: 'Data is pushed to Power BI in real-time',\n          },\n          {\n            name: 'Streaming',\n            value: 'Streaming',\n            description: 'Data is streamed to Power BI',\n          },\n          {\n            name: 'Push Streaming',\n            value: 'PushStreaming',\n            description: 'Combination of Push and Streaming',\n          },\n        ],\n        default: 'Push',\n        displayOptions: {\n          show: {\n            operation: ['createDataset'],\n          },\n        },\n        description: 'Default mode for the dataset',\n      },\n      {\n        displayName: 'Auto-Create Schema',\n        name: 'autoCreateSchema',\n        type: 'boolean',\n        default: true,\n        displayOptions: {\n          show: {\n            operation: ['createDataset'],\n          },\n        },\n        description: 'Whether to automatically create schema from input data',\n      },\n      {\n        displayName: 'Batch Size',\n        name: 'batchSize',\n        type: 'number',\n        default: 1000,\n        displayOptions: {\n          show: {\n            operation: ['pushRows'],\n          },\n        },\n        description: 'Number of rows to send in each batch (max 10,000)',\n      },\n    ],\n  };\n\n  async execute(this: IExecuteFunctions): Promise&lt;INodeExecutionData[][]&gt; {\n    const items = this.getInputData();\n    const returnData: INodeExecutionData[] = [];\n    const operation = this.getNodeParameter('operation', 0) as string;\n    const workspaceId = this.getNodeParameter('workspaceId', 0) as string;\n\n    const credentials = await this.getCredentials('powerBIApi');\n    const baseUrl = 'https://api.powerbi.com/v1.0/myorg';\n\n    try {\n      if (operation === 'getDatasets') {\n        // Get all datasets in workspace\n        const response = await this.helpers.requestWithAuthentication.call(\n          this,\n          'powerBIApi',\n          {\n            method: 'GET',\n            url: `${baseUrl}/groups/${workspaceId}/datasets`,\n            json: true,\n          }\n        );\n\n        for (const dataset of response.value || []) {\n          returnData.push({\n            json: {\n              id: dataset.id,\n              name: dataset.name,\n              configuredBy: dataset.configuredBy,\n              defaultMode: dataset.defaultMode,\n              isRefreshable: dataset.isRefreshable,\n              isOnPremGatewayRequired: dataset.isOnPremGatewayRequired,\n            },\n          });\n        }\n\n      } else if (operation === 'createDataset') {\n        const datasetName = this.getNodeParameter('datasetName', 0) as string;\n        const defaultMode = this.getNodeParameter('defaultMode', 0) as string;\n        const autoCreateSchema = this.getNodeParameter('autoCreateSchema', 0) as boolean;\n\n        let tables: any[] = [];\n\n        if (autoCreateSchema &amp;&amp; items.length &gt; 0) {\n          // Auto-generate schema from first item\n          const sampleData = items[0].json;\n          const columns = Object.keys(sampleData).map(key =&gt; {\n            const value = sampleData[key];\n            let dataType = 'String';\n\n            if (typeof value === 'number') {\n              dataType = Number.isInteger(value) ? 'Int64' : 'Double';\n            } else if (typeof value === 'boolean') {\n              dataType = 'Boolean';\n            } else if (value instanceof Date || (typeof value === 'string' &amp;&amp; !isNaN(Date.parse(value)))) {\n              dataType = 'DateTime';\n            }\n\n            return {\n              name: key,\n              dataType,\n            };\n          });\n\n          tables = [{\n            name: 'Table1',\n            columns,\n          }];\n        }\n\n        const datasetPayload = {\n          name: datasetName,\n          defaultMode,\n          tables,\n        };\n\n        const response = await this.helpers.requestWithAuthentication.call(\n          this,\n          'powerBIApi',\n          {\n            method: 'POST',\n            url: `${baseUrl}/groups/${workspaceId}/datasets`,\n            body: datasetPayload,\n            json: true,\n          }\n        );\n\n        returnData.push({\n          json: {\n            id: response.id,\n            name: response.name,\n            defaultMode: response.defaultMode,\n            tables: response.tables,\n            message: 'Dataset created successfully',\n          },\n        });\n\n      } else if (operation === 'pushRows') {\n        const datasetId = this.getNodeParameter('datasetId', 0) as string;\n        const tableName = this.getNodeParameter('tableName', 0) as string;\n        const batchSize = this.getNodeParameter('batchSize', 0) as number;\n\n        // Validate batch size\n        if (batchSize &gt; 10000) {\n          throw new NodeOperationError(\n            this.getNode(),\n            'Batch size cannot exceed 10,000 rows'\n          );\n        }\n\n        // Process items in batches\n        const batches: any[][] = [];\n        for (let i = 0; i &lt; items.length; i += batchSize) {\n          batches.push(items.slice(i, i + batchSize));\n        }\n\n        let totalRowsPushed = 0;\n\n        for (let batchIndex = 0; batchIndex &lt; batches.length; batchIndex++) {\n          const batch = batches[batchIndex];\n          const rows = batch.map(item =&gt; item.json);\n\n          try {\n            await this.helpers.requestWithAuthentication.call(\n              this,\n              'powerBIApi',\n              {\n                method: 'POST',\n                url: `${baseUrl}/groups/${workspaceId}/datasets/${datasetId}/tables/${tableName}/rows`,\n                body: {\n                  rows,\n                },\n                json: true,\n              }\n            );\n\n            totalRowsPushed += rows.length;\n\n            // Add batch result to return data\n            returnData.push({\n              json: {\n                batchIndex: batchIndex + 1,\n                rowsInBatch: rows.length,\n                totalRowsPushed,\n                status: 'success',\n              },\n            });\n\n          } catch (error) {\n            if (this.continueOnFail()) {\n              returnData.push({\n                json: {\n                  batchIndex: batchIndex + 1,\n                  rowsInBatch: rows.length,\n                  error: error.message,\n                  status: 'failed',\n                },\n              });\n              continue;\n            }\n            throw error;\n          }\n        }\n\n        // Add summary\n        returnData.push({\n          json: {\n            operation: 'pushRows',\n            datasetId,\n            tableName,\n            totalBatches: batches.length,\n            totalRowsPushed,\n            summary: `Successfully pushed ${totalRowsPushed} rows in ${batches.length} batches`,\n          },\n        });\n      }\n\n    } catch (error) {\n      throw new NodeApiError(this.getNode(), error, {\n        message: `Power BI operation failed: ${error.message}`,\n        description: error.description || 'Check your credentials and parameters',\n      });\n    }\n\n    return [returnData];\n  }\n}\n</code></pre> <p>Power BI OAuth2 Credentials: <pre><code>import {\n  ICredentialType,\n  INodeProperties,\n} from 'n8n-workflow';\n\nexport class PowerBIApi implements ICredentialType {\n  name = 'powerBIApi';\n  extends = ['oAuth2Api'];\n  displayName = 'Power BI API';\n  documentationUrl = 'https://docs.microsoft.com/en-us/power-bi/developer/embedded/get-azuread-access-token';\n  properties: INodeProperties[] = [\n    {\n      displayName: 'Grant Type',\n      name: 'grantType',\n      type: 'hidden',\n      default: 'authorizationCode',\n    },\n    {\n      displayName: 'Authorization URL',\n      name: 'authUrl',\n      type: 'hidden',\n      default: 'https://login.microsoftonline.com/common/oauth2/v2.0/authorize',\n    },\n    {\n      displayName: 'Access Token URL',\n      name: 'accessTokenUrl',\n      type: 'hidden',\n      default: 'https://login.microsoftonline.com/common/oauth2/v2.0/token',\n    },\n    {\n      displayName: 'Scope',\n      name: 'scope',\n      type: 'hidden',\n      default: 'https://analysis.windows.net/powerbi/api/.default',\n    },\n    {\n      displayName: 'Auth URI Query Parameters',\n      name: 'authQueryParameters',\n      type: 'hidden',\n      default: 'response_mode=query',\n    },\n    {\n      displayName: 'Authentication',\n      name: 'authentication',\n      type: 'hidden',\n      default: 'body',\n    },\n  ];\n}\n</code></pre></p> <p>Advanced Power BI Node with Retry Logic: <pre><code>export class AdvancedPowerBINode implements INodeType {\n  description: INodeTypeDescription = {\n    displayName: 'Advanced Power BI',\n    name: 'advancedPowerBI',\n    icon: 'file:powerbi.svg',\n    group: ['output'],\n    version: 1,\n    description: 'Advanced Power BI integration with retry logic and error handling',\n    defaults: {\n      name: 'Advanced Power BI',\n    },\n    inputs: ['main'],\n    outputs: ['main'],\n    credentials: [\n      {\n        name: 'powerBIApi',\n        required: true,\n      },\n    ],\n    properties: [\n      // ... existing properties ...\n      {\n        displayName: 'Advanced Options',\n        name: 'advancedOptions',\n        type: 'collection',\n        placeholder: 'Add Option',\n        default: {},\n        options: [\n          {\n            displayName: 'Clear Table Before Insert',\n            name: 'clearTable',\n            type: 'boolean',\n            default: false,\n            description: 'Clear all rows from table before inserting new data',\n          },\n          {\n            displayName: 'Retry Failed Batches',\n            name: 'retryFailedBatches',\n            type: 'boolean',\n            default: true,\n            description: 'Retry failed batches up to 3 times',\n          },\n          {\n            displayName: 'Max Retry Attempts',\n            name: 'maxRetries',\n            type: 'number',\n            default: 3,\n            description: 'Maximum number of retry attempts for failed batches',\n          },\n        ],\n      },\n    ],\n  };\n\n  async execute(this: IExecuteFunctions): Promise&lt;INodeExecutionData[][]&gt; {\n    const items = this.getInputData();\n    const returnData: INodeExecutionData[] = [];\n    const operation = this.getNodeParameter('operation', 0) as string;\n\n    // Get advanced options\n    const advancedOptions = this.getNodeParameter('advancedOptions', 0, {}) as any;\n    const retryFailedBatches = advancedOptions.retryFailedBatches ?? true;\n    const maxRetries = advancedOptions.maxRetries ?? 3;\n    const clearTable = advancedOptions.clearTable ?? false;\n\n    if (operation === 'pushRows') {\n      const workspaceId = this.getNodeParameter('workspaceId', 0) as string;\n      const datasetId = this.getNodeParameter('datasetId', 0) as string;\n      const tableName = this.getNodeParameter('tableName', 0) as string;\n      const batchSize = this.getNodeParameter('batchSize', 0) as number;\n      const baseUrl = 'https://api.powerbi.com/v1.0/myorg';\n\n      // Clear table if requested\n      if (clearTable) {\n        try {\n          await this.helpers.requestWithAuthentication.call(\n            this,\n            'powerBIApi',\n            {\n              method: 'DELETE',\n              url: `${baseUrl}/groups/${workspaceId}/datasets/${datasetId}/tables/${tableName}/rows`,\n              json: true,\n            }\n          );\n\n          returnData.push({\n            json: {\n              operation: 'clearTable',\n              status: 'success',\n              message: 'Table cleared successfully',\n            },\n          });\n        } catch (error) {\n          throw new NodeApiError(this.getNode(), error, {\n            message: 'Failed to clear table before insert',\n          });\n        }\n      }\n\n      // Process items in batches with retry logic\n      const batches: any[][] = [];\n      for (let i = 0; i &lt; items.length; i += batchSize) {\n        batches.push(items.slice(i, i + batchSize));\n      }\n\n      let totalRowsPushed = 0;\n      let totalFailedBatches = 0;\n\n      for (let batchIndex = 0; batchIndex &lt; batches.length; batchIndex++) {\n        const batch = batches[batchIndex];\n        let retryCount = 0;\n        let success = false;\n\n        while (!success &amp;&amp; retryCount &lt;= maxRetries) {\n          try {\n            const rows = batch.map(item =&gt; item.json);\n\n            await this.helpers.requestWithAuthentication.call(\n              this,\n              'powerBIApi',\n              {\n                method: 'POST',\n                url: `${baseUrl}/groups/${workspaceId}/datasets/${datasetId}/tables/${tableName}/rows`,\n                body: { rows },\n                json: true,\n              }\n            );\n\n            success = true;\n            totalRowsPushed += rows.length;\n\n            returnData.push({\n              json: {\n                batchIndex: batchIndex + 1,\n                rowsInBatch: rows.length,\n                retryCount,\n                status: 'success',\n              },\n            });\n\n          } catch (error) {\n            retryCount++;\n\n            if (retryCount &gt; maxRetries || !retryFailedBatches) {\n              totalFailedBatches++;\n\n              if (this.continueOnFail()) {\n                returnData.push({\n                  json: {\n                    batchIndex: batchIndex + 1,\n                    rowsInBatch: batch.length,\n                    retryCount: retryCount - 1,\n                    error: error.message,\n                    status: 'failed',\n                  },\n                });\n                break;\n              }\n              throw error;\n            }\n\n            // Wait before retry (exponential backoff)\n            const delay = Math.pow(2, retryCount) * 1000;\n            await new Promise(resolve =&gt; setTimeout(resolve, delay));\n          }\n        }\n      }\n\n      // Add final summary\n      returnData.push({\n        json: {\n          operation: 'pushRows',\n          summary: {\n            totalBatches: batches.length,\n            successfulBatches: batches.length - totalFailedBatches,\n            failedBatches: totalFailedBatches,\n            totalRowsPushed,\n            retryEnabled: retryFailedBatches,\n            maxRetries,\n          },\n        },\n      });\n    }\n\n    return [returnData];\n  }\n}\n</code></pre></p> <p>Usage Examples:</p> <ol> <li> <p>Push Sales Data: <pre><code>{\n  \"date\": \"2023-12-01\",\n  \"product\": \"Widget A\",\n  \"sales\": 1250.50,\n  \"quantity\": 25\n}\n</code></pre></p> </li> <li> <p>Create Real-time Dashboard Dataset:</p> </li> <li>Auto-generate schema from input data</li> <li> <p>Set to \"Streaming\" mode for real-time updates</p> </li> <li> <p>Batch Upload Analytics Data:</p> </li> <li>Process 10,000 rows in batches of 1,000</li> <li>Retry failed batches automatically</li> </ol> <p>This Power BI node demonstrates: - OAuth2 integration with Microsoft Azure AD - Batch processing for large datasets - Schema auto-generation from JSON data - Error handling and retries for robust data pipelines - Multiple operations (create, push, list datasets) - Advanced options for fine-tuned control</p> <p>Perfect for building real-time business intelligence dashboards and automated reporting workflows!</p>"},{"location":"real-world/QrCodeNode/","title":"QR Code Generator Node","text":"<p>This node generates QR codes from input text using a local library or external API.</p>"},{"location":"real-world/QrCodeNode/#key-features","title":"Key Features","text":"<ul> <li>Accepts text input and outputs a QR image</li> <li>Can return base64, binary, or image URL</li> <li>Supports customization (size, error correction)</li> </ul>"},{"location":"real-world/QrCodeNode/#implementation-highlights","title":"Implementation Highlights","text":"<ul> <li>Uses <code>qrcode</code> npm package or HTTP API</li> <li>Converts text to image buffer</li> <li>Attaches image to <code>item.binary</code></li> </ul>"},{"location":"real-world/QrCodeNode/#use-cases","title":"Use Cases","text":"<ul> <li>Generate QR codes for links or IDs</li> <li>Embed QR in PDFs or emails</li> <li>Create scannable labels or tickets</li> </ul>"},{"location":"real-world/QrCodeNode/#teaching-value","title":"Teaching Value","text":"<ul> <li>Demonstrates binary output generation</li> <li>Shows how to use <code>prepareBinaryData()</code></li> <li>Great example of a utility node</li> </ul>"},{"location":"real-world/QrCodeNode/#complete-qr-code-generator-implementation","title":"Complete QR Code Generator Implementation","text":"<p>Here's a full QR code generator node that creates QR codes and returns them as binary data:</p> <pre><code>import {\n  IExecuteFunctions,\n  INodeExecutionData,\n  INodeType,\n  INodeTypeDescription,\n  NodeApiError,\n  NodeOperationError,\n} from 'n8n-workflow';\nimport * as QRCode from 'qrcode';\n\nexport class QrCodeGenerator implements INodeType {\n  description: INodeTypeDescription = {\n    displayName: 'QR Code Generator',\n    name: 'qrCodeGenerator',\n    icon: 'file:qrcode.svg',\n    group: ['transform'],\n    version: 1,\n    description: 'Generate QR codes from text input',\n    defaults: {\n      name: 'QR Code Generator',\n    },\n    inputs: ['main'],\n    outputs: ['main'],\n    properties: [\n      {\n        displayName: 'Text to Encode',\n        name: 'text',\n        type: 'string',\n        default: '',\n        required: true,\n        description: 'The text to encode in the QR code',\n        placeholder: 'https://example.com or any text',\n      },\n      {\n        displayName: 'Output Format',\n        name: 'outputFormat',\n        type: 'options',\n        options: [\n          {\n            name: 'PNG Image',\n            value: 'png',\n            description: 'Generate PNG image file',\n          },\n          {\n            name: 'SVG Vector',\n            value: 'svg',\n            description: 'Generate SVG vector file',\n          },\n          {\n            name: 'Base64 Data URL',\n            value: 'dataurl',\n            description: 'Generate base64 data URL',\n          },\n        ],\n        default: 'png',\n        description: 'The format for the QR code output',\n      },\n      {\n        displayName: 'Size (pixels)',\n        name: 'size',\n        type: 'number',\n        default: 200,\n        description: 'Size of the QR code in pixels',\n        displayOptions: {\n          show: {\n            outputFormat: ['png'],\n          },\n        },\n      },\n      {\n        displayName: 'Error Correction Level',\n        name: 'errorCorrectionLevel',\n        type: 'options',\n        options: [\n          {\n            name: 'Low (~7%)',\n            value: 'L',\n            description: 'Low error correction, smaller QR code',\n          },\n          {\n            name: 'Medium (~15%)',\n            value: 'M',\n            description: 'Medium error correction (recommended)',\n          },\n          {\n            name: 'Quartile (~25%)',\n            value: 'Q',\n            description: 'High error correction',\n          },\n          {\n            name: 'High (~30%)',\n            value: 'H',\n            description: 'Highest error correction, larger QR code',\n          },\n        ],\n        default: 'M',\n        description: 'Error correction level for the QR code',\n      },\n      {\n        displayName: 'Margin',\n        name: 'margin',\n        type: 'number',\n        default: 4,\n        description: 'Margin around the QR code (in modules)',\n      },\n      {\n        displayName: 'Dark Color',\n        name: 'darkColor',\n        type: 'string',\n        default: '#000000',\n        description: 'Color of the dark modules (hex color)',\n        placeholder: '#000000',\n      },\n      {\n        displayName: 'Light Color',\n        name: 'lightColor',\n        type: 'string',\n        default: '#FFFFFF',\n        description: 'Color of the light modules (hex color)',\n        placeholder: '#FFFFFF',\n      },\n      {\n        displayName: 'Binary Property Name',\n        name: 'binaryPropertyName',\n        type: 'string',\n        default: 'qrcode',\n        description: 'Name of the binary property to store the QR code',\n        displayOptions: {\n          show: {\n            outputFormat: ['png', 'svg'],\n          },\n        },\n      },\n    ],\n  };\n\n  async execute(this: IExecuteFunctions): Promise&lt;INodeExecutionData[][]&gt; {\n    const items = this.getInputData();\n    const returnData: INodeExecutionData[] = [];\n\n    for (let i = 0; i &lt; items.length; i++) {\n      try {\n        const text = this.getNodeParameter('text', i) as string;\n        const outputFormat = this.getNodeParameter('outputFormat', i) as string;\n        const size = this.getNodeParameter('size', i) as number;\n        const errorCorrectionLevel = this.getNodeParameter('errorCorrectionLevel', i) as 'L' | 'M' | 'Q' | 'H';\n        const margin = this.getNodeParameter('margin', i) as number;\n        const darkColor = this.getNodeParameter('darkColor', i) as string;\n        const lightColor = this.getNodeParameter('lightColor', i) as string;\n        const binaryPropertyName = this.getNodeParameter('binaryPropertyName', i) as string;\n\n        if (!text.trim()) {\n          throw new NodeOperationError(\n            this.getNode(),\n            'Text to encode cannot be empty',\n            { itemIndex: i }\n          );\n        }\n\n        // QR code generation options\n        const qrOptions: QRCode.QRCodeToBufferOptions = {\n          errorCorrectionLevel,\n          margin,\n          color: {\n            dark: darkColor,\n            light: lightColor,\n          },\n        };\n\n        let result: INodeExecutionData;\n\n        if (outputFormat === 'png') {\n          // Generate PNG buffer\n          const qrBuffer = await QRCode.toBuffer(text, {\n            ...qrOptions,\n            width: size,\n            type: 'png',\n          });\n\n          // Prepare binary data\n          const binaryData = await this.helpers.prepareBinaryData(\n            qrBuffer,\n            `qrcode_${i}.png`,\n            'image/png'\n          );\n\n          result = {\n            json: {\n              text,\n              format: 'png',\n              size,\n              errorCorrectionLevel,\n              filename: `qrcode_${i}.png`,\n            },\n            binary: {\n              [binaryPropertyName]: binaryData,\n            },\n          };\n\n        } else if (outputFormat === 'svg') {\n          // Generate SVG string\n          const svgString = await QRCode.toString(text, {\n            ...qrOptions,\n            type: 'svg',\n          });\n\n          // Convert SVG string to buffer\n          const svgBuffer = Buffer.from(svgString, 'utf8');\n\n          // Prepare binary data\n          const binaryData = await this.helpers.prepareBinaryData(\n            svgBuffer,\n            `qrcode_${i}.svg`,\n            'image/svg+xml'\n          );\n\n          result = {\n            json: {\n              text,\n              format: 'svg',\n              errorCorrectionLevel,\n              filename: `qrcode_${i}.svg`,\n              svgContent: svgString,\n            },\n            binary: {\n              [binaryPropertyName]: binaryData,\n            },\n          };\n\n        } else if (outputFormat === 'dataurl') {\n          // Generate base64 data URL\n          const dataUrl = await QRCode.toDataURL(text, {\n            ...qrOptions,\n            width: size,\n          });\n\n          result = {\n            json: {\n              text,\n              format: 'dataurl',\n              size,\n              errorCorrectionLevel,\n              dataUrl,\n              // Extract just the base64 part (without data:image/png;base64,)\n              base64: dataUrl.split(',')[1],\n            },\n          };\n\n        } else {\n          throw new NodeOperationError(\n            this.getNode(),\n            `Unsupported output format: ${outputFormat}`,\n            { itemIndex: i }\n          );\n        }\n\n        returnData.push(result);\n\n      } catch (error) {\n        if (this.continueOnFail()) {\n          returnData.push({\n            json: {\n              error: error.message,\n              item: i,\n            },\n          });\n          continue;\n        }\n\n        throw new NodeApiError(this.getNode(), error, {\n          message: `Failed to generate QR code for item ${i}`,\n          description: error.message,\n        });\n      }\n    }\n\n    return [returnData];\n  }\n}\n</code></pre> <p>Advanced QR Code Node with Special Formats: <pre><code>export class AdvancedQrCodeGenerator implements INodeType {\n  description: INodeTypeDescription = {\n    displayName: 'Advanced QR Code Generator',\n    name: 'advancedQrCodeGenerator',\n    icon: 'file:qrcode.svg',\n    group: ['transform'],\n    version: 1,\n    description: 'Generate QR codes with special formats (WiFi, vCard, etc.)',\n    defaults: {\n      name: 'Advanced QR Code Generator',\n    },\n    inputs: ['main'],\n    outputs: ['main'],\n    properties: [\n      {\n        displayName: 'Input Type',\n        name: 'inputType',\n        type: 'options',\n        options: [\n          {\n            name: 'Text',\n            value: 'text',\n            description: 'Plain text input',\n          },\n          {\n            name: 'URL',\n            value: 'url',\n            description: 'URL with validation',\n          },\n          {\n            name: 'WiFi',\n            value: 'wifi',\n            description: 'WiFi network credentials',\n          },\n          {\n            name: 'Contact (vCard)',\n            value: 'vcard',\n            description: 'Contact information',\n          },\n        ],\n        default: 'text',\n        description: 'Type of data to encode',\n      },\n      {\n        displayName: 'Text',\n        name: 'text',\n        type: 'string',\n        default: '',\n        required: true,\n        displayOptions: {\n          show: {\n            inputType: ['text'],\n          },\n        },\n        description: 'Plain text to encode',\n      },\n      {\n        displayName: 'URL',\n        name: 'url',\n        type: 'string',\n        default: '',\n        required: true,\n        displayOptions: {\n          show: {\n            inputType: ['url'],\n          },\n        },\n        description: 'URL to encode (will be validated)',\n        placeholder: 'https://example.com',\n      },\n      {\n        displayName: 'WiFi Network Name (SSID)',\n        name: 'wifiSSID',\n        type: 'string',\n        default: '',\n        required: true,\n        displayOptions: {\n          show: {\n            inputType: ['wifi'],\n          },\n        },\n        description: 'WiFi network name',\n      },\n      {\n        displayName: 'WiFi Password',\n        name: 'wifiPassword',\n        type: 'string',\n        default: '',\n        displayOptions: {\n          show: {\n            inputType: ['wifi'],\n          },\n        },\n        description: 'WiFi password (leave empty for open networks)',\n      },\n      {\n        displayName: 'WiFi Security',\n        name: 'wifiSecurity',\n        type: 'options',\n        options: [\n          { name: 'WPA/WPA2', value: 'WPA' },\n          { name: 'WEP', value: 'WEP' },\n          { name: 'Open', value: 'nopass' },\n        ],\n        default: 'WPA',\n        displayOptions: {\n          show: {\n            inputType: ['wifi'],\n          },\n        },\n        description: 'WiFi security type',\n      },\n      {\n        displayName: 'Contact Name',\n        name: 'contactName',\n        type: 'string',\n        default: '',\n        required: true,\n        displayOptions: {\n          show: {\n            inputType: ['vcard'],\n          },\n        },\n        description: 'Full name of the contact',\n      },\n      {\n        displayName: 'Phone Number',\n        name: 'contactPhone',\n        type: 'string',\n        default: '',\n        displayOptions: {\n          show: {\n            inputType: ['vcard'],\n          },\n        },\n        description: 'Phone number',\n      },\n      {\n        displayName: 'Email',\n        name: 'contactEmail',\n        type: 'string',\n        default: '',\n        displayOptions: {\n          show: {\n            inputType: ['vcard'],\n          },\n        },\n        description: 'Email address',\n      },\n    ],\n  };\n\n  async execute(this: IExecuteFunctions): Promise&lt;INodeExecutionData[][]&gt; {\n    const items = this.getInputData();\n    const returnData: INodeExecutionData[] = [];\n\n    for (let i = 0; i &lt; items.length; i++) {\n      try {\n        const inputType = this.getNodeParameter('inputType', i) as string;\n        let textToEncode: string;\n\n        // Generate content based on input type\n        switch (inputType) {\n          case 'text':\n            textToEncode = this.getNodeParameter('text', i) as string;\n            break;\n\n          case 'url':\n            const url = this.getNodeParameter('url', i) as string;\n            // Validate URL\n            try {\n              new URL(url);\n              textToEncode = url;\n            } catch {\n              throw new NodeOperationError(\n                this.getNode(),\n                `Invalid URL format: ${url}`,\n                { itemIndex: i }\n              );\n            }\n            break;\n\n          case 'wifi':\n            const ssid = this.getNodeParameter('wifiSSID', i) as string;\n            const password = this.getNodeParameter('wifiPassword', i) as string;\n            const security = this.getNodeParameter('wifiSecurity', i) as string;\n\n            // Generate WiFi QR code format\n            textToEncode = `WIFI:T:${security};S:${ssid};P:${password};;`;\n            break;\n\n          case 'vcard':\n            const name = this.getNodeParameter('contactName', i) as string;\n            const phone = this.getNodeParameter('contactPhone', i) as string;\n            const email = this.getNodeParameter('contactEmail', i) as string;\n\n            // Generate vCard format\n            textToEncode = [\n              'BEGIN:VCARD',\n              'VERSION:3.0',\n              `FN:${name}`,\n              phone ? `TEL:${phone}` : '',\n              email ? `EMAIL:${email}` : '',\n              'END:VCARD',\n            ].filter(Boolean).join('\\n');\n            break;\n\n          default:\n            throw new NodeOperationError(\n              this.getNode(),\n              `Unsupported input type: ${inputType}`,\n              { itemIndex: i }\n            );\n        }\n\n        // Generate QR code using the same logic as basic version\n        const qrBuffer = await QRCode.toBuffer(textToEncode, {\n          errorCorrectionLevel: 'M',\n          width: 200,\n        });\n\n        const binaryData = await this.helpers.prepareBinaryData(\n          qrBuffer,\n          `qrcode_${inputType}_${i}.png`,\n          'image/png'\n        );\n\n        returnData.push({\n          json: {\n            inputType,\n            originalText: textToEncode,\n            filename: `qrcode_${inputType}_${i}.png`,\n          },\n          binary: {\n            qrcode: binaryData,\n          },\n        });\n\n      } catch (error) {\n        if (this.continueOnFail()) {\n          returnData.push({\n            json: {\n              error: error.message,\n              item: i,\n            },\n          });\n          continue;\n        }\n\n        throw new NodeApiError(this.getNode(), error, {\n          message: `Failed to generate QR code for item ${i}`,\n          description: error.message,\n        });\n      }\n    }\n\n    return [returnData];\n  }\n}\n</code></pre></p> <p>Usage Examples:</p> <ol> <li>Basic Text QR Code:</li> <li>Input: \"Hello, World!\"</li> <li> <p>Output: PNG image with QR code</p> </li> <li> <p>URL QR Code:</p> </li> <li>Input: \"https://n8n.io\"</li> <li> <p>Output: Scannable link QR code</p> </li> <li> <p>WiFi QR Code:</p> </li> <li>SSID: \"MyNetwork\"</li> <li>Password: \"mypassword123\"</li> <li>Security: \"WPA\"</li> <li> <p>Output: QR code that automatically connects devices to WiFi</p> </li> <li> <p>Contact vCard:</p> </li> <li>Name: \"John Doe\"</li> <li>Phone: \"+1234567890\"</li> <li>Email: \"john@example.com\"</li> <li>Output: QR code that adds contact to phone</li> </ol> <p>This QR code generator demonstrates: - Binary data handling: Using <code>prepareBinaryData()</code> for images - Multiple output formats: PNG, SVG, and base64 data URLs - Input validation: URL validation and error handling - Specialized formats: WiFi and vCard QR codes - Customization options: Size, colors, error correction - Error handling: Graceful failures with detailed messages</p> <p>Perfect for generating scannable codes for websites, contact sharing, WiFi access, and more!</p>"},{"location":"real-world/WebSocketServerNode/","title":"WebSocket Server Node","text":"<p>This node spins up a WebSocket server inside n8n and allows external clients to send messages into a workflow.</p>"},{"location":"real-world/WebSocketServerNode/#key-features","title":"Key Features","text":"<ul> <li>Starts a WebSocket server on a configurable port</li> <li>Broadcasts messages to all connected clients</li> <li>Emits incoming messages as workflow items</li> </ul>"},{"location":"real-world/WebSocketServerNode/#implementation-highlights","title":"Implementation Highlights","text":"<ul> <li>Uses <code>ws</code> package to create a server</li> <li>Stores server instance in a global map</li> <li>Cleans up on workflow deactivation</li> </ul>"},{"location":"real-world/WebSocketServerNode/#use-cases","title":"Use Cases","text":"<ul> <li>Real-time dashboards</li> <li>External event ingestion</li> <li>Local dev tools integration</li> </ul>"},{"location":"real-world/WebSocketServerNode/#teaching-value","title":"Teaching Value","text":"<ul> <li>Shows how to manage long-lived server state</li> <li>Demonstrates use of <code>workflow.on('close')</code> for cleanup</li> <li>Great example of a trigger node with custom transport</li> </ul>"},{"location":"real-world/WebSocketServerNode/#complete-websocket-server-implementation","title":"Complete WebSocket Server Implementation","text":"<p>Here's a full WebSocket server node that manages connections and emits messages:</p> <pre><code>import {\n  ITriggerFunctions,\n  INodeType,\n  INodeTypeDescription,\n  ITriggerResponse,\n  NodeApiError,\n} from 'n8n-workflow';\nimport { Server as WebSocketServer } from 'ws';\nimport { createServer } from 'http';\n\n// Global map to store active WebSocket servers\nconst activeServers = new Map&lt;string, WebSocketServer&gt;();\n\nexport class WebSocketServerTrigger implements INodeType {\n  description: INodeTypeDescription = {\n    displayName: 'WebSocket Server',\n    name: 'webSocketServer',\n    icon: 'file:websocket.svg',\n    group: ['trigger'],\n    version: 1,\n    description: 'Start a WebSocket server and emit incoming messages',\n    defaults: {\n      name: 'WebSocket Server',\n    },\n    inputs: [],\n    outputs: ['main'],\n    properties: [\n      {\n        displayName: 'Port',\n        name: 'port',\n        type: 'number',\n        default: 8080,\n        required: true,\n        description: 'Port to run the WebSocket server on',\n      },\n      {\n        displayName: 'Path',\n        name: 'path',\n        type: 'string',\n        default: '/',\n        description: 'WebSocket endpoint path',\n      },\n      {\n        displayName: 'Max Connections',\n        name: 'maxConnections',\n        type: 'number',\n        default: 100,\n        description: 'Maximum number of concurrent connections',\n      },\n      {\n        displayName: 'Enable Heartbeat',\n        name: 'enableHeartbeat',\n        type: 'boolean',\n        default: true,\n        description: 'Send periodic ping messages to keep connections alive',\n      },\n      {\n        displayName: 'Heartbeat Interval (seconds)',\n        name: 'heartbeatInterval',\n        type: 'number',\n        default: 30,\n        displayOptions: {\n          show: {\n            enableHeartbeat: [true],\n          },\n        },\n        description: 'How often to send heartbeat pings',\n      },\n    ],\n  };\n\n  async trigger(this: ITriggerFunctions): Promise&lt;ITriggerResponse&gt; {\n    const port = this.getNodeParameter('port') as number;\n    const path = this.getNodeParameter('path') as string;\n    const maxConnections = this.getNodeParameter('maxConnections') as number;\n    const enableHeartbeat = this.getNodeParameter('enableHeartbeat') as boolean;\n    const heartbeatInterval = this.getNodeParameter('heartbeatInterval') as number;\n\n    const workflowId = this.getWorkflow().id;\n    const nodeId = this.getNode().id;\n    const serverKey = `${workflowId}-${nodeId}`;\n\n    // Check if server is already running\n    if (activeServers.has(serverKey)) {\n      throw new NodeApiError(this.getNode(), {\n        message: 'WebSocket server already running',\n        description: `A WebSocket server is already running on port ${port}`,\n      });\n    }\n\n    try {\n      // Create HTTP server for WebSocket upgrade\n      const httpServer = createServer();\n\n      // Create WebSocket server\n      const wss = new WebSocketServer({\n        server: httpServer,\n        path,\n        maxPayload: 1024 * 1024, // 1MB max message size\n      });\n\n      // Store server reference\n      activeServers.set(serverKey, wss);\n\n      // Track connections\n      const connections = new Set();\n      let heartbeatTimer: NodeJS.Timeout | null = null;\n\n      // Handle new connections\n      wss.on('connection', (ws, request) =&gt; {\n        // Check connection limit\n        if (connections.size &gt;= maxConnections) {\n          ws.close(1013, 'Server at capacity');\n          return;\n        }\n\n        connections.add(ws);\n\n        console.log(`WebSocket client connected. Total: ${connections.size}`);\n\n        // Add connection metadata\n        (ws as any).isAlive = true;\n        (ws as any).clientIp = request.socket.remoteAddress;\n        (ws as any).userAgent = request.headers['user-agent'];\n        (ws as any).connectedAt = new Date();\n\n        // Handle incoming messages\n        ws.on('message', (data) =&gt; {\n          try {\n            let message: any;\n\n            // Try to parse as JSON, fallback to string\n            try {\n              message = JSON.parse(data.toString());\n            } catch {\n              message = data.toString();\n            }\n\n            // Emit message to workflow\n            this.emit([\n              {\n                json: {\n                  message,\n                  metadata: {\n                    clientIp: (ws as any).clientIp,\n                    userAgent: (ws as any).userAgent,\n                    connectedAt: (ws as any).connectedAt,\n                    timestamp: new Date().toISOString(),\n                  },\n                },\n              },\n            ]);\n          } catch (error) {\n            console.error('Error processing WebSocket message:', error);\n          }\n        });\n\n        // Handle connection close\n        ws.on('close', (code, reason) =&gt; {\n          connections.delete(ws);\n          console.log(`WebSocket client disconnected. Code: ${code}, Reason: ${reason}. Total: ${connections.size}`);\n        });\n\n        // Handle errors\n        ws.on('error', (error) =&gt; {\n          console.error('WebSocket error:', error);\n          connections.delete(ws);\n        });\n\n        // Handle pong responses for heartbeat\n        ws.on('pong', () =&gt; {\n          (ws as any).isAlive = true;\n        });\n\n        // Send welcome message\n        ws.send(JSON.stringify({\n          type: 'welcome',\n          message: 'Connected to n8n WebSocket server',\n          timestamp: new Date().toISOString(),\n        }));\n      });\n\n      // Setup heartbeat if enabled\n      if (enableHeartbeat) {\n        heartbeatTimer = setInterval(() =&gt; {\n          wss.clients.forEach((ws) =&gt; {\n            if ((ws as any).isAlive === false) {\n              ws.terminate();\n              connections.delete(ws);\n              return;\n            }\n\n            (ws as any).isAlive = false;\n            ws.ping();\n          });\n        }, heartbeatInterval * 1000);\n      }\n\n      // Start HTTP server\n      httpServer.listen(port, () =&gt; {\n        console.log(`WebSocket server started on port ${port}${path}`);\n      });\n\n      // Cleanup function\n      const closeFunction = async () =&gt; {\n        console.log('Closing WebSocket server...');\n\n        // Clear heartbeat timer\n        if (heartbeatTimer) {\n          clearInterval(heartbeatTimer);\n        }\n\n        // Close all connections\n        wss.clients.forEach((ws) =&gt; {\n          ws.close(1001, 'Server shutting down');\n        });\n\n        // Close server\n        wss.close();\n        httpServer.close();\n\n        // Remove from active servers\n        activeServers.delete(serverKey);\n\n        console.log('WebSocket server closed');\n      };\n\n      // Register cleanup on workflow close\n      this.getWorkflow().on('close', closeFunction);\n\n      return {\n        closeFunction,\n        // Provide server info for manual operations\n        manualTriggerFunction: async () =&gt; {\n          return {\n            json: {\n              serverInfo: {\n                port,\n                path,\n                activeConnections: connections.size,\n                maxConnections,\n                heartbeatEnabled: enableHeartbeat,\n                serverUrl: `ws://localhost:${port}${path}`,\n              },\n            },\n          };\n        },\n      };\n\n    } catch (error) {\n      // Cleanup on error\n      activeServers.delete(serverKey);\n\n      throw new NodeApiError(this.getNode(), error, {\n        message: 'Failed to start WebSocket server',\n        description: error.message,\n      });\n    }\n  }\n}\n</code></pre> <p>Client Connection Example: <pre><code>// JavaScript client example\nconst ws = new WebSocket('ws://localhost:8080/');\n\nws.onopen = function() {\n  console.log('Connected to n8n WebSocket server');\n\n  // Send a message\n  ws.send(JSON.stringify({\n    type: 'user_action',\n    action: 'button_click',\n    data: { buttonId: 'submit', userId: '12345' }\n  }));\n};\n\nws.onmessage = function(event) {\n  const message = JSON.parse(event.data);\n  console.log('Received:', message);\n};\n\nws.onclose = function(event) {\n  console.log('Connection closed:', event.code, event.reason);\n};\n\nws.onerror = function(error) {\n  console.error('WebSocket error:', error);\n};\n</code></pre></p> <p>Python Client Example: <pre><code>import asyncio\nimport websockets\nimport json\n\nasync def client():\n    uri = \"ws://localhost:8080/\"\n\n    async with websockets.connect(uri) as websocket:\n        # Send a message\n        message = {\n            \"type\": \"sensor_data\",\n            \"temperature\": 23.5,\n            \"humidity\": 65.2,\n            \"timestamp\": \"2023-12-01T10:30:00Z\"\n        }\n\n        await websocket.send(json.dumps(message))\n\n        # Listen for responses\n        async for message in websocket:\n            data = json.loads(message)\n            print(f\"Received: {data}\")\n\n# Run the client\nasyncio.run(client())\n</code></pre></p> <p>This WebSocket server node demonstrates: - Server lifecycle management: Starting, tracking, and cleaning up servers - Connection handling: Managing multiple clients with limits - Message processing: Parsing JSON and emitting to workflows - Heartbeat mechanism: Keeping connections alive - Error handling: Graceful error management and cleanup - Metadata tracking: Client information and connection details</p> <p>Perfect for real-time applications, IoT data ingestion, and interactive dashboards!</p>"},{"location":"tutorial-basics/congratulations/","title":"Congratulations!","text":"<p>You have just learned the basics of Docusaurus and made some changes to the initial template.</p> <p>Docusaurus has much more to offer!</p> <p>Have 5 more minutes? Take a look at versioning and i18n.</p> <p>Anything unclear or buggy in this tutorial? Please report it!</p>"},{"location":"tutorial-basics/congratulations/#whats-next","title":"What's next?","text":"<ul> <li>Read the official documentation</li> <li>Modify your site configuration with <code>docusaurus.config.js</code></li> <li>Add navbar and footer items with <code>themeConfig</code></li> <li>Add a custom Design and Layout</li> <li>Add a search bar</li> <li>Find inspirations in the Docusaurus showcase</li> <li>Get involved in the Docusaurus Community</li> </ul>"},{"location":"tutorial-basics/create-a-blog-post/","title":"Create a Blog Post","text":"<p>Docusaurus creates a page for each blog post, but also a blog index page, a tag system, an RSS feed...</p>"},{"location":"tutorial-basics/create-a-blog-post/#create-your-first-post","title":"Create your first Post","text":"<p>Create a file at <code>blog/2021-02-28-greetings.md</code>:</p> blog/2021-02-28-greetings.md<pre><code>---\nslug: greetings\ntitle: Greetings!\nauthors:\n  - name: Joel Marcey\n    title: Co-creator of Docusaurus 1\n    url: https://github.com/JoelMarcey\n    image_url: https://github.com/JoelMarcey.png\n  - name: S\u00e9bastien Lorber\n    title: Docusaurus maintainer\n    url: https://sebastienlorber.com\n    image_url: https://github.com/slorber.png\ntags: [greetings]\n---\n\nCongratulations, you have made your first post!\n\nFeel free to play around and edit this post as much as you like.\n</code></pre> <p>A new blog post is now available at http://localhost:3000/blog/greetings.</p>"},{"location":"tutorial-basics/create-a-document/","title":"Create a Document","text":"<p>Documents are groups of pages connected through:</p> <ul> <li>a sidebar</li> <li>previous/next navigation</li> <li>versioning</li> </ul>"},{"location":"tutorial-basics/create-a-document/#create-your-first-doc","title":"Create your first Doc","text":"<p>Create a Markdown file at <code>docs/hello.md</code>:</p> docs/hello.md<pre><code># Hello\n\nThis is my **first Docusaurus document**!\n</code></pre> <p>A new document is now available at http://localhost:3000/docs/hello.</p>"},{"location":"tutorial-basics/create-a-document/#configure-the-sidebar","title":"Configure the Sidebar","text":"<p>Docusaurus automatically creates a sidebar from the <code>docs</code> folder.</p> <p>Add metadata to customize the sidebar label and position:</p>"},{"location":"tutorial-basics/create-a-document/#md-titledocshellomd-1-4","title":"```md title=\"docs/hello.md\" {1-4}","text":"<p>sidebar_label: 'Hi!' sidebar_position: 3</p>"},{"location":"tutorial-basics/create-a-document/#hello","title":"Hello","text":"<p>This is my first Docusaurus document! <pre><code>It is also possible to create your sidebar explicitly in `sidebars.js`:\n\n```js title=\"sidebars.js\"\nexport default {\n  tutorialSidebar: [\n    'intro',\n    // highlight-next-line\n    'hello',\n    {\n      type: 'category',\n      label: 'Tutorial',\n      items: ['tutorial-basics/create-a-document'],\n    },\n  ],\n};\n</code></pre></p>"},{"location":"tutorial-basics/create-a-page/","title":"Create a Page","text":"<p>Add Markdown or React files to <code>src/pages</code> to create a standalone page:</p> <ul> <li><code>src/pages/index.js</code> \u2192 <code>localhost:3000/</code></li> <li><code>src/pages/foo.md</code> \u2192 <code>localhost:3000/foo</code></li> <li><code>src/pages/foo/bar.js</code> \u2192 <code>localhost:3000/foo/bar</code></li> </ul>"},{"location":"tutorial-basics/create-a-page/#create-your-first-react-page","title":"Create your first React Page","text":"<p>Create a file at <code>src/pages/my-react-page.js</code>:</p> src/pages/my-react-page.js<pre><code>import React from 'react';\nimport Layout from '@theme/Layout';\n\nexport default function MyReactPage() {\n  return (\n    &lt;Layout&gt;\n      &lt;h1&gt;My React page&lt;/h1&gt;\n      &lt;p&gt;This is a React page&lt;/p&gt;\n    &lt;/Layout&gt;\n  );\n}\n</code></pre> <p>A new page is now available at http://localhost:3000/my-react-page.</p>"},{"location":"tutorial-basics/create-a-page/#create-your-first-markdown-page","title":"Create your first Markdown Page","text":"<p>Create a file at <code>src/pages/my-markdown-page.md</code>:</p> src/pages/my-markdown-page.md<pre><code># My Markdown page\n\nThis is a Markdown page\n</code></pre> <p>A new page is now available at http://localhost:3000/my-markdown-page.</p>"},{"location":"tutorial-basics/deploy-your-site/","title":"Deploy your site","text":"<p>Docusaurus is a static-site-generator (also called Jamstack).</p> <p>It builds your site as simple static HTML, JavaScript and CSS files.</p>"},{"location":"tutorial-basics/deploy-your-site/#build-your-site","title":"Build your site","text":"<p>Build your site for production:</p> <pre><code>npm run build\n</code></pre> <p>The static files are generated in the <code>build</code> folder.</p>"},{"location":"tutorial-basics/deploy-your-site/#deploy-your-site_1","title":"Deploy your site","text":"<p>Test your production build locally:</p> <pre><code>npm run serve\n</code></pre> <p>The <code>build</code> folder is now served at http://localhost:3000/.</p> <p>You can now deploy the <code>build</code> folder almost anywhere easily, for free or very small cost (read the Deployment Guide).</p>"},{"location":"tutorial-extras/manage-docs-versions/","title":"Manage Docs Versions","text":"<p>Docusaurus can manage multiple versions of your docs.</p>"},{"location":"tutorial-extras/manage-docs-versions/#create-a-docs-version","title":"Create a docs version","text":"<p>Release a version 1.0 of your project:</p> <pre><code>npm run docusaurus docs:version 1.0\n</code></pre> <p>The <code>docs</code> folder is copied into <code>versioned_docs/version-1.0</code> and <code>versions.json</code> is created.</p> <p>Your docs now have 2 versions:</p> <ul> <li><code>1.0</code> at <code>http://localhost:3000/docs/</code> for the version 1.0 docs</li> <li><code>current</code> at <code>http://localhost:3000/docs/next/</code> for the upcoming, unreleased docs</li> </ul>"},{"location":"tutorial-extras/manage-docs-versions/#add-a-version-dropdown","title":"Add a Version Dropdown","text":"<p>To navigate seamlessly across versions, add a version dropdown.</p> <p>Modify the <code>docusaurus.config.js</code> file:</p> docusaurus.config.js<pre><code>export default {\n  themeConfig: {\n    navbar: {\n      items: [\n        // highlight-start\n        {\n          type: 'docsVersionDropdown',\n        },\n        // highlight-end\n      ],\n    },\n  },\n};\n</code></pre> <p>The docs version dropdown appears in your navbar:</p> <p></p>"},{"location":"tutorial-extras/manage-docs-versions/#update-an-existing-version","title":"Update an existing version","text":"<p>It is possible to edit versioned docs in their respective folder:</p> <ul> <li><code>versioned_docs/version-1.0/hello.md</code> updates <code>http://localhost:3000/docs/hello</code></li> <li><code>docs/hello.md</code> updates <code>http://localhost:3000/docs/next/hello</code></li> </ul>"},{"location":"tutorial-extras/translate-your-site/","title":"Translate your site","text":"<p>Let's translate <code>docs/intro.md</code> to French.</p>"},{"location":"tutorial-extras/translate-your-site/#configure-i18n","title":"Configure i18n","text":"<p>Modify <code>docusaurus.config.js</code> to add support for the <code>fr</code> locale:</p> docusaurus.config.js<pre><code>export default {\n  i18n: {\n    defaultLocale: 'en',\n    locales: ['en', 'fr'],\n  },\n};\n</code></pre>"},{"location":"tutorial-extras/translate-your-site/#translate-a-doc","title":"Translate a doc","text":"<p>Copy the <code>docs/intro.md</code> file to the <code>i18n/fr</code> folder:</p> <pre><code>mkdir -p i18n/fr/docusaurus-plugin-content-docs/current/\n\ncp docs/intro.md i18n/fr/docusaurus-plugin-content-docs/current/intro.md\n</code></pre> <p>Translate <code>i18n/fr/docusaurus-plugin-content-docs/current/intro.md</code> in French.</p>"},{"location":"tutorial-extras/translate-your-site/#start-your-localized-site","title":"Start your localized site","text":"<p>Start your site on the French locale:</p> <pre><code>npm run start -- --locale fr\n</code></pre> <p>Your localized site is accessible at http://localhost:3000/fr/ and the <code>Getting Started</code> page is translated.</p> <p>:::caution</p> <p>In development, you can only use one locale at a time.</p> <p>:::</p>"},{"location":"tutorial-extras/translate-your-site/#add-a-locale-dropdown","title":"Add a Locale Dropdown","text":"<p>To navigate seamlessly across languages, add a locale dropdown.</p> <p>Modify the <code>docusaurus.config.js</code> file:</p> docusaurus.config.js<pre><code>export default {\n  themeConfig: {\n    navbar: {\n      items: [\n        // highlight-start\n        {\n          type: 'localeDropdown',\n        },\n        // highlight-end\n      ],\n    },\n  },\n};\n</code></pre> <p>The locale dropdown now appears in your navbar:</p> <p></p>"},{"location":"tutorial-extras/translate-your-site/#build-your-localized-site","title":"Build your localized site","text":"<p>Build your site for a specific locale:</p> <pre><code>npm run build -- --locale fr\n</code></pre> <p>Or build your site to include all the locales at once:</p> <pre><code>npm run build\n</code></pre>"},{"location":"ui-ux/CodexMetadata/","title":"Codex Metadata","text":"<p>Codex metadata enhances the node's appearance and behavior in the n8n UI and documentation.</p>"},{"location":"ui-ux/CodexMetadata/#syntax","title":"Syntax","text":"<pre><code>codex: {\n  categories: [\"Productivity\"],\n  subcategories: [\"Utilities\"],\n  resources: [\n    {\n      name: \"Documentation\",\n      url: \"https://example.com/docs\",\n    },\n  ],\n}\n</code></pre>"},{"location":"ui-ux/CodexMetadata/#use-cases","title":"Use Cases","text":"<ul> <li>Organize nodes in the UI</li> <li>Link to external docs or support</li> <li>Improve discoverability in the node picker</li> </ul>"},{"location":"ui-ux/CodexMetadata/#tips","title":"Tips","text":"<ul> <li>Use consistent categories and subcategories</li> <li>Include helpful resource links</li> <li>Keep metadata up to date</li> </ul> <p>[TODO: inline code]</p>"},{"location":"ui-ux/CollectionsAndAdditionalFields/","title":"Collections &amp; Additional Fields","text":"<p>Collections and additional fields allow you to group related parameters and support dynamic key-value input.</p>"},{"location":"ui-ux/CollectionsAndAdditionalFields/#collections","title":"Collections","text":"<pre><code>{\n  displayName: \"Options\",\n  name: \"options\",\n  type: \"collection\",\n  default: {},\n  options: [\n    {\n      displayName: \"Limit\",\n      name: \"limit\",\n      type: \"number\",\n      default: 10,\n    },\n  ],\n}\n</code></pre>"},{"location":"ui-ux/CollectionsAndAdditionalFields/#additional-fields","title":"Additional Fields","text":"<pre><code>{\n  displayName: \"Headers\",\n  name: \"headers\",\n  type: \"fixedCollection\",\n  typeOptions: { multipleValues: true },\n  default: {},\n  options: [\n    {\n      name: \"header\",\n      displayName: \"Header\",\n      values: [\n        { name: \"name\", type: \"string\" },\n        { name: \"value\", type: \"string\" },\n      ],\n    },\n  ],\n}\n</code></pre>"},{"location":"ui-ux/CollectionsAndAdditionalFields/#use-cases","title":"Use Cases","text":"<ul> <li>Optional advanced settings</li> <li>Dynamic headers, query params, or metadata</li> <li>Grouping related inputs</li> </ul> <p>[TODO: inline code]</p>"},{"location":"ui-ux/DisplayOptions/","title":"Display Options","text":"<p>Display options control when a property is shown in the UI based on other parameter values.</p>"},{"location":"ui-ux/DisplayOptions/#syntax","title":"Syntax","text":"<pre><code>displayOptions: {\n  show: {\n    operation: ['create'],\n  },\n  hide: {\n    resource: ['user'],\n  },\n}\n</code></pre>"},{"location":"ui-ux/DisplayOptions/#use-cases","title":"Use Cases","text":"<ul> <li>Show advanced fields only when needed</li> <li>Hide irrelevant options based on context</li> <li>Create dynamic, user-friendly forms</li> </ul>"},{"location":"ui-ux/DisplayOptions/#tips","title":"Tips","text":"<ul> <li>Use <code>show</code> and <code>hide</code> together for fine control</li> <li>Combine multiple conditions with AND logic</li> <li>Use <code>displayOptions: { show: { resource: ['*'] } }</code> to show for all</li> </ul>"},{"location":"ui-ux/DisplayOptions/#complete-display-options-examples","title":"Complete Display Options Examples","text":"<p>Here are comprehensive examples showing how to use <code>displayOptions</code> to create dynamic, user-friendly forms:</p>"},{"location":"ui-ux/DisplayOptions/#basic-showhide-logic","title":"Basic Show/Hide Logic","text":"<pre><code>export class DisplayOptionsExample implements INodeType {\n  description: INodeTypeDescription = {\n    displayName: 'Display Options Example',\n    name: 'displayOptionsExample',\n    group: ['transform'],\n    version: 1,\n    description: 'Demonstrates advanced display options patterns',\n    defaults: {\n      name: 'Display Options Example',\n    },\n    inputs: ['main'],\n    outputs: ['main'],\n    properties: [\n      {\n        displayName: 'Resource',\n        name: 'resource',\n        type: 'options',\n        noDataExpression: true,\n        options: [\n          {\n            name: 'User',\n            value: 'user',\n          },\n          {\n            name: 'Company',\n            value: 'company',\n          },\n          {\n            name: 'Contact',\n            value: 'contact',\n          },\n        ],\n        default: 'user',\n        description: 'The resource to work with',\n      },\n      {\n        displayName: 'Operation',\n        name: 'operation',\n        type: 'options',\n        noDataExpression: true,\n        displayOptions: {\n          show: {\n            resource: ['user'],\n          },\n        },\n        options: [\n          {\n            name: 'Create',\n            value: 'create',\n            action: 'Create a user',\n          },\n          {\n            name: 'Update',\n            value: 'update',\n            action: 'Update a user',\n          },\n          {\n            name: 'Delete',\n            value: 'delete',\n            action: 'Delete a user',\n          },\n          {\n            name: 'Get',\n            value: 'get',\n            action: 'Get a user',\n          },\n        ],\n        default: 'create',\n        description: 'The operation to perform on users',\n      },\n      {\n        displayName: 'Company Operation',\n        name: 'companyOperation',\n        type: 'options',\n        noDataExpression: true,\n        displayOptions: {\n          show: {\n            resource: ['company'],\n          },\n        },\n        options: [\n          {\n            name: 'Create Company',\n            value: 'create',\n            action: 'Create a company',\n          },\n          {\n            name: 'List Companies',\n            value: 'list',\n            action: 'List all companies',\n          },\n        ],\n        default: 'create',\n        description: 'The operation to perform on companies',\n      },\n      // User-specific fields\n      {\n        displayName: 'User ID',\n        name: 'userId',\n        type: 'string',\n        required: true,\n        displayOptions: {\n          show: {\n            resource: ['user'],\n            operation: ['update', 'delete', 'get'],\n          },\n        },\n        default: '',\n        description: 'ID of the user to operate on',\n      },\n      {\n        displayName: 'User Name',\n        name: 'userName',\n        type: 'string',\n        required: true,\n        displayOptions: {\n          show: {\n            resource: ['user'],\n            operation: ['create', 'update'],\n          },\n        },\n        default: '',\n        description: 'Name of the user',\n      },\n      {\n        displayName: 'User Email',\n        name: 'userEmail',\n        type: 'string',\n        required: true,\n        displayOptions: {\n          show: {\n            resource: ['user'],\n            operation: ['create', 'update'],\n          },\n        },\n        default: '',\n        description: 'Email address of the user',\n      },\n      // Company-specific fields\n      {\n        displayName: 'Company Name',\n        name: 'companyName',\n        type: 'string',\n        required: true,\n        displayOptions: {\n          show: {\n            resource: ['company'],\n            companyOperation: ['create'],\n          },\n        },\n        default: '',\n        description: 'Name of the company',\n      },\n      {\n        displayName: 'Industry',\n        name: 'industry',\n        type: 'options',\n        displayOptions: {\n          show: {\n            resource: ['company'],\n            companyOperation: ['create'],\n          },\n        },\n        options: [\n          { name: 'Technology', value: 'tech' },\n          { name: 'Healthcare', value: 'healthcare' },\n          { name: 'Finance', value: 'finance' },\n          { name: 'Other', value: 'other' },\n        ],\n        default: 'tech',\n        description: 'Industry of the company',\n      },\n    ],\n  };\n\n  async execute(this: IExecuteFunctions): Promise&lt;INodeExecutionData[][]&gt; {\n    const items = this.getInputData();\n    const returnData: INodeExecutionData[] = [];\n\n    for (let i = 0; i &lt; items.length; i++) {\n      const resource = this.getNodeParameter('resource', i) as string;\n\n      if (resource === 'user') {\n        const operation = this.getNodeParameter('operation', i) as string;\n        const result: any = { resource, operation };\n\n        if (operation === 'create' || operation === 'update') {\n          result.userName = this.getNodeParameter('userName', i);\n          result.userEmail = this.getNodeParameter('userEmail', i);\n        }\n\n        if (operation === 'update' || operation === 'delete' || operation === 'get') {\n          result.userId = this.getNodeParameter('userId', i);\n        }\n\n        returnData.push({ json: result });\n\n      } else if (resource === 'company') {\n        const companyOperation = this.getNodeParameter('companyOperation', i) as string;\n        const result: any = { resource, operation: companyOperation };\n\n        if (companyOperation === 'create') {\n          result.companyName = this.getNodeParameter('companyName', i);\n          result.industry = this.getNodeParameter('industry', i);\n        }\n\n        returnData.push({ json: result });\n      }\n    }\n\n    return [returnData];\n  }\n}\n</code></pre>"},{"location":"ui-ux/DisplayOptions/#advanced-display-options-with-hide-logic","title":"Advanced Display Options with Hide Logic","text":"<pre><code>export class AdvancedDisplayOptions implements INodeType {\n  description: INodeTypeDescription = {\n    displayName: 'Advanced Display Options',\n    name: 'advancedDisplayOptions',\n    group: ['transform'],\n    version: 1,\n    description: 'Advanced display options with show and hide logic',\n    defaults: {\n      name: 'Advanced Display Options',\n    },\n    inputs: ['main'],\n    outputs: ['main'],\n    properties: [\n      {\n        displayName: 'Authentication Method',\n        name: 'authMethod',\n        type: 'options',\n        options: [\n          { name: 'API Key', value: 'apiKey' },\n          { name: 'OAuth2', value: 'oauth2' },\n          { name: 'Basic Auth', value: 'basic' },\n          { name: 'No Auth', value: 'none' },\n        ],\n        default: 'apiKey',\n        description: 'Method to use for authentication',\n      },\n      {\n        displayName: 'API Key',\n        name: 'apiKey',\n        type: 'string',\n        typeOptions: {\n          password: true,\n        },\n        displayOptions: {\n          show: {\n            authMethod: ['apiKey'],\n          },\n        },\n        default: '',\n        description: 'Your API key',\n      },\n      {\n        displayName: 'Username',\n        name: 'username',\n        type: 'string',\n        displayOptions: {\n          show: {\n            authMethod: ['basic'],\n          },\n        },\n        default: '',\n        description: 'Username for basic authentication',\n      },\n      {\n        displayName: 'Password',\n        name: 'password',\n        type: 'string',\n        typeOptions: {\n          password: true,\n        },\n        displayOptions: {\n          show: {\n            authMethod: ['basic'],\n          },\n        },\n        default: '',\n        description: 'Password for basic authentication',\n      },\n      {\n        displayName: 'OAuth2 Settings',\n        name: 'oauth2Settings',\n        type: 'collection',\n        placeholder: 'Add OAuth2 Setting',\n        displayOptions: {\n          show: {\n            authMethod: ['oauth2'],\n          },\n        },\n        default: {},\n        options: [\n          {\n            displayName: 'Client ID',\n            name: 'clientId',\n            type: 'string',\n            default: '',\n            description: 'OAuth2 client ID',\n          },\n          {\n            displayName: 'Client Secret',\n            name: 'clientSecret',\n            type: 'string',\n            typeOptions: {\n              password: true,\n            },\n            default: '',\n            description: 'OAuth2 client secret',\n          },\n          {\n            displayName: 'Scope',\n            name: 'scope',\n            type: 'string',\n            default: 'read write',\n            description: 'OAuth2 scope',\n          },\n        ],\n      },\n      {\n        displayName: 'Request Method',\n        name: 'method',\n        type: 'options',\n        options: [\n          { name: 'GET', value: 'GET' },\n          { name: 'POST', value: 'POST' },\n          { name: 'PUT', value: 'PUT' },\n          { name: 'DELETE', value: 'DELETE' },\n        ],\n        default: 'GET',\n        description: 'HTTP method to use',\n      },\n      {\n        displayName: 'Request Body',\n        name: 'body',\n        type: 'json',\n        displayOptions: {\n          show: {\n            method: ['POST', 'PUT'],\n          },\n          hide: {\n            authMethod: ['none'],\n          },\n        },\n        default: '{}',\n        description: 'Request body (JSON)',\n      },\n      {\n        displayName: 'Advanced Options',\n        name: 'advancedOptions',\n        type: 'collection',\n        placeholder: 'Add Option',\n        default: {},\n        displayOptions: {\n          hide: {\n            authMethod: ['none'],\n          },\n        },\n        options: [\n          {\n            displayName: 'Timeout (ms)',\n            name: 'timeout',\n            type: 'number',\n            default: 5000,\n            description: 'Request timeout in milliseconds',\n          },\n          {\n            displayName: 'Retry Count',\n            name: 'retryCount',\n            type: 'number',\n            default: 3,\n            description: 'Number of retry attempts',\n          },\n        ],\n      },\n      {\n        displayName: 'Debug Mode',\n        name: 'debugMode',\n        type: 'boolean',\n        default: false,\n        description: 'Enable debug logging',\n        displayOptions: {\n          show: {\n            authMethod: ['apiKey', 'oauth2', 'basic'],\n          },\n        },\n      },\n    ],\n  };\n\n  async execute(this: IExecuteFunctions): Promise&lt;INodeExecutionData[][]&gt; {\n    const items = this.getInputData();\n    const returnData: INodeExecutionData[] = [];\n\n    for (let i = 0; i &lt; items.length; i++) {\n      const authMethod = this.getNodeParameter('authMethod', i) as string;\n      const method = this.getNodeParameter('method', i) as string;\n      const debugMode = this.getNodeParameter('debugMode', i, false) as boolean;\n\n      const result: any = {\n        authMethod,\n        method,\n        debugMode,\n      };\n\n      // Add auth-specific data\n      if (authMethod === 'apiKey') {\n        result.apiKey = this.getNodeParameter('apiKey', i);\n      } else if (authMethod === 'basic') {\n        result.username = this.getNodeParameter('username', i);\n        result.password = this.getNodeParameter('password', i);\n      } else if (authMethod === 'oauth2') {\n        result.oauth2Settings = this.getNodeParameter('oauth2Settings', i, {});\n      }\n\n      // Add body for POST/PUT requests\n      if (method === 'POST' || method === 'PUT') {\n        const bodyParam = this.getNodeParameter('body', i, '{}') as string;\n        try {\n          result.body = JSON.parse(bodyParam);\n        } catch (error) {\n          result.body = bodyParam;\n        }\n      }\n\n      // Add advanced options if auth is not 'none'\n      if (authMethod !== 'none') {\n        result.advancedOptions = this.getNodeParameter('advancedOptions', i, {});\n      }\n\n      returnData.push({ json: result });\n    }\n\n    return [returnData];\n  }\n}\n</code></pre> <p>Key Display Options Patterns:</p> <ol> <li> <p>Basic Show Logic: <pre><code>displayOptions: {\n  show: {\n    operation: ['create', 'update'],\n  },\n}\n</code></pre></p> </li> <li> <p>Multiple Conditions (AND logic): <pre><code>displayOptions: {\n  show: {\n    resource: ['user'],\n    operation: ['create'],\n  },\n}\n</code></pre></p> </li> <li> <p>Hide Logic: <pre><code>displayOptions: {\n  hide: {\n    authMethod: ['none'],\n  },\n}\n</code></pre></p> </li> <li> <p>Combined Show and Hide: <pre><code>displayOptions: {\n  show: {\n    method: ['POST', 'PUT'],\n  },\n  hide: {\n    authMethod: ['none'],\n  },\n}\n</code></pre></p> </li> <li> <p>Wildcard Matching: <pre><code>displayOptions: {\n  show: {\n    resource: ['*'], // Show for all resource values\n  },\n}\n</code></pre></p> </li> </ol> <p>These examples demonstrate how to create sophisticated, user-friendly forms that adapt based on user selections, reducing clutter and improving the overall user experience!</p>"},{"location":"ui-ux/DynamicOptions/","title":"Dynamic Options","text":"<p>Dynamic options allow you to populate dropdowns based on external data or other parameters.</p>"},{"location":"ui-ux/DynamicOptions/#syntax","title":"Syntax","text":"<pre><code>{\n  displayName: \"Project\",\n  name: \"projectId\",\n  type: \"options\",\n  typeOptions: {\n    loadOptionsMethod: \"getProjects\",\n  },\n  default: \"\",\n}\n</code></pre>"},{"location":"ui-ux/DynamicOptions/#method","title":"Method","text":"<pre><code>methods: {\n  loadOptions: {\n    async getProjects() {\n      const response = await this.helpers.request(\"https://api.example.com/projects\")\n      return response.map(project =&gt; ({\n        name: project.name,\n        value: project.id,\n      }))\n    },\n  },\n}\n</code></pre>"},{"location":"ui-ux/DynamicOptions/#use-cases","title":"Use Cases","text":"<ul> <li>Load user-specific data (e.g. workspaces, boards)</li> <li>Fetch options from an API</li> <li>Create dependent dropdowns</li> </ul> <p>[TODO: inline code]</p>"}]}